; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_timer.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_timer.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User -I"C:\Users\xuan5\Desktop\JOSONG-XS03 V3.0\Project\MDK-ARM(uV4)\RTE" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=521 -D_RTE_ -DSTM32F10X_MD -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=.\flash\obj\bsp_timer.crf ..\..\User\bsp\bsp_timer.c]
                          THUMB

                          AREA ||i.SysTick_ISR||, CODE, READONLY, ALIGN=2

                  SysTick_ISR PROC
;;;53     */
;;;54     void SysTick_ISR(void)
000000  b510              PUSH     {r4,lr}
;;;55     {
;;;56     	static uint8_t s_count = 0;
;;;57     	uint8_t i;
;;;58     
;;;59     	for (i = 0; i < TMR_COUNT; i++)
000002  2400              MOVS     r4,#0
000004  e006              B        |L1.20|
                  |L1.6|
;;;60     	{
;;;61     		bsp_SoftTimerDec(&g_Tmr[i]);
000006  4911              LDR      r1,|L1.76|
000008  eb0100c4          ADD      r0,r1,r4,LSL #3
00000c  f7fffffe          BL       bsp_SoftTimerDec
000010  1c60              ADDS     r0,r4,#1              ;59
000012  b2c4              UXTB     r4,r0                 ;59
                  |L1.20|
000014  2c04              CMP      r4,#4                 ;59
000016  dbf6              BLT      |L1.6|
;;;62     	}
;;;63     
;;;64     	g_iRunTime++;	/* 全局运行时间每1ms增1 */	
000018  480d              LDR      r0,|L1.80|
00001a  6800              LDR      r0,[r0,#0]  ; g_iRunTime
00001c  1c40              ADDS     r0,r0,#1
00001e  490c              LDR      r1,|L1.80|
000020  6008              STR      r0,[r1,#0]  ; g_iRunTime
;;;65     	if (g_iRunTime == 0x7FFFFFFF)
000022  4608              MOV      r0,r1
000024  6800              LDR      r0,[r0,#0]  ; g_iRunTime
000026  f06f4100          MVN      r1,#0x80000000
00002a  4288              CMP      r0,r1
00002c  d102              BNE      |L1.52|
;;;66     	{
;;;67     		g_iRunTime = 0;
00002e  2000              MOVS     r0,#0
000030  4907              LDR      r1,|L1.80|
000032  6008              STR      r0,[r1,#0]  ; g_iRunTime
                  |L1.52|
;;;68     	}
;;;69     		
;;;70     	if (++s_count >= 10)
000034  4807              LDR      r0,|L1.84|
000036  7800              LDRB     r0,[r0,#0]  ; s_count
000038  1c40              ADDS     r0,r0,#1
00003a  b2c0              UXTB     r0,r0
00003c  4905              LDR      r1,|L1.84|
00003e  7008              STRB     r0,[r1,#0]
000040  280a              CMP      r0,#0xa
000042  db01              BLT      |L1.72|
;;;71     	{
;;;72     		s_count = 0;
000044  2000              MOVS     r0,#0
000046  7008              STRB     r0,[r1,#0]
                  |L1.72|
;;;73     
;;;74     
;;;75     
;;;76     		/* 
;;;77     			下面的代码实现所有按键的检测。按键检测每隔10ms一次就行了，一般做40ms的滤波处理就可以
;;;78     			有效过滤掉机械动作造成的按键抖动。
;;;79     		*/
;;;80     		//bsp_KeyPro();		/* 该函数在 bsp_button.c 中实现 */
;;;81     	}
;;;82     }
000048  bd10              POP      {r4,pc}
;;;83     
                          ENDP

00004a  0000              DCW      0x0000
                  |L1.76|
                          DCD      g_Tmr
                  |L1.80|
                          DCD      g_iRunTime
                  |L1.84|
                          DCD      s_count

                          AREA ||i.__set_PRIMASK||, CODE, READONLY, ALIGN=1

                  __set_PRIMASK PROC
;;;986     */
;;;987    static __INLINE void __set_PRIMASK(uint32_t priMask)
000000  f3808810          MSR      PRIMASK,r0
;;;988    {
;;;989      register uint32_t __regPriMask         __ASM("primask");
;;;990      __regPriMask = (priMask);
;;;991    }
000004  4770              BX       lr
;;;992    
                          ENDP


                          AREA ||i.bsp_CheckTimer||, CODE, READONLY, ALIGN=2

                  bsp_CheckTimer PROC
;;;173    */
;;;174    uint8_t bsp_CheckTimer(uint8_t _id)
000000  4601              MOV      r1,r0
;;;175    {
;;;176    	if (_id >= TMR_COUNT)
000002  2904              CMP      r1,#4
000004  db01              BLT      |L3.10|
;;;177    	{
;;;178    		return 0;
000006  2000              MOVS     r0,#0
                  |L3.8|
;;;179    	}
;;;180    
;;;181    	if (g_Tmr[_id].flag == 1)
;;;182    	{
;;;183    		g_Tmr[_id].flag = 0;
;;;184    		return 1;
;;;185    	}
;;;186    	else
;;;187    	{
;;;188    		return 0;
;;;189    	}
;;;190    }
000008  4770              BX       lr
                  |L3.10|
00000a  4807              LDR      r0,|L3.40|
00000c  eb0000c1          ADD      r0,r0,r1,LSL #3       ;181
000010  7900              LDRB     r0,[r0,#4]            ;181
000012  2801              CMP      r0,#1                 ;181
000014  d106              BNE      |L3.36|
000016  2000              MOVS     r0,#0                 ;183
000018  4a03              LDR      r2,|L3.40|
00001a  eb0202c1          ADD      r2,r2,r1,LSL #3       ;183
00001e  7110              STRB     r0,[r2,#4]            ;183
000020  2001              MOVS     r0,#1                 ;184
000022  e7f1              B        |L3.8|
                  |L3.36|
000024  2000              MOVS     r0,#0                 ;188
000026  e7ef              B        |L3.8|
;;;191    
                          ENDP

                  |L3.40|
                          DCD      g_Tmr

                          AREA ||i.bsp_DelayMS||, CODE, READONLY, ALIGN=2

                  bsp_DelayMS PROC
;;;114    */
;;;115    void bsp_DelayMS(uint32_t n)
000000  b510              PUSH     {r4,lr}
;;;116    {
000002  4604              MOV      r4,r0
;;;117    	/* 避免 n = 1 出现主程序死锁 */
;;;118    	if (n <= 1)
000004  2c01              CMP      r4,#1
000006  d800              BHI      |L4.10|
;;;119    	{
;;;120    		n = 2;
000008  2402              MOVS     r4,#2
                  |L4.10|
;;;121    	}
;;;122    	
;;;123    	__set_PRIMASK(1);  		/* 关中断 */
00000a  2001              MOVS     r0,#1
00000c  f7fffffe          BL       __set_PRIMASK
;;;124    	g_Tmr[0].count = n;
000010  4808              LDR      r0,|L4.52|
000012  6004              STR      r4,[r0,#0]  ; g_Tmr
;;;125    	g_Tmr[0].flag = 0;
000014  2000              MOVS     r0,#0
000016  4907              LDR      r1,|L4.52|
000018  7108              STRB     r0,[r1,#4]
;;;126    	__set_PRIMASK(0);  		/* 开中断 */
00001a  f7fffffe          BL       __set_PRIMASK
;;;127    
;;;128    	while (1)
00001e  e006              B        |L4.46|
                  |L4.32|
;;;129    	{
;;;130    		CPU_IDLE();	/* 此处是空操作。用户可以定义，让CPU进入IDLE状态，以降低功耗；或实现喂狗 */
000020  f7fffffe          BL       CPU_IDLE
;;;131    
;;;132    		/* 等待延迟时间到 */
;;;133    		if (g_Tmr[0].flag == 1)
000024  4803              LDR      r0,|L4.52|
000026  7900              LDRB     r0,[r0,#4]  ; g_Tmr
000028  2801              CMP      r0,#1
00002a  d100              BNE      |L4.46|
;;;134    		{
;;;135    			break;
00002c  e000              B        |L4.48|
                  |L4.46|
00002e  e7f7              B        |L4.32|
                  |L4.48|
000030  bf00              NOP      
;;;136    		}
;;;137    	}
;;;138    }
000032  bd10              POP      {r4,pc}
;;;139    
                          ENDP

                  |L4.52|
                          DCD      g_Tmr

                          AREA ||i.bsp_GetRunTime||, CODE, READONLY, ALIGN=2

                  bsp_GetRunTime PROC
;;;199    */
;;;200    int32_t bsp_GetRunTime(void)
000000  b510              PUSH     {r4,lr}
;;;201    {
;;;202    	int runtime; 
;;;203    
;;;204    	__set_PRIMASK(1);  		/* 关中断 */
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       __set_PRIMASK
;;;205    	
;;;206    	runtime = g_iRunTime;	/* 由于在Systick中断被改写，因此关中断进行保护 */
000008  4803              LDR      r0,|L5.24|
00000a  6804              LDR      r4,[r0,#0]  ; g_iRunTime
;;;207    		
;;;208    	__set_PRIMASK(0);  		/* 开中断 */
00000c  2000              MOVS     r0,#0
00000e  f7fffffe          BL       __set_PRIMASK
;;;209    
;;;210    	return runtime;
000012  4620              MOV      r0,r4
;;;211    }
000014  bd10              POP      {r4,pc}
                          ENDP

000016  0000              DCW      0x0000
                  |L5.24|
                          DCD      g_iRunTime

                          AREA ||i.bsp_InitTimer||, CODE, READONLY, ALIGN=2

                  bsp_InitTimer PROC
;;;20     
;;;21     void bsp_InitTimer(void)
000000  2000              MOVS     r0,#0
;;;22     {
;;;23     	uint8_t i;
;;;24     	
;;;25     	/* 清零所有的软件定时器 */
;;;26     	for (i = 0; i < TMR_COUNT; i++)
000002  e008              B        |L6.22|
                  |L6.4|
;;;27     	{
;;;28     		g_Tmr[i].count = 0;
000004  2100              MOVS     r1,#0
000006  4a05              LDR      r2,|L6.28|
000008  f8421030          STR      r1,[r2,r0,LSL #3]
;;;29     		g_Tmr[i].flag = 0;
00000c  eb0202c0          ADD      r2,r2,r0,LSL #3
000010  7111              STRB     r1,[r2,#4]
000012  1c41              ADDS     r1,r0,#1              ;26
000014  b2c8              UXTB     r0,r1                 ;26
                  |L6.22|
000016  2804              CMP      r0,#4                 ;26
000018  dbf4              BLT      |L6.4|
;;;30     	}
;;;31     	
;;;32     	/* 
;;;33     		配置systic中断周期为1ms，并启动systick中断。
;;;34         	这个函数在 \Libraries\CMSIS\CM3\CoreSupport\core_cm3.h 
;;;35         	
;;;36         	Systick中断向量在(\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\startup\arm\
;;;37         		startup_stm32f10x_hd.s 文件中定义为 SysTick_Handler。
;;;38         	SysTick_Handler函数的实现在stm32f10x_it.c 文件。
;;;39         	SysTick_Handler函数调用了SysTick_ISR()函数，在本文件末尾。
;;;40         */	
;;;41     //	SysTick_Config(SystemCoreClock / 16000);
;;;42     //	SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK_Div8);	//选择外部时钟  HCLK/8
;;;43     	//SysTick_Config(1600);
;;;44     }
00001a  4770              BX       lr
;;;45     
                          ENDP

                  |L6.28|
                          DCD      g_Tmr

                          AREA ||i.bsp_SoftTimerDec||, CODE, READONLY, ALIGN=1

                  bsp_SoftTimerDec PROC
;;;91     */
;;;92     static void bsp_SoftTimerDec(SOFT_TMR *_tmr)
000000  7901              LDRB     r1,[r0,#4]
;;;93     {
;;;94     	if (_tmr->flag == 0)
000002  b939              CBNZ     r1,|L7.20|
;;;95     	{
;;;96     		if (_tmr->count > 0)
000004  6801              LDR      r1,[r0,#0]
000006  b129              CBZ      r1,|L7.20|
;;;97     		{
;;;98     			/* 如果定时器变量减到1则设置定时器到达标志 */
;;;99     			if (--_tmr->count == 0)
000008  6801              LDR      r1,[r0,#0]
00000a  1e49              SUBS     r1,r1,#1
00000c  6001              STR      r1,[r0,#0]
00000e  b909              CBNZ     r1,|L7.20|
;;;100    			{
;;;101    				_tmr->flag = 1;
000010  2101              MOVS     r1,#1
000012  7101              STRB     r1,[r0,#4]
                  |L7.20|
;;;102    			}
;;;103    		}
;;;104    	}
;;;105    }
000014  4770              BX       lr
;;;106    
                          ENDP


                          AREA ||i.bsp_StartTimer||, CODE, READONLY, ALIGN=2

                  bsp_StartTimer PROC
;;;149    */
;;;150    void bsp_StartTimer(uint8_t _id, uint32_t _period)
000000  b570              PUSH     {r4-r6,lr}
;;;151    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;152    	if (_id >= TMR_COUNT)
000006  2c04              CMP      r4,#4
000008  db00              BLT      |L8.12|
                  |L8.10|
;;;153    	{
;;;154    		/* while(1); 死机 */
;;;155    		return;
;;;156    	}
;;;157    
;;;158    	__set_PRIMASK(1);  		/* 关中断 */
;;;159    	g_Tmr[_id].count = _period;
;;;160    	g_Tmr[_id].flag = 0;
;;;161    	__set_PRIMASK(0);  		/* 开中断 */
;;;162    }
00000a  bd70              POP      {r4-r6,pc}
                  |L8.12|
00000c  2001              MOVS     r0,#1                 ;158
00000e  f7fffffe          BL       __set_PRIMASK
000012  4806              LDR      r0,|L8.44|
000014  f8405034          STR      r5,[r0,r4,LSL #3]     ;159
000018  2000              MOVS     r0,#0                 ;160
00001a  4904              LDR      r1,|L8.44|
00001c  eb0101c4          ADD      r1,r1,r4,LSL #3       ;160
000020  7108              STRB     r0,[r1,#4]            ;160
000022  f7fffffe          BL       __set_PRIMASK
000026  bf00              NOP      
000028  e7ef              B        |L8.10|
;;;163    
                          ENDP

00002a  0000              DCW      0x0000
                  |L8.44|
                          DCD      g_Tmr

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_Tmr
                          %        32

                          AREA ||.data||, DATA, ALIGN=2

                  g_iRunTime
                          DCD      0x00000000
                  s_count
000004  00                DCB      0x00
