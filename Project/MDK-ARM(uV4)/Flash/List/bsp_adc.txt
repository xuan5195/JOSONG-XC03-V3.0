; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_adc.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_adc.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User -I"C:\Users\xuan5\Desktop\JOSONG-XS03 V3.0\Project\MDK-ARM(uV4)\RTE" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=521 -D_RTE_ -DSTM32F10X_MD -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=.\flash\obj\bsp_adc.crf ..\..\User\bsp\bsp_ADC.c]
                          THUMB

                          AREA ||i.Adc_Init||, CODE, READONLY, ALIGN=2

                  Adc_Init PROC
;;;5      //这里我们仅以规则通道为例
;;;6      void  Adc_Init(void)
000000  b500              PUSH     {lr}
;;;7      { 	
000002  b087              SUB      sp,sp,#0x1c
;;;8      	ADC_InitTypeDef ADC_InitStructure; 
;;;9      	GPIO_InitTypeDef GPIO_InitStructure;
;;;10     
;;;11     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA |RCC_APB2Periph_ADC1	, ENABLE );	  //使能ADC1通道时钟
000004  2101              MOVS     r1,#1
000006  f44f7001          MOV      r0,#0x204
00000a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;12      
;;;13     
;;;14     	RCC_ADCCLKConfig(RCC_PCLK2_Div6);   //设置ADC分频因子6 72M/6=12,ADC最大时间不能超过14M
00000e  f44f4000          MOV      r0,#0x8000
000012  f7fffffe          BL       RCC_ADCCLKConfig
;;;15     
;;;16     	//PA1 作为模拟通道输入引脚                         
;;;17     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;
000016  2002              MOVS     r0,#2
000018  f8ad0004          STRH     r0,[sp,#4]
;;;18     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;		//模拟输入引脚
00001c  2000              MOVS     r0,#0
00001e  f88d0007          STRB     r0,[sp,#7]
;;;19     	GPIO_Init(GPIOA, &GPIO_InitStructure);	
000022  a901              ADD      r1,sp,#4
000024  4817              LDR      r0,|L1.132|
000026  f7fffffe          BL       GPIO_Init
;;;20     
;;;21     	ADC_DeInit(ADC1);  //复位ADC1 
00002a  4817              LDR      r0,|L1.136|
00002c  f7fffffe          BL       ADC_DeInit
;;;22     
;;;23     	ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;	//ADC工作模式:ADC1和ADC2工作在独立模式
000030  2000              MOVS     r0,#0
000032  9002              STR      r0,[sp,#8]
;;;24     	ADC_InitStructure.ADC_ScanConvMode = DISABLE;	//模数转换工作在单通道模式
000034  f88d000c          STRB     r0,[sp,#0xc]
;;;25     	ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;	//模数转换工作在单次转换模式
000038  f88d000d          STRB     r0,[sp,#0xd]
;;;26     	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;	//转换由软件而不是外部触发启动
00003c  f44f2060          MOV      r0,#0xe0000
000040  9004              STR      r0,[sp,#0x10]
;;;27     	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;	//ADC数据右对齐
000042  2000              MOVS     r0,#0
000044  9005              STR      r0,[sp,#0x14]
;;;28     	ADC_InitStructure.ADC_NbrOfChannel = 1;	//顺序进行规则转换的ADC通道的数目
000046  2001              MOVS     r0,#1
000048  f88d0018          STRB     r0,[sp,#0x18]
;;;29     	ADC_Init(ADC1, &ADC_InitStructure);	//根据ADC_InitStruct中指定的参数初始化外设ADCx的寄存器   
00004c  a902              ADD      r1,sp,#8
00004e  480e              LDR      r0,|L1.136|
000050  f7fffffe          BL       ADC_Init
;;;30     
;;;31       
;;;32     	ADC_Cmd(ADC1, ENABLE);	//使能指定的ADC1	
000054  2101              MOVS     r1,#1
000056  480c              LDR      r0,|L1.136|
000058  f7fffffe          BL       ADC_Cmd
;;;33     	ADC_ResetCalibration(ADC1);	//使能复位校准  	 
00005c  480a              LDR      r0,|L1.136|
00005e  f7fffffe          BL       ADC_ResetCalibration
;;;34     	while(ADC_GetResetCalibrationStatus(ADC1));	//等待复位校准结束	
000062  bf00              NOP      
                  |L1.100|
000064  4808              LDR      r0,|L1.136|
000066  f7fffffe          BL       ADC_GetResetCalibrationStatus
00006a  2800              CMP      r0,#0
00006c  d1fa              BNE      |L1.100|
;;;35     	ADC_StartCalibration(ADC1);	 //开启AD校准 
00006e  4806              LDR      r0,|L1.136|
000070  f7fffffe          BL       ADC_StartCalibration
;;;36     	while(ADC_GetCalibrationStatus(ADC1));	 //等待校准结束
000074  bf00              NOP      
                  |L1.118|
000076  4804              LDR      r0,|L1.136|
000078  f7fffffe          BL       ADC_GetCalibrationStatus
00007c  2800              CMP      r0,#0
00007e  d1fa              BNE      |L1.118|
;;;37     
;;;38     }				  
000080  b007              ADD      sp,sp,#0x1c
000082  bd00              POP      {pc}
;;;39     //获得ADC值
                          ENDP

                  |L1.132|
                          DCD      0x40010800
                  |L1.136|
                          DCD      0x40012400

                          AREA ||i.Get_Adc||, CODE, READONLY, ALIGN=2

                  Get_Adc PROC
;;;39     //获得ADC值
;;;40     u16 Get_Adc(u8 ch)   
000000  b510              PUSH     {r4,lr}
;;;41     {
000002  4604              MOV      r4,r0
;;;42       	//设置指定ADC的规则组通道，一个序列，采样时间
;;;43     	ADC_RegularChannelConfig(ADC1, ch, 1, ADC_SampleTime_1Cycles5 );	//ADC1,ADC通道,采样时间为239.5周期	  			      
000004  2300              MOVS     r3,#0
000006  2201              MOVS     r2,#1
000008  4621              MOV      r1,r4
00000a  4809              LDR      r0,|L2.48|
00000c  f7fffffe          BL       ADC_RegularChannelConfig
;;;44     	ADC_SoftwareStartConvCmd(ADC1, ENABLE);		//使能指定的ADC1的软件转换启动功能		 
000010  2101              MOVS     r1,#1
000012  4807              LDR      r0,|L2.48|
000014  f7fffffe          BL       ADC_SoftwareStartConvCmd
;;;45     	while(!ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC ));//等待转换结束
000018  bf00              NOP      
                  |L2.26|
00001a  2102              MOVS     r1,#2
00001c  4804              LDR      r0,|L2.48|
00001e  f7fffffe          BL       ADC_GetFlagStatus
000022  2800              CMP      r0,#0
000024  d0f9              BEQ      |L2.26|
;;;46     	return ADC_GetConversionValue(ADC1);	//返回最近一次ADC1规则组的转换结果
000026  4802              LDR      r0,|L2.48|
000028  f7fffffe          BL       ADC_GetConversionValue
;;;47     }
00002c  bd10              POP      {r4,pc}
;;;48     
                          ENDP

00002e  0000              DCW      0x0000
                  |L2.48|
                          DCD      0x40012400

                          AREA ||i.Get_Adc_Average||, CODE, READONLY, ALIGN=1

                  Get_Adc_Average PROC
;;;48     
;;;49     u16 Get_Adc_Average(u8 ch,u8 times)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;50     {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
;;;51     	u32 temp_val=0;
000008  2500              MOVS     r5,#0
;;;52     	u8 t;
;;;53     	for(t=0;t<times;t++)
00000a  2600              MOVS     r6,#0
00000c  e005              B        |L3.26|
                  |L3.14|
;;;54     	{
;;;55     		temp_val+=Get_Adc(ch);
00000e  4638              MOV      r0,r7
000010  f7fffffe          BL       Get_Adc
000014  4405              ADD      r5,r5,r0
000016  1c70              ADDS     r0,r6,#1              ;53
000018  b2c6              UXTB     r6,r0                 ;53
                  |L3.26|
00001a  42a6              CMP      r6,r4                 ;53
00001c  dbf7              BLT      |L3.14|
;;;56     	}
;;;57     	return temp_val/times;
00001e  fbb5f0f4          UDIV     r0,r5,r4
000022  b280              UXTH     r0,r0
;;;58     }
000024  e8bd81f0          POP      {r4-r8,pc}
;;;59     
                          ENDP


                          AREA ||i.Read_Rand||, CODE, READONLY, ALIGN=1

                  Read_Rand PROC
;;;59     
;;;60     u8 Read_Rand(void)	//产生随时数
000000  b570              PUSH     {r4-r6,lr}
;;;61     {
;;;62       	u8	uTemp=0;
000002  2400              MOVS     r4,#0
;;;63     	u16 TempADC_value=0;
000004  2500              MOVS     r5,#0
;;;64     //	TempADC_value = Get_Adc(ADC_Channel_1);	
;;;65     //	uTemp = TempADC_value%5;	//0-50随机数
;;;66     //	TempADC_value = Get_Adc(ADC_Channel_1);	
;;;67     //	uTemp = TempADC_value%10 + uTemp*10;
;;;68     	TempADC_value = Get_Adc(ADC_Channel_1);	
000006  2001              MOVS     r0,#1
000008  f7fffffe          BL       Get_Adc
00000c  4605              MOV      r5,r0
;;;69     	uTemp = TempADC_value%50;
00000e  2032              MOVS     r0,#0x32
000010  fb95f1f0          SDIV     r1,r5,r0
000014  fb005011          MLS      r0,r0,r1,r5
000018  b2c4              UXTB     r4,r0
;;;70     	return uTemp;
00001a  4620              MOV      r0,r4
;;;71     }
00001c  bd70              POP      {r4-r6,pc}
                          ENDP

