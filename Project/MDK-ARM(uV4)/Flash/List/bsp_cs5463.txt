; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_cs5463.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_cs5463.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User -I"C:\Users\xuan5\Desktop\JOSONG-XS03 V3.0\Project\MDK-ARM(uV4)\RTE" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=521 -D_RTE_ -DSTM32F10X_MD -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=.\flash\obj\bsp_cs5463.crf ..\..\User\bsp\bsp_cs5463.c]
                          THUMB

                          AREA ||i.Bsp_CS5463_Config||, CODE, READONLY, ALIGN=2

                  Bsp_CS5463_Config PROC
;;;17     
;;;18     void Bsp_CS5463_Config(void) 
000000  b508              PUSH     {r3,lr}
;;;19     {
;;;20     	GPIO_InitTypeDef GPIO_InitStructure;
;;;21     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOB, ENABLE); 
000002  2101              MOVS     r1,#1
000004  200c              MOVS     r0,#0xc
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;22     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5|GPIO_Pin_7;
00000a  20a0              MOVS     r0,#0xa0
00000c  f8ad0000          STRH     r0,[sp,#0]
;;;23     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
000010  2010              MOVS     r0,#0x10
000012  f88d0003          STRB     r0,[sp,#3]
;;;24     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000016  2003              MOVS     r0,#3
000018  f88d0002          STRB     r0,[sp,#2]
;;;25     	GPIO_Init(GPIOA, &GPIO_InitStructure);
00001c  4669              MOV      r1,sp
00001e  480d              LDR      r0,|L1.84|
000020  f7fffffe          BL       GPIO_Init
;;;26     
;;;27     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3|GPIO_Pin_4|GPIO_Pin_5;
000024  2038              MOVS     r0,#0x38
000026  f8ad0000          STRH     r0,[sp,#0]
;;;28     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
00002a  2010              MOVS     r0,#0x10
00002c  f88d0003          STRB     r0,[sp,#3]
;;;29     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000030  2003              MOVS     r0,#3
000032  f88d0002          STRB     r0,[sp,#2]
;;;30     	GPIO_Init(GPIOB, &GPIO_InitStructure);
000036  4669              MOV      r1,sp
000038  4807              LDR      r0,|L1.88|
00003a  f7fffffe          BL       GPIO_Init
;;;31     	
;;;32     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
00003e  2040              MOVS     r0,#0x40
000040  f8ad0000          STRH     r0,[sp,#0]
;;;33     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;	//上拉输入
000044  2048              MOVS     r0,#0x48
000046  f88d0003          STRB     r0,[sp,#3]
;;;34     	GPIO_Init(GPIOA, &GPIO_InitStructure);
00004a  4669              MOV      r1,sp
00004c  4801              LDR      r0,|L1.84|
00004e  f7fffffe          BL       GPIO_Init
;;;35     }
000052  bd08              POP      {r3,pc}
;;;36     
                          ENDP

                  |L1.84|
                          DCD      0x40010800
                  |L1.88|
                          DCD      0x40010c00

                          AREA ||i.CS5463CMD||, CODE, READONLY, ALIGN=2

                  CS5463CMD PROC
;;;182    */
;;;183    static void CS5463CMD(u8 cmd)
000000  b570              PUSH     {r4-r6,lr}
;;;184    {
000002  4604              MOV      r4,r0
;;;185        u8 i;
;;;186        CS546x_SET_CLK;		//SCLK = 1;
000004  2120              MOVS     r1,#0x20
000006  481a              LDR      r0,|L2.112|
000008  f7fffffe          BL       GPIO_SetBits
;;;187        CS546x_RESET_CS;	//CS = 0;
00000c  2120              MOVS     r1,#0x20
00000e  4819              LDR      r0,|L2.116|
000010  f7fffffe          BL       GPIO_ResetBits
;;;188        i = 0;
000014  2500              MOVS     r5,#0
;;;189        while(i<8)
000016  e01d              B        |L2.84|
                  |L2.24|
;;;190        {
;;;191            delay_us(50);		//uDelay(50);
000018  2032              MOVS     r0,#0x32
00001a  f7fffffe          BL       delay_us
;;;192            CS546x_RESET_CLK;	//SCLK = 0;
00001e  2120              MOVS     r1,#0x20
000020  4813              LDR      r0,|L2.112|
000022  f7fffffe          BL       GPIO_ResetBits
;;;193            if(cmd&0x80)    CS546x_SET_SDI;		//MOSI = 1;
000026  f0040080          AND      r0,r4,#0x80
00002a  b120              CBZ      r0,|L2.54|
00002c  2180              MOVS     r1,#0x80
00002e  4810              LDR      r0,|L2.112|
000030  f7fffffe          BL       GPIO_SetBits
000034  e003              B        |L2.62|
                  |L2.54|
;;;194            else		    CS546x_RESET_SDI;	//MOSI = 0;
000036  2180              MOVS     r1,#0x80
000038  480d              LDR      r0,|L2.112|
00003a  f7fffffe          BL       GPIO_ResetBits
                  |L2.62|
;;;195            delay_us(50);		//uDelay(50);
00003e  2032              MOVS     r0,#0x32
000040  f7fffffe          BL       delay_us
;;;196            CS546x_SET_CLK;		//SCLK = 1;			 		//在时钟上升沿，数据被写入CS5463
000044  2120              MOVS     r1,#0x20
000046  480a              LDR      r0,|L2.112|
000048  f7fffffe          BL       GPIO_SetBits
;;;197            cmd <<= 1;
00004c  0660              LSLS     r0,r4,#25
00004e  0e04              LSRS     r4,r0,#24
;;;198            i++;
000050  1c68              ADDS     r0,r5,#1
000052  b2c5              UXTB     r5,r0
                  |L2.84|
000054  2d08              CMP      r5,#8                 ;189
000056  dbdf              BLT      |L2.24|
;;;199        }
;;;200        delay_us(50);		//uDelay(50);
000058  2032              MOVS     r0,#0x32
00005a  f7fffffe          BL       delay_us
;;;201        CS546x_SET_SDI;		//MOSI = 1;
00005e  2180              MOVS     r1,#0x80
000060  4803              LDR      r0,|L2.112|
000062  f7fffffe          BL       GPIO_SetBits
;;;202        CS546x_SET_CS;		//CS = 1;
000066  2120              MOVS     r1,#0x20
000068  4802              LDR      r0,|L2.116|
00006a  f7fffffe          BL       GPIO_SetBits
;;;203    }
00006e  bd70              POP      {r4-r6,pc}
;;;204    
                          ENDP

                  |L2.112|
                          DCD      0x40010800
                  |L2.116|
                          DCD      0x40010c00

                          AREA ||i.CS5463ReadReg||, CODE, READONLY, ALIGN=2

                  CS5463ReadReg PROC
;;;265    */
;;;266    void CS5463ReadReg(u8 addr,u8 *p)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;267    {	
000004  4605              MOV      r5,r0
000006  4688              MOV      r8,r1
;;;268        u8 i,j;
;;;269        u8 dat;
;;;270        CS546x_RESET_CS;	//CS = 0;
000008  2120              MOVS     r1,#0x20
00000a  4837              LDR      r0,|L3.232|
00000c  f7fffffe          BL       GPIO_ResetBits
;;;271        addr &= READ_MASK;
000010  f00505bf          AND      r5,r5,#0xbf
;;;272        i = 0;
000014  2400              MOVS     r4,#0
;;;273        while(i<8)
000016  e01d              B        |L3.84|
                  |L3.24|
;;;274        {
;;;275            delay_us(50);		//uDelay(50);
000018  2032              MOVS     r0,#0x32
00001a  f7fffffe          BL       delay_us
;;;276            CS546x_RESET_CLK;	//SCLK = 0;
00001e  2120              MOVS     r1,#0x20
000020  4832              LDR      r0,|L3.236|
000022  f7fffffe          BL       GPIO_ResetBits
;;;277            if(addr&0x80)CS546x_SET_SDI;	//MOSI = 1;
000026  f0050080          AND      r0,r5,#0x80
00002a  b120              CBZ      r0,|L3.54|
00002c  2180              MOVS     r1,#0x80
00002e  482f              LDR      r0,|L3.236|
000030  f7fffffe          BL       GPIO_SetBits
000034  e003              B        |L3.62|
                  |L3.54|
;;;278            else		 CS546x_RESET_SDI;	//MOSI = 0;
000036  2180              MOVS     r1,#0x80
000038  482c              LDR      r0,|L3.236|
00003a  f7fffffe          BL       GPIO_ResetBits
                  |L3.62|
;;;279            delay_us(50);		//uDelay(50);
00003e  2032              MOVS     r0,#0x32
000040  f7fffffe          BL       delay_us
;;;280            CS546x_SET_CLK;		//SCLK = 1;
000044  2120              MOVS     r1,#0x20
000046  4829              LDR      r0,|L3.236|
000048  f7fffffe          BL       GPIO_SetBits
;;;281            addr <<= 1;	//在时钟上升沿，数据被写入CS5463
00004c  0668              LSLS     r0,r5,#25
00004e  0e05              LSRS     r5,r0,#24
;;;282            i++;
000050  1c60              ADDS     r0,r4,#1
000052  b2c4              UXTB     r4,r0
                  |L3.84|
000054  2c08              CMP      r4,#8                 ;273
000056  dbdf              BLT      |L3.24|
;;;283        }
;;;284    
;;;285        CS546x_SET_SDI;		//MOSI = 1;
000058  2180              MOVS     r1,#0x80
00005a  4824              LDR      r0,|L3.236|
00005c  f7fffffe          BL       GPIO_SetBits
;;;286        j = 0;
000060  2600              MOVS     r6,#0
;;;287        while(j<3)
000062  e032              B        |L3.202|
                  |L3.100|
;;;288        {
;;;289            i = 0;
000064  2400              MOVS     r4,#0
;;;290            dat = 0;
000066  2700              MOVS     r7,#0
;;;291            while(i<8)
000068  e029              B        |L3.190|
                  |L3.106|
;;;292            {
;;;293                delay_us(50);		//uDelay(50);
00006a  2032              MOVS     r0,#0x32
00006c  f7fffffe          BL       delay_us
;;;294                CS546x_RESET_CLK;	//SCLK = 0;
000070  2120              MOVS     r1,#0x20
000072  481e              LDR      r0,|L3.236|
000074  f7fffffe          BL       GPIO_ResetBits
;;;295                if(i==7)CS546x_RESET_SDI;	//MOSI = 0;
000078  2c07              CMP      r4,#7
00007a  d104              BNE      |L3.134|
00007c  2180              MOVS     r1,#0x80
00007e  481b              LDR      r0,|L3.236|
000080  f7fffffe          BL       GPIO_ResetBits
000084  e003              B        |L3.142|
                  |L3.134|
;;;296                else	CS546x_SET_SDI;		//MOSI = 1;
000086  2180              MOVS     r1,#0x80
000088  4818              LDR      r0,|L3.236|
00008a  f7fffffe          BL       GPIO_SetBits
                  |L3.142|
;;;297                delay_us(50);		//uDelay(50);
00008e  2032              MOVS     r0,#0x32
000090  f7fffffe          BL       delay_us
;;;298                dat <<= 1;			 			
000094  0678              LSLS     r0,r7,#25
000096  0e07              LSRS     r7,r0,#24
;;;299                if(CS546x_Get_SDO)	dat |= 0x01;
000098  2140              MOVS     r1,#0x40
00009a  4814              LDR      r0,|L3.236|
00009c  f7fffffe          BL       GPIO_ReadInputDataBit
0000a0  b110              CBZ      r0,|L3.168|
0000a2  f0470701          ORR      r7,r7,#1
0000a6  e001              B        |L3.172|
                  |L3.168|
;;;300                else				dat &= 0xFE;
0000a8  f00707fe          AND      r7,r7,#0xfe
                  |L3.172|
;;;301                CS546x_SET_CLK;		//SCLK = 1;
0000ac  2120              MOVS     r1,#0x20
0000ae  480f              LDR      r0,|L3.236|
0000b0  f7fffffe          BL       GPIO_SetBits
;;;302                delay_us(50);		//uDelay(50);					 		
0000b4  2032              MOVS     r0,#0x32
0000b6  f7fffffe          BL       delay_us
;;;303                i++;
0000ba  1c60              ADDS     r0,r4,#1
0000bc  b2c4              UXTB     r4,r0
                  |L3.190|
0000be  2c08              CMP      r4,#8                 ;291
0000c0  dbd3              BLT      |L3.106|
;;;304            }
;;;305            *(p+j) = dat;
0000c2  f8087006          STRB     r7,[r8,r6]
;;;306            j++;
0000c6  1c70              ADDS     r0,r6,#1
0000c8  b2c6              UXTB     r6,r0
                  |L3.202|
0000ca  2e03              CMP      r6,#3                 ;287
0000cc  dbca              BLT      |L3.100|
;;;307        }
;;;308        delay_us(50);		//uDelay(50);
0000ce  2032              MOVS     r0,#0x32
0000d0  f7fffffe          BL       delay_us
;;;309        CS546x_SET_SDI;		//MOSI = 1;
0000d4  2180              MOVS     r1,#0x80
0000d6  4805              LDR      r0,|L3.236|
0000d8  f7fffffe          BL       GPIO_SetBits
;;;310        CS546x_SET_CS;		//CS = 1;
0000dc  2120              MOVS     r1,#0x20
0000de  4802              LDR      r0,|L3.232|
0000e0  f7fffffe          BL       GPIO_SetBits
;;;311    }
0000e4  e8bd81f0          POP      {r4-r8,pc}
;;;312    
                          ENDP

                  |L3.232|
                          DCD      0x40010c00
                  |L3.236|
                          DCD      0x40010800

                          AREA ||i.CS5463WriteReg||, CODE, READONLY, ALIGN=2

                  CS5463WriteReg PROC
;;;214    */
;;;215    void CS5463WriteReg(u8 addr,u8 *p)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;216    {	
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;217        u8 i,j;
;;;218        u8 dat;
;;;219        CS546x_RESET_CS;	//CS = 0;
000008  2120              MOVS     r1,#0x20
00000a  4832              LDR      r0,|L4.212|
00000c  f7fffffe          BL       GPIO_ResetBits
;;;220        i = 0;
000010  2400              MOVS     r4,#0
;;;221        while(i<8)
000012  e01d              B        |L4.80|
                  |L4.20|
;;;222        {
;;;223            delay_us(50);		//uDelay(50);
000014  2032              MOVS     r0,#0x32
000016  f7fffffe          BL       delay_us
;;;224            CS546x_RESET_CLK;	//SCLK = 0;
00001a  2120              MOVS     r1,#0x20
00001c  482e              LDR      r0,|L4.216|
00001e  f7fffffe          BL       GPIO_ResetBits
;;;225            if(addr&0x80)CS546x_SET_SDI;	//MOSI = 1;
000022  f0060080          AND      r0,r6,#0x80
000026  b120              CBZ      r0,|L4.50|
000028  2180              MOVS     r1,#0x80
00002a  482b              LDR      r0,|L4.216|
00002c  f7fffffe          BL       GPIO_SetBits
000030  e003              B        |L4.58|
                  |L4.50|
;;;226            else		 CS546x_RESET_SDI;	//MOSI = 0;
000032  2180              MOVS     r1,#0x80
000034  4828              LDR      r0,|L4.216|
000036  f7fffffe          BL       GPIO_ResetBits
                  |L4.58|
;;;227            delay_us(50);		//uDelay(50);
00003a  2032              MOVS     r0,#0x32
00003c  f7fffffe          BL       delay_us
;;;228            CS546x_SET_CLK;		//SCLK = 1;	//在时钟上升沿，数据被写入CS5463
000040  2120              MOVS     r1,#0x20
000042  4825              LDR      r0,|L4.216|
000044  f7fffffe          BL       GPIO_SetBits
;;;229            addr <<= 1;
000048  0670              LSLS     r0,r6,#25
00004a  0e06              LSRS     r6,r0,#24
;;;230            i++;
00004c  1c60              ADDS     r0,r4,#1
00004e  b2c4              UXTB     r4,r0
                  |L4.80|
000050  2c08              CMP      r4,#8                 ;221
000052  dbdf              BLT      |L4.20|
;;;231        }
;;;232        j = 0;
000054  2500              MOVS     r5,#0
;;;233        delay_us(50);		//uDelay(50);
000056  2032              MOVS     r0,#0x32
000058  f7fffffe          BL       delay_us
;;;234        while(j<3)
00005c  e02a              B        |L4.180|
                  |L4.94|
;;;235        {
;;;236            dat = *(p+j);
00005e  f8178005          LDRB     r8,[r7,r5]
;;;237            i = 0;
000062  2400              MOVS     r4,#0
;;;238            while(i<8)
000064  e01f              B        |L4.166|
                  |L4.102|
;;;239            {
;;;240                delay_us(50);		//uDelay(50);
000066  2032              MOVS     r0,#0x32
000068  f7fffffe          BL       delay_us
;;;241                CS546x_RESET_CLK;	//SCLK = 0;
00006c  2120              MOVS     r1,#0x20
00006e  481a              LDR      r0,|L4.216|
000070  f7fffffe          BL       GPIO_ResetBits
;;;242                if(dat&0x80)CS546x_SET_SDI;		//MOSI = 1;
000074  f0080080          AND      r0,r8,#0x80
000078  b120              CBZ      r0,|L4.132|
00007a  2180              MOVS     r1,#0x80
00007c  4816              LDR      r0,|L4.216|
00007e  f7fffffe          BL       GPIO_SetBits
000082  e003              B        |L4.140|
                  |L4.132|
;;;243                else		CS546x_RESET_SDI;	//MOSI = 0;
000084  2180              MOVS     r1,#0x80
000086  4814              LDR      r0,|L4.216|
000088  f7fffffe          BL       GPIO_ResetBits
                  |L4.140|
;;;244                delay_us(50);		//uDelay(50);
00008c  2032              MOVS     r0,#0x32
00008e  f7fffffe          BL       delay_us
;;;245                CS546x_SET_CLK;		//SCLK = 1;   //在时钟上升沿，数据被写入CS5463
000092  2120              MOVS     r1,#0x20
000094  4810              LDR      r0,|L4.216|
000096  f7fffffe          BL       GPIO_SetBits
;;;246                dat <<= 1;
00009a  ea4f6048          LSL      r0,r8,#25
00009e  ea4f6810          LSR      r8,r0,#24
;;;247                i++;
0000a2  1c60              ADDS     r0,r4,#1
0000a4  b2c4              UXTB     r4,r0
                  |L4.166|
0000a6  2c08              CMP      r4,#8                 ;238
0000a8  dbdd              BLT      |L4.102|
;;;248            }
;;;249            delay_us(50);		//uDelay(50);
0000aa  2032              MOVS     r0,#0x32
0000ac  f7fffffe          BL       delay_us
;;;250            j++;
0000b0  1c68              ADDS     r0,r5,#1
0000b2  b2c5              UXTB     r5,r0
                  |L4.180|
0000b4  2d03              CMP      r5,#3                 ;234
0000b6  dbd2              BLT      |L4.94|
;;;251        }
;;;252        CS546x_SET_SDI;		//MOSI = 1;
0000b8  2180              MOVS     r1,#0x80
0000ba  4807              LDR      r0,|L4.216|
0000bc  f7fffffe          BL       GPIO_SetBits
;;;253        CS546x_SET_CS;		//CS = 1;
0000c0  2120              MOVS     r1,#0x20
0000c2  4804              LDR      r0,|L4.212|
0000c4  f7fffffe          BL       GPIO_SetBits
;;;254        delay_us(50);		//uDelay(50);	
0000c8  2032              MOVS     r0,#0x32
0000ca  f7fffffe          BL       delay_us
;;;255    }
0000ce  e8bd81f0          POP      {r4-r8,pc}
;;;256    
                          ENDP

0000d2  0000              DCW      0x0000
                  |L4.212|
                          DCD      0x40010c00
                  |L4.216|
                          DCD      0x40010800

                          AREA ||i.CS5463_GetStaReg_Val||, CODE, READONLY, ALIGN=2

                  CS5463_GetStaReg_Val PROC
;;;375    */
;;;376    u8 CS5463_GetStaReg_Val(void)
000000  b510              PUSH     {r4,lr}
;;;377    {
;;;378    	u8 ret=0;
000002  2400              MOVS     r4,#0
;;;379    
;;;380    	CS5463ReadReg(Status | REG_RD,CS546x_Buff.u8);
000004  490c              LDR      r1,|L5.56|
000006  201e              MOVS     r0,#0x1e
000008  f7fffffe          BL       CS5463ReadReg
;;;381    	if(CS546x_Buff.u8[0] & 0x80)
00000c  480a              LDR      r0,|L5.56|
00000e  7800              LDRB     r0,[r0,#0]  ; CS546x_Buff
000010  f0000080          AND      r0,r0,#0x80
000014  b170              CBZ      r0,|L5.52|
;;;382    	{
;;;383    		//检测电流/电压是否超出范围
;;;384    		//检测电流有效值/电压有效值/电能是否超出范围
;;;385    		if((CS546x_Buff.u8[0]&0x03)||(CS546x_Buff.u8[1]&0x70))
000016  4808              LDR      r0,|L5.56|
000018  7800              LDRB     r0,[r0,#0]  ; CS546x_Buff
00001a  f0000003          AND      r0,r0,#3
00001e  b920              CBNZ     r0,|L5.42|
000020  4805              LDR      r0,|L5.56|
000022  7840              LDRB     r0,[r0,#1]  ; CS546x_Buff
000024  f0000070          AND      r0,r0,#0x70
000028  b110              CBZ      r0,|L5.48|
                  |L5.42|
;;;386    		{
;;;387    		 	CS546x_ResetStaReg();		//复位状态寄存器
00002a  f7fffffe          BL       CS546x_ResetStaReg
00002e  e001              B        |L5.52|
                  |L5.48|
;;;388    		}else
;;;389    		{
;;;390    			ret |= 0x01;
000030  f0440401          ORR      r4,r4,#1
                  |L5.52|
;;;391    		}
;;;392    	}
;;;393    
;;;394    	return ret;
000034  4620              MOV      r0,r4
;;;395    }
000036  bd10              POP      {r4,pc}
;;;396    
                          ENDP

                  |L5.56|
                          DCD      CS546x_Buff

                          AREA ||i.CS5463_GetStatusReg||, CODE, READONLY, ALIGN=2

                  CS5463_GetStatusReg PROC
;;;338    */
;;;339    u8 CS5463_GetStatusReg(void)
000000  b510              PUSH     {r4,lr}
;;;340    { 
;;;341    	u8 sta=0;
000002  2400              MOVS     r4,#0
;;;342    
;;;343    	CS5463ReadReg(0x1E,RX_Buff);	   //1E 是什么？   状态寄存器
000004  4910              LDR      r1,|L6.72|
000006  201e              MOVS     r0,#0x1e
000008  f7fffffe          BL       CS5463ReadReg
;;;344    	if(RX_Buff[0]&0x80)		   			//检测：电流、电压、功率测量是否完毕
00000c  480e              LDR      r0,|L6.72|
00000e  7800              LDRB     r0,[r0,#0]  ; RX_Buff
000010  f0000080          AND      r0,r0,#0x80
000014  b170              CBZ      r0,|L6.52|
;;;345    	{
;;;346    		//检测电流/电压是否超出范围
;;;347    		//检测电流有效值/电压有效值/电能是否超出范围
;;;348    		if((RX_Buff[0]&0x03)||(RX_Buff[1]&0x70))
000016  480c              LDR      r0,|L6.72|
000018  7800              LDRB     r0,[r0,#0]  ; RX_Buff
00001a  f0000003          AND      r0,r0,#3
00001e  b920              CBNZ     r0,|L6.42|
000020  4809              LDR      r0,|L6.72|
000022  7840              LDRB     r0,[r0,#1]  ; RX_Buff
000024  f0000070          AND      r0,r0,#0x70
000028  b110              CBZ      r0,|L6.48|
                  |L6.42|
;;;349    		{
;;;350    			CS5463_ResetStatusReg();		//复位状态寄存器
00002a  f7fffffe          BL       CS5463_ResetStatusReg
00002e  e001              B        |L6.52|
                  |L6.48|
;;;351    		}
;;;352    		else
;;;353    		{
;;;354    			sta |= 0x01;//B0000_0001;	//这什么意思 还可以这样写吗？ PT2017-2-8   分隔符吗？ 
000030  f0440401          ORR      r4,r4,#1
                  |L6.52|
;;;355    		}
;;;356    	}
;;;357    
;;;358    	if(RX_Buff[2]&0x80)			   	//检测：温度测量是否完毕
000034  4804              LDR      r0,|L6.72|
000036  7880              LDRB     r0,[r0,#2]  ; RX_Buff
000038  f0000080          AND      r0,r0,#0x80
00003c  b108              CBZ      r0,|L6.66|
;;;359    	{
;;;360    		sta |=0x02; //B0000_0010;
00003e  f0440402          ORR      r4,r4,#2
                  |L6.66|
;;;361    	} 
;;;362    	return(sta);	
000042  4620              MOV      r0,r4
;;;363    }  
000044  bd10              POP      {r4,pc}
;;;364    
                          ENDP

000046  0000              DCW      0x0000
                  |L6.72|
                          DCD      RX_Buff

                          AREA ||i.CS5463_ResetStatusReg||, CODE, READONLY, ALIGN=2

                  CS5463_ResetStatusReg PROC
;;;321    */
;;;322    static void CS5463_ResetStatusReg(void)
000000  b510              PUSH     {r4,lr}
;;;323    {
;;;324        RX_Buff[0] = 0xFF;
000002  20ff              MOVS     r0,#0xff
000004  4903              LDR      r1,|L7.20|
000006  7008              STRB     r0,[r1,#0]
;;;325        RX_Buff[1] = 0xFF;
000008  7048              STRB     r0,[r1,#1]
;;;326        RX_Buff[2] = 0xFF;
00000a  7088              STRB     r0,[r1,#2]
;;;327        CS5463WriteReg(0x5E,RX_Buff);		//复位状态寄存器	#define REG_STATUSR 	0x5E 	//状态  
00000c  205e              MOVS     r0,#0x5e
00000e  f7fffffe          BL       CS5463WriteReg
;;;328    }
000012  bd10              POP      {r4,pc}
;;;329    
                          ENDP

                  |L7.20|
                          DCD      RX_Buff

                          AREA ||i.CS546x_Get_Irms||, CODE, READONLY, ALIGN=2

                  CS546x_Get_Irms PROC
;;;467    */
;;;468    u32 CS546x_Get_Irms()
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;469    {
;;;470    	float Tmp;
;;;471    	UN32 ResceBuf;
;;;472        u8 DustBuf[4]={0};
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;473    
;;;474        
;;;475    	ResceBuf.u32 = 0;
000008  9001              STR      r0,[sp,#4]
;;;476    	Tmp = 0;
00000a  2400              MOVS     r4,#0
;;;477    	CS5463ReadReg(REG_RD|Irms,DustBuf);
00000c  4669              MOV      r1,sp
00000e  2016              MOVS     r0,#0x16
000010  f7fffffe          BL       CS5463ReadReg
;;;478    	ResceBuf.u8[0] =  DustBuf[2];
000014  f89d0002          LDRB     r0,[sp,#2]
000018  f88d0004          STRB     r0,[sp,#4]
;;;479    	ResceBuf.u8[1] =  DustBuf[1];
00001c  f89d0001          LDRB     r0,[sp,#1]
000020  f88d0005          STRB     r0,[sp,#5]
;;;480    	ResceBuf.u8[2] =  DustBuf[0];
000024  f89d0000          LDRB     r0,[sp,#0]
000028  f88d0006          STRB     r0,[sp,#6]
;;;481    	Tmp = ResceBuf.u32/16777215.0;
00002c  9801              LDR      r0,[sp,#4]
00002e  f7fffffe          BL       __aeabi_ui2d
000032  4607              MOV      r7,r0
000034  f04f4260          MOV      r2,#0xe0000000
000038  4b0b              LDR      r3,|L8.104|
00003a  f7fffffe          BL       __aeabi_ddiv
00003e  4605              MOV      r5,r0
000040  f7fffffe          BL       __aeabi_d2f
000044  4604              MOV      r4,r0
;;;482    	Tmp = Tmp*CS5463_IScale;//I_Coff;		//计算电流值 暂时不用 
000046  4909              LDR      r1,|L8.108|
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       __aeabi_fmul
00004e  4604              MOV      r4,r0
;;;483    	Tmp *= 1000;
000050  4907              LDR      r1,|L8.112|
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       __aeabi_fmul
000058  4604              MOV      r4,r0
;;;484    	ResceBuf.u32 = (u32)Tmp;
00005a  4620              MOV      r0,r4
00005c  f7fffffe          BL       __aeabi_f2uiz
000060  9001              STR      r0,[sp,#4]
;;;485    	
;;;486    	return ResceBuf.u32;
000062  9801              LDR      r0,[sp,#4]
;;;487    }
000064  e8bd81fc          POP      {r2-r8,pc}
;;;488    
                          ENDP

                  |L8.104|
                          DCD      0x416fffff
                  |L8.108|
                          DCD      0x41100000
                  |L8.112|
                          DCD      0x447a0000

                          AREA ||i.CS546x_Get_Vrms||, CODE, READONLY, ALIGN=2

                  CS546x_Get_Vrms PROC
;;;414    */
;;;415    u32 CS546x_Get_Vrms()
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;416    {
;;;417    	float Tmp;
;;;418    	UN32 ResceBuf;
;;;419    	u8 DustBuf[4]={0};
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;420    	
;;;421    	ResceBuf.u32 = 0;
000008  9001              STR      r0,[sp,#4]
;;;422    	CS5463ReadReg(REG_RD|Vrms,DustBuf);
00000a  4669              MOV      r1,sp
00000c  2018              MOVS     r0,#0x18
00000e  f7fffffe          BL       CS5463ReadReg
;;;423    //	ShowHex(DustBuf,4);						//打印原始数据
;;;424    
;;;425    	ResceBuf.u8[0] =  DustBuf[2];
000012  f89d0002          LDRB     r0,[sp,#2]
000016  f88d0004          STRB     r0,[sp,#4]
;;;426    	ResceBuf.u8[1] =  DustBuf[1];
00001a  f89d0001          LDRB     r0,[sp,#1]
00001e  f88d0005          STRB     r0,[sp,#5]
;;;427    	ResceBuf.u8[2] =  DustBuf[0];
000022  f89d0000          LDRB     r0,[sp,#0]
000026  f88d0006          STRB     r0,[sp,#6]
;;;428    	Tmp = ResceBuf.u32/16777215.0;
00002a  9801              LDR      r0,[sp,#4]
00002c  f7fffffe          BL       __aeabi_ui2d
000030  4607              MOV      r7,r0
000032  f04f4260          MOV      r2,#0xe0000000
000036  4b0c              LDR      r3,|L9.104|
000038  f7fffffe          BL       __aeabi_ddiv
00003c  4605              MOV      r5,r0
00003e  f7fffffe          BL       __aeabi_d2f
000042  4604              MOV      r4,r0
;;;429    //	printf("result-K: %f\r\n",Tmp);		//转为小数点数值    
;;;430    	Tmp = Tmp*CS5463_VScale;		//V_Coff;     //计算电压值220V*250mv/(110mv/1.414)=704.8V
000044  4909              LDR      r1,|L9.108|
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       __aeabi_fmul
00004c  4604              MOV      r4,r0
;;;431    //    printf("电压: %f\r\n",Tmp);		//转为小数点数值   
;;;432        Tmp *= 10;						//放大十倍
00004e  4908              LDR      r1,|L9.112|
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       __aeabi_fmul
000056  4604              MOV      r4,r0
;;;433    	ResceBuf.u32 = (u32)Tmp;
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       __aeabi_f2uiz
00005e  9001              STR      r0,[sp,#4]
;;;434    //	memcpy(DustBuf,ResceBuf.u8,4);
;;;435    
;;;436    	return ResceBuf.u32;
000060  9801              LDR      r0,[sp,#4]
;;;437    }
000062  e8bd81fc          POP      {r2-r8,pc}
;;;438    
                          ENDP

000066  0000              DCW      0x0000
                  |L9.104|
                          DCD      0x416fffff
                  |L9.108|
                          DCD      0x44768000
                  |L9.112|
                          DCD      0x41200000

                          AREA ||i.CS546x_Init||, CODE, READONLY, ALIGN=2

                  CS546x_Init PROC
;;;498    */
;;;499    void CS546x_Init(unsigned char IsReadEEP)
000000  b510              PUSH     {r4,lr}
;;;500    {
000002  4604              MOV      r4,r0
;;;501    	CS546x_CLR_RST;
000004  2110              MOVS     r1,#0x10
000006  485c              LDR      r0,|L10.376|
000008  f7fffffe          BL       GPIO_ResetBits
;;;502    	delay_ms(10);
00000c  200a              MOVS     r0,#0xa
00000e  f7fffffe          BL       delay_ms
;;;503    	CS546x_SET_RST;
000012  2110              MOVS     r1,#0x10
000014  4858              LDR      r0,|L10.376|
000016  f7fffffe          BL       GPIO_SetBits
;;;504    
;;;505    	if(IsReadEEP)
00001a  2c00              CMP      r4,#0
00001c  d054              BEQ      |L10.200|
;;;506    	{			
;;;507    		CS546x_Buff.u8[0] = SYNC1;
00001e  20ff              MOVS     r0,#0xff
000020  4956              LDR      r1,|L10.380|
000022  7008              STRB     r0,[r1,#0]
;;;508    		CS546x_Buff.u8[1] = SYNC1;
000024  7048              STRB     r0,[r1,#1]
;;;509    		CS546x_Buff.u8[2] = SYNC0;
000026  20fe              MOVS     r0,#0xfe
000028  7088              STRB     r0,[r1,#2]
;;;510    		CS5463WriteReg(SYNC1,CS546x_Buff.u8); 			//同步串口
00002a  20ff              MOVS     r0,#0xff
00002c  f7fffffe          BL       CS5463WriteReg
;;;511    
;;;512    		CS546x_Buff.u8[0] = 0x00;
000030  2000              MOVS     r0,#0
000032  4952              LDR      r1,|L10.380|
000034  7008              STRB     r0,[r1,#0]
;;;513    		CS546x_Buff.u8[1] = 0x0f;
000036  200f              MOVS     r0,#0xf
000038  7048              STRB     r0,[r1,#1]
;;;514    		CS546x_Buff.u8[2] = 0xA0;
00003a  20a0              MOVS     r0,#0xa0
00003c  7088              STRB     r0,[r1,#2]
;;;515    		CS5463WriteReg(CycleCount | REG_WR,CS546x_Buff.u8); //配置每个计算周期的A/D转换数->4000
00003e  204a              MOVS     r0,#0x4a
000040  f7fffffe          BL       CS5463WriteReg
;;;516    
;;;517    		CS546x_Buff.u8[0] = 0x00;
000044  2000              MOVS     r0,#0
000046  494d              LDR      r1,|L10.380|
000048  7008              STRB     r0,[r1,#0]
;;;518    		CS546x_Buff.u8[1] = 0x00;
00004a  7048              STRB     r0,[r1,#1]
;;;519    		CS546x_Buff.u8[2] = 0x00;
00004c  7088              STRB     r0,[r1,#2]
;;;520    		CS5463WriteReg(Mode| REG_WR,CS546x_Buff.u8);	//开启高通滤波
00004e  2064              MOVS     r0,#0x64
000050  f7fffffe          BL       CS5463WriteReg
;;;521    
;;;522    		CS546x_Buff.u8[0] = 0x00;
000054  2000              MOVS     r0,#0
000056  4949              LDR      r1,|L10.380|
000058  7008              STRB     r0,[r1,#0]
;;;523    		CS546x_Buff.u8[1] = 0x00;
00005a  7048              STRB     r0,[r1,#1]
;;;524    		CS546x_Buff.u8[2] = 0x01;
00005c  2001              MOVS     r0,#1
00005e  7088              STRB     r0,[r1,#2]
;;;525    		CS5463WriteReg(Cfg | REG_WR,CS546x_Buff.u8);	//配置寄存器
000060  2040              MOVS     r0,#0x40
000062  f7fffffe          BL       CS5463WriteReg
;;;526    
;;;527    		CS546x_Buff.u8[0] = 0xFF;
000066  20ff              MOVS     r0,#0xff
000068  4944              LDR      r1,|L10.380|
00006a  7008              STRB     r0,[r1,#0]
;;;528    		CS546x_Buff.u8[1] = 0xFF;
00006c  7048              STRB     r0,[r1,#1]
;;;529    		CS546x_Buff.u8[2] = 0xFF;
00006e  7088              STRB     r0,[r1,#2]
;;;530    		CS5463WriteReg(Status | REG_WR,CS546x_Buff.u8);//clear state reg
000070  205e              MOVS     r0,#0x5e
000072  f7fffffe          BL       CS5463WriteReg
;;;531    
;;;532    		CS546x_Buff.u8[0] = 0x80;
000076  2080              MOVS     r0,#0x80
000078  4940              LDR      r1,|L10.380|
00007a  7008              STRB     r0,[r1,#0]
;;;533    		CS546x_Buff.u8[1] = 0x00;
00007c  2000              MOVS     r0,#0
00007e  7048              STRB     r0,[r1,#1]
;;;534    		CS546x_Buff.u8[2] = 0x00;
000080  7088              STRB     r0,[r1,#2]
;;;535    		CS5463WriteReg(MASK | REG_WR,CS546x_Buff.u8);	// allow int
000082  2074              MOVS     r0,#0x74
000084  f7fffffe          BL       CS5463WriteReg
;;;536    
;;;537    		CS546x_Buff.u8[0] = 0x00;
000088  2000              MOVS     r0,#0
00008a  493c              LDR      r1,|L10.380|
00008c  7008              STRB     r0,[r1,#0]
;;;538    		CS546x_Buff.u8[1] = 0x00;
00008e  7048              STRB     r0,[r1,#1]
;;;539    		CS546x_Buff.u8[2] = 0x00;
000090  7088              STRB     r0,[r1,#2]
;;;540    		CS5463WriteReg(Ctrl | REG_WR,CS546x_Buff.u8);	//初始化控制寄存器
000092  2078              MOVS     r0,#0x78
000094  f7fffffe          BL       CS5463WriteReg
;;;541    
;;;542    		CS546x_Buff.u8[0] = SYNC1;
000098  20ff              MOVS     r0,#0xff
00009a  4938              LDR      r1,|L10.380|
00009c  7008              STRB     r0,[r1,#0]
;;;543    		CS546x_Buff.u8[1] = SYNC1;
00009e  7048              STRB     r0,[r1,#1]
;;;544    		CS546x_Buff.u8[2] = SYNC0;
0000a0  20fe              MOVS     r0,#0xfe
0000a2  7088              STRB     r0,[r1,#2]
;;;545    		CS5463WriteReg(SYNC1,CS546x_Buff.u8); 			//同步串口
0000a4  20ff              MOVS     r0,#0xff
0000a6  f7fffffe          BL       CS5463WriteReg
;;;546    
;;;547    		CS546x_RESET_CS;
0000aa  2120              MOVS     r1,#0x20
0000ac  4832              LDR      r0,|L10.376|
0000ae  f7fffffe          BL       GPIO_ResetBits
;;;548    		delay_us(10);
0000b2  200a              MOVS     r0,#0xa
0000b4  f7fffffe          BL       delay_us
;;;549    		CS5463CMD(0xe8);  						//采用连续计算周期测量模式
0000b8  20e8              MOVS     r0,#0xe8
0000ba  f7fffffe          BL       CS5463CMD
;;;550    		CS546x_SET_CS;
0000be  2120              MOVS     r1,#0x20
0000c0  482d              LDR      r0,|L10.376|
0000c2  f7fffffe          BL       GPIO_SetBits
0000c6  e055              B        |L10.372|
                  |L10.200|
;;;551    	}
;;;552    	else
;;;553    	{			
;;;554    		CS546x_Buff.u8[0] = SYNC1;
0000c8  20ff              MOVS     r0,#0xff
0000ca  492c              LDR      r1,|L10.380|
0000cc  7008              STRB     r0,[r1,#0]
;;;555    		CS546x_Buff.u8[1] = SYNC1;
0000ce  7048              STRB     r0,[r1,#1]
;;;556    		CS546x_Buff.u8[2] = SYNC0;
0000d0  20fe              MOVS     r0,#0xfe
0000d2  7088              STRB     r0,[r1,#2]
;;;557    		CS5463WriteReg(SYNC1,CS546x_Buff.u8);  			//串口重新初始化序列  ->SYNC1命令
0000d4  20ff              MOVS     r0,#0xff
0000d6  f7fffffe          BL       CS5463WriteReg
;;;558    
;;;559    		CS546x_Buff.u8[0] = 0x00;
0000da  2000              MOVS     r0,#0
0000dc  4927              LDR      r1,|L10.380|
0000de  7008              STRB     r0,[r1,#0]
;;;560    		CS546x_Buff.u8[1] = 0x00;
0000e0  7048              STRB     r0,[r1,#1]
;;;561    		CS546x_Buff.u8[2] = 0x01;
0000e2  2001              MOVS     r0,#1
0000e4  7088              STRB     r0,[r1,#2]
;;;562    		CS5463WriteReg(Cfg | REG_WR,CS546x_Buff.u8);	//配置寄存器						
0000e6  2040              MOVS     r0,#0x40
0000e8  f7fffffe          BL       CS5463WriteReg
;;;563    
;;;564    		CS546x_Buff.u8[0] = 0x00;
0000ec  2000              MOVS     r0,#0
0000ee  4923              LDR      r1,|L10.380|
0000f0  7008              STRB     r0,[r1,#0]
;;;565    		CS546x_Buff.u8[1] = 0x00;
0000f2  7048              STRB     r0,[r1,#1]
;;;566    		CS546x_Buff.u8[2] = 0x60;                       //开启电流和电压高通滤波器
0000f4  2060              MOVS     r0,#0x60
0000f6  7088              STRB     r0,[r1,#2]
;;;567    		CS5463WriteReg(Mode | REG_WR,CS546x_Buff.u8);	//工作模式寄存器	
0000f8  2064              MOVS     r0,#0x64
0000fa  f7fffffe          BL       CS5463WriteReg
;;;568    		
;;;569    		CS546x_Buff.u8[0] = 0x00;
0000fe  2000              MOVS     r0,#0
000100  491e              LDR      r1,|L10.380|
000102  7008              STRB     r0,[r1,#0]
;;;570    		CS546x_Buff.u8[1] = 0x0f;
000104  200f              MOVS     r0,#0xf
000106  7048              STRB     r0,[r1,#1]
;;;571    		CS546x_Buff.u8[2] = 0xA0;
000108  20a0              MOVS     r0,#0xa0
00010a  7088              STRB     r0,[r1,#2]
;;;572    		CS5463WriteReg(CycleCount | REG_WR,CS546x_Buff.u8);	//配置每个计算周期的A/D转换数->4000
00010c  204a              MOVS     r0,#0x4a
00010e  f7fffffe          BL       CS5463WriteReg
;;;573    
;;;574    		CS546x_Buff.u8[0] = 0xFF;
000112  20ff              MOVS     r0,#0xff
000114  4919              LDR      r1,|L10.380|
000116  7008              STRB     r0,[r1,#0]
;;;575    		CS546x_Buff.u8[1] = 0xFF;
000118  7048              STRB     r0,[r1,#1]
;;;576    		CS546x_Buff.u8[2] = 0xFF;
00011a  7088              STRB     r0,[r1,#2]
;;;577    		CS5463WriteReg(Status | REG_WR,CS546x_Buff.u8);//clear state reg
00011c  205e              MOVS     r0,#0x5e
00011e  f7fffffe          BL       CS5463WriteReg
;;;578    
;;;579    		CS546x_Buff.u8[0] = 0x80;
000122  2080              MOVS     r0,#0x80
000124  4915              LDR      r1,|L10.380|
000126  7008              STRB     r0,[r1,#0]
;;;580    		CS546x_Buff.u8[1] = 0x00;
000128  2000              MOVS     r0,#0
00012a  7048              STRB     r0,[r1,#1]
;;;581    		CS546x_Buff.u8[2] = 0x80;
00012c  2080              MOVS     r0,#0x80
00012e  7088              STRB     r0,[r1,#2]
;;;582    		CS5463WriteReg(MASK | REG_WR,CS546x_Buff.u8);	// allow int
000130  2074              MOVS     r0,#0x74
000132  f7fffffe          BL       CS5463WriteReg
;;;583    
;;;584    		CS546x_Buff.u8[0] = 0x00;
000136  2000              MOVS     r0,#0
000138  4910              LDR      r1,|L10.380|
00013a  7008              STRB     r0,[r1,#0]
;;;585    		CS546x_Buff.u8[1] = 0x00;
00013c  7048              STRB     r0,[r1,#1]
;;;586    		CS546x_Buff.u8[2] = 0x00;
00013e  7088              STRB     r0,[r1,#2]
;;;587    		CS5463WriteReg(Ctrl | REG_WR,CS546x_Buff.u8);	//初始化控制寄存器		
000140  2078              MOVS     r0,#0x78
000142  f7fffffe          BL       CS5463WriteReg
;;;588    
;;;589    		CS546x_Buff.u8[0] = SYNC1;
000146  20ff              MOVS     r0,#0xff
000148  490c              LDR      r1,|L10.380|
00014a  7008              STRB     r0,[r1,#0]
;;;590    		CS546x_Buff.u8[1] = SYNC1;
00014c  7048              STRB     r0,[r1,#1]
;;;591    		CS546x_Buff.u8[2] = SYNC0;
00014e  20fe              MOVS     r0,#0xfe
000150  7088              STRB     r0,[r1,#2]
;;;592    		CS5463WriteReg(SYNC1,CS546x_Buff.u8); 			//同步串口
000152  20ff              MOVS     r0,#0xff
000154  f7fffffe          BL       CS5463WriteReg
;;;593    
;;;594    		CS546x_RESET_CS;
000158  2120              MOVS     r1,#0x20
00015a  4807              LDR      r0,|L10.376|
00015c  f7fffffe          BL       GPIO_ResetBits
;;;595    		delay_us(10);
000160  200a              MOVS     r0,#0xa
000162  f7fffffe          BL       delay_us
;;;596    		CS5463CMD(0xe8);  						//采用连续计算周期测量模式,开启测量
000166  20e8              MOVS     r0,#0xe8
000168  f7fffffe          BL       CS5463CMD
;;;597    		CS546x_SET_CS;
00016c  2120              MOVS     r1,#0x20
00016e  4802              LDR      r0,|L10.376|
000170  f7fffffe          BL       GPIO_SetBits
                  |L10.372|
;;;598    	}
;;;599    }
000174  bd10              POP      {r4,pc}
;;;600    extern uint16_t g_ShowDat[6];
                          ENDP

000176  0000              DCW      0x0000
                  |L10.376|
                          DCD      0x40010c00
                  |L10.380|
                          DCD      CS546x_Buff

                          AREA ||i.CS546x_Read_Byte||, CODE, READONLY, ALIGN=2

                  CS546x_Read_Byte PROC
;;;45     */
;;;46     u8 CS546x_Read_Byte(void)
000000  b570              PUSH     {r4-r6,lr}
;;;47     {	
;;;48     	u8 ReceiveDat,i;	
;;;49     	ReceiveDat = 0;
000002  2400              MOVS     r4,#0
;;;50     	CS546x_SET_SDI;
000004  2180              MOVS     r1,#0x80
000006  4811              LDR      r0,|L11.76|
000008  f7fffffe          BL       GPIO_SetBits
;;;51     //	delay_us(10);
;;;52     	for(i=0;i<7;i++) 
00000c  2500              MOVS     r5,#0
00000e  e018              B        |L11.66|
                  |L11.16|
;;;53     	{
;;;54     		CS546x_RESET_CLK;
000010  2120              MOVS     r1,#0x20
000012  480e              LDR      r0,|L11.76|
000014  f7fffffe          BL       GPIO_ResetBits
;;;55     		delay_us(5);
000018  2005              MOVS     r0,#5
00001a  f7fffffe          BL       delay_us
;;;56     		CS546x_SET_CLK;
00001e  2120              MOVS     r1,#0x20
000020  480a              LDR      r0,|L11.76|
000022  f7fffffe          BL       GPIO_SetBits
;;;57     		delay_us(5);
000026  2005              MOVS     r0,#5
000028  f7fffffe          BL       delay_us
;;;58     		if(CS546x_Get_SDO)	ReceiveDat |= 1;
00002c  2140              MOVS     r1,#0x40
00002e  4807              LDR      r0,|L11.76|
000030  f7fffffe          BL       GPIO_ReadInputDataBit
000034  b108              CBZ      r0,|L11.58|
000036  f0440401          ORR      r4,r4,#1
                  |L11.58|
;;;59     		ReceiveDat <<= 1;	
00003a  0660              LSLS     r0,r4,#25
00003c  0e04              LSRS     r4,r0,#24
00003e  1c68              ADDS     r0,r5,#1              ;52
000040  b2c5              UXTB     r5,r0                 ;52
                  |L11.66|
000042  2d07              CMP      r5,#7                 ;52
000044  dbe4              BLT      |L11.16|
;;;60     	}	
;;;61     	return ReceiveDat;
000046  4620              MOV      r0,r4
;;;62     }
000048  bd70              POP      {r4-r6,pc}
;;;63     /*
                          ENDP

00004a  0000              DCW      0x0000
                  |L11.76|
                          DCD      0x40010800

                          AREA ||i.CS546x_RedReg||, CODE, READONLY, ALIGN=2

                  CS546x_RedReg PROC
;;;97     */
;;;98     void CS546x_RedReg(u8 RegAddr,u8 *DustBuf)
000000  b570              PUSH     {r4-r6,lr}
;;;99     {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;100    	u8 i;	
;;;101    	CS546x_RESET_CS;
000006  2120              MOVS     r1,#0x20
000008  480b              LDR      r0,|L12.56|
00000a  f7fffffe          BL       GPIO_ResetBits
;;;102    	delay_us(10);
00000e  200a              MOVS     r0,#0xa
000010  f7fffffe          BL       delay_us
;;;103    	CS546x_Write_Byte(RegAddr);
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       CS546x_Write_Byte
;;;104    	for(i=0;i<3;i++)
00001a  2400              MOVS     r4,#0
00001c  e004              B        |L12.40|
                  |L12.30|
;;;105    	{
;;;106    		*(DustBuf+i) = CS546x_Read_Byte();
00001e  f7fffffe          BL       CS546x_Read_Byte
000022  5528              STRB     r0,[r5,r4]
000024  1c60              ADDS     r0,r4,#1              ;104
000026  b2c4              UXTB     r4,r0                 ;104
                  |L12.40|
000028  2c03              CMP      r4,#3                 ;104
00002a  dbf8              BLT      |L12.30|
;;;107    	}
;;;108    	CS546x_SET_CS;
00002c  2120              MOVS     r1,#0x20
00002e  4802              LDR      r0,|L12.56|
000030  f7fffffe          BL       GPIO_SetBits
;;;109    
;;;110    }
000034  bd70              POP      {r4-r6,pc}
;;;111    
                          ENDP

000036  0000              DCW      0x0000
                  |L12.56|
                          DCD      0x40010c00

                          AREA ||i.CS546x_ResetStaReg||, CODE, READONLY, ALIGN=2

                  CS546x_ResetStaReg PROC
;;;143    */
;;;144    void CS546x_ResetStaReg()
000000  b510              PUSH     {r4,lr}
;;;145    {
;;;146    	CS546x_Buff.u8[0] = 0xFF;
000002  20ff              MOVS     r0,#0xff
000004  4903              LDR      r1,|L13.20|
000006  7008              STRB     r0,[r1,#0]
;;;147    	CS546x_Buff.u8[1] = 0xFF;
000008  7048              STRB     r0,[r1,#1]
;;;148    	CS546x_Buff.u8[2] = 0xFF;
00000a  7088              STRB     r0,[r1,#2]
;;;149    
;;;150    	CS546x_WriteReg(Status | REG_WR,CS546x_Buff.u8);
00000c  205e              MOVS     r0,#0x5e
00000e  f7fffffe          BL       CS546x_WriteReg
;;;151    }
000012  bd10              POP      {r4,pc}
;;;152    
                          ENDP

                  |L13.20|
                          DCD      CS546x_Buff

                          AREA ||i.CS546x_WriteReg||, CODE, READONLY, ALIGN=2

                  CS546x_WriteReg PROC
;;;120    */
;;;121    void CS546x_WriteReg(u8 RegAddr,u8 *DustBuf)
000000  b570              PUSH     {r4-r6,lr}
;;;122    {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;123    	u8 i;	
;;;124    	CS546x_RESET_CS;
000006  2120              MOVS     r1,#0x20
000008  480b              LDR      r0,|L14.56|
00000a  f7fffffe          BL       GPIO_ResetBits
;;;125    	delay_us(10);
00000e  200a              MOVS     r0,#0xa
000010  f7fffffe          BL       delay_us
;;;126    	CS546x_Write_Byte(RegAddr);
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       CS546x_Write_Byte
;;;127    	for(i=0;i<3;i++)
00001a  2400              MOVS     r4,#0
00001c  e004              B        |L14.40|
                  |L14.30|
;;;128    	{
;;;129    		CS546x_Write_Byte(*(DustBuf+i));
00001e  5d28              LDRB     r0,[r5,r4]
000020  f7fffffe          BL       CS546x_Write_Byte
000024  1c60              ADDS     r0,r4,#1              ;127
000026  b2c4              UXTB     r4,r0                 ;127
                  |L14.40|
000028  2c03              CMP      r4,#3                 ;127
00002a  dbf8              BLT      |L14.30|
;;;130    	}
;;;131    	CS546x_SET_CS;
00002c  2120              MOVS     r1,#0x20
00002e  4802              LDR      r0,|L14.56|
000030  f7fffffe          BL       GPIO_SetBits
;;;132    
;;;133    }
000034  bd70              POP      {r4-r6,pc}
;;;134    
                          ENDP

000036  0000              DCW      0x0000
                  |L14.56|
                          DCD      0x40010c00

                          AREA ||i.CS546x_Write_Byte||, CODE, READONLY, ALIGN=2

                  CS546x_Write_Byte PROC
;;;71     */
;;;72     void CS546x_Write_Byte(u8 WrDat)
000000  b570              PUSH     {r4-r6,lr}
;;;73     {
000002  4604              MOV      r4,r0
;;;74     	u8  tmp_8u,i;
;;;75     	tmp_8u = WrDat;
000004  4625              MOV      r5,r4
;;;76     	for(i=0;i<8;i++)
000006  2600              MOVS     r6,#0
000008  e01d              B        |L15.70|
                  |L15.10|
;;;77     	{
;;;78     		delay_us(10);
00000a  200a              MOVS     r0,#0xa
00000c  f7fffffe          BL       delay_us
;;;79     		CS546x_RESET_CLK;
000010  2120              MOVS     r1,#0x20
000012  4812              LDR      r0,|L15.92|
000014  f7fffffe          BL       GPIO_ResetBits
;;;80     		if((tmp_8u&0x80)==0)	CS546x_RESET_SDI;
000018  f0050080          AND      r0,r5,#0x80
00001c  b920              CBNZ     r0,|L15.40|
00001e  2180              MOVS     r1,#0x80
000020  480e              LDR      r0,|L15.92|
000022  f7fffffe          BL       GPIO_ResetBits
000026  e003              B        |L15.48|
                  |L15.40|
;;;81     		else					CS546x_SET_SDI;
000028  2180              MOVS     r1,#0x80
00002a  480c              LDR      r0,|L15.92|
00002c  f7fffffe          BL       GPIO_SetBits
                  |L15.48|
;;;82     		delay_us(2);
000030  2002              MOVS     r0,#2
000032  f7fffffe          BL       delay_us
;;;83     		tmp_8u <<= 1;
000036  0668              LSLS     r0,r5,#25
000038  0e05              LSRS     r5,r0,#24
;;;84     		CS546x_SET_CLK;
00003a  2120              MOVS     r1,#0x20
00003c  4807              LDR      r0,|L15.92|
00003e  f7fffffe          BL       GPIO_SetBits
000042  1c70              ADDS     r0,r6,#1              ;76
000044  b2c6              UXTB     r6,r0                 ;76
                  |L15.70|
000046  2e08              CMP      r6,#8                 ;76
000048  dbdf              BLT      |L15.10|
;;;85     	}
;;;86     	delay_us(10);
00004a  200a              MOVS     r0,#0xa
00004c  f7fffffe          BL       delay_us
;;;87     	CS546x_RESET_CLK;
000050  2120              MOVS     r1,#0x20
000052  4802              LDR      r0,|L15.92|
000054  f7fffffe          BL       GPIO_ResetBits
;;;88     }
000058  bd70              POP      {r4-r6,pc}
;;;89     /*
                          ENDP

00005a  0000              DCW      0x0000
                  |L15.92|
                          DCD      0x40010800

                          AREA ||i.Get_InputValue||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  Get_InputValue PROC
;;;602    //Channal 检测通道
;;;603    void Get_InputValue(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;604    {
;;;605    	static UN32 Voltage_VA,Voltage_IA;
;;;606        static u8 Channal=Channal_A;
;;;607    	u8 CS546x_Sta,TimeCount;
;;;608        printf("CS5463检测, ");
000004  a07f              ADR      r0,|L16.516|
000006  f7fffffe          BL       __2printf
;;;609        if(Channal==Channal_A)
00000a  4882              LDR      r0,|L16.532|
00000c  7800              LDRB     r0,[r0,#0]  ; Channal
00000e  2801              CMP      r0,#1
000010  d149              BNE      |L16.166|
;;;610        {
;;;611            SetInput_CSCD4051Switch(IV_A);	//A相电压通道选择
000012  2002              MOVS     r0,#2
000014  f7fffffe          BL       SetInput_CSCD4051Switch
;;;612            SetInput_IICD4051Switch(II_A);	//A相电流通道选择
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       SetInput_IICD4051Switch
;;;613            delay_us(30);					//必要延时
00001e  201e              MOVS     r0,#0x1e
000020  f7fffffe          BL       delay_us
;;;614            printf("Channal_A,");
000024  a07c              ADR      r0,|L16.536|
000026  f7fffffe          BL       __2printf
;;;615            TimeCount = 10;
00002a  240a              MOVS     r4,#0xa
;;;616            while((0x01!=(CS546x_Sta&0x01))&&(TimeCount>0))
00002c  e007              B        |L16.62|
                  |L16.46|
;;;617            {
;;;618                TimeCount--;delay_ms(10);
00002e  1e60              SUBS     r0,r4,#1
000030  b2c4              UXTB     r4,r0
000032  200a              MOVS     r0,#0xa
000034  f7fffffe          BL       delay_ms
;;;619                CS546x_Sta	= CS5463_GetStaReg_Val();			//检测中断产生的原因
000038  f7fffffe          BL       CS5463_GetStaReg_Val
00003c  4605              MOV      r5,r0
                  |L16.62|
00003e  f0050001          AND      r0,r5,#1              ;616
000042  b908              CBNZ     r0,|L16.72|
000044  2c00              CMP      r4,#0                 ;616
000046  dcf2              BGT      |L16.46|
                  |L16.72|
;;;620            }
;;;621            printf("TimeCount:%2d. ",TimeCount);
000048  4621              MOV      r1,r4
00004a  a076              ADR      r0,|L16.548|
00004c  f7fffffe          BL       __2printf
;;;622            if(TimeCount>0)
000050  2c00              CMP      r4,#0
000052  dd21              BLE      |L16.152|
;;;623            {
;;;624                Voltage_VA.u32 = CS546x_Get_Vrms(); 
000054  f7fffffe          BL       CS546x_Get_Vrms
000058  4976              LDR      r1,|L16.564|
00005a  6008              STR      r0,[r1,#0]  ; Voltage_VA
;;;625                Voltage_IA.u32 = CS546x_Get_Irms(); 	//读有效电流值
00005c  f7fffffe          BL       CS546x_Get_Irms
000060  4975              LDR      r1,|L16.568|
000062  6008              STR      r0,[r1,#0]  ; Voltage_IA
;;;626                printf("A V:%3d.%dV , I:%3dmA.\r\n",Voltage_VA.u16[0]/10,Voltage_VA.u16[0]%10,Voltage_IA.u32);
000064  4873              LDR      r0,|L16.564|
000066  8800              LDRH     r0,[r0,#0]  ; Voltage_VA
000068  210a              MOVS     r1,#0xa
00006a  fb90f2f1          SDIV     r2,r0,r1
00006e  fb010612          MLS      r6,r1,r2,r0
000072  4870              LDR      r0,|L16.564|
000074  8800              LDRH     r0,[r0,#0]  ; Voltage_VA
000076  fb90f7f1          SDIV     r7,r0,r1
00007a  486f              LDR      r0,|L16.568|
00007c  4632              MOV      r2,r6
00007e  4639              MOV      r1,r7
000080  6803              LDR      r3,[r0,#0]  ; Voltage_IA
000082  a06e              ADR      r0,|L16.572|
000084  f7fffffe          BL       __2printf
;;;627                CS546x_ResetStaReg();
000088  f7fffffe          BL       CS546x_ResetStaReg
;;;628                Channal++;
00008c  4861              LDR      r0,|L16.532|
00008e  7800              LDRB     r0,[r0,#0]  ; Channal
000090  1c40              ADDS     r0,r0,#1
000092  4960              LDR      r1,|L16.532|
000094  7008              STRB     r0,[r1,#0]
000096  e0a9              B        |L16.492|
                  |L16.152|
;;;629            }
;;;630            else
;;;631            {
;;;632                CS546x_Init(0);
000098  2000              MOVS     r0,#0
00009a  f7fffffe          BL       CS546x_Init
;;;633                printf("CS546x_Init.\r\n");
00009e  a06e              ADR      r0,|L16.600|
0000a0  f7fffffe          BL       __2printf
0000a4  e0a2              B        |L16.492|
                  |L16.166|
;;;634            }
;;;635        }
;;;636        else if(Channal==Channal_B)
0000a6  485b              LDR      r0,|L16.532|
0000a8  7800              LDRB     r0,[r0,#0]  ; Channal
0000aa  2802              CMP      r0,#2
0000ac  d149              BNE      |L16.322|
;;;637        {
;;;638            SetInput_CSCD4051Switch(IV_B);	//B相电压通道选择
0000ae  2001              MOVS     r0,#1
0000b0  f7fffffe          BL       SetInput_CSCD4051Switch
;;;639            SetInput_IICD4051Switch(II_B);	//B相电流通道选择
0000b4  2001              MOVS     r0,#1
0000b6  f7fffffe          BL       SetInput_IICD4051Switch
;;;640            delay_us(30);					//必要延时
0000ba  201e              MOVS     r0,#0x1e
0000bc  f7fffffe          BL       delay_us
;;;641            printf("Channal_B,");
0000c0  a069              ADR      r0,|L16.616|
0000c2  f7fffffe          BL       __2printf
;;;642            TimeCount = 10;
0000c6  240a              MOVS     r4,#0xa
;;;643            while((0x01!=(CS546x_Sta&0x01))&&(TimeCount>0))
0000c8  e007              B        |L16.218|
                  |L16.202|
;;;644            {
;;;645                TimeCount--;delay_ms(10);
0000ca  1e60              SUBS     r0,r4,#1
0000cc  b2c4              UXTB     r4,r0
0000ce  200a              MOVS     r0,#0xa
0000d0  f7fffffe          BL       delay_ms
;;;646                CS546x_Sta	= CS5463_GetStaReg_Val();			//检测中断产生的原因
0000d4  f7fffffe          BL       CS5463_GetStaReg_Val
0000d8  4605              MOV      r5,r0
                  |L16.218|
0000da  f0050001          AND      r0,r5,#1              ;643
0000de  b908              CBNZ     r0,|L16.228|
0000e0  2c00              CMP      r4,#0                 ;643
0000e2  dcf2              BGT      |L16.202|
                  |L16.228|
;;;647            }            
;;;648            printf("TimeCount:%2d. ",TimeCount);
0000e4  4621              MOV      r1,r4
0000e6  a04f              ADR      r0,|L16.548|
0000e8  f7fffffe          BL       __2printf
;;;649            if(TimeCount>0)
0000ec  2c00              CMP      r4,#0
0000ee  dd21              BLE      |L16.308|
;;;650            {
;;;651                Voltage_VA.u32 = CS546x_Get_Vrms(); 
0000f0  f7fffffe          BL       CS546x_Get_Vrms
0000f4  494f              LDR      r1,|L16.564|
0000f6  6008              STR      r0,[r1,#0]  ; Voltage_VA
;;;652                Voltage_IA.u32 = CS546x_Get_Irms(); 	//读有效电流值
0000f8  f7fffffe          BL       CS546x_Get_Irms
0000fc  494e              LDR      r1,|L16.568|
0000fe  6008              STR      r0,[r1,#0]  ; Voltage_IA
;;;653                printf("B V:%3d.%dV , I:%3dmA.\r\n",Voltage_VA.u16[0]/10,Voltage_VA.u16[0]%10,Voltage_IA.u32);
000100  484c              LDR      r0,|L16.564|
000102  8800              LDRH     r0,[r0,#0]  ; Voltage_VA
000104  210a              MOVS     r1,#0xa
000106  fb90f2f1          SDIV     r2,r0,r1
00010a  fb010612          MLS      r6,r1,r2,r0
00010e  4849              LDR      r0,|L16.564|
000110  8800              LDRH     r0,[r0,#0]  ; Voltage_VA
000112  fb90f7f1          SDIV     r7,r0,r1
000116  4848              LDR      r0,|L16.568|
000118  4632              MOV      r2,r6
00011a  4639              MOV      r1,r7
00011c  6803              LDR      r3,[r0,#0]  ; Voltage_IA
00011e  a055              ADR      r0,|L16.628|
000120  f7fffffe          BL       __2printf
;;;654                CS546x_ResetStaReg();
000124  f7fffffe          BL       CS546x_ResetStaReg
;;;655                Channal++;
000128  483a              LDR      r0,|L16.532|
00012a  7800              LDRB     r0,[r0,#0]  ; Channal
00012c  1c40              ADDS     r0,r0,#1
00012e  4939              LDR      r1,|L16.532|
000130  7008              STRB     r0,[r1,#0]
000132  e05b              B        |L16.492|
                  |L16.308|
;;;656            }
;;;657            else
;;;658            {
;;;659                CS546x_Init(0);
000134  2000              MOVS     r0,#0
000136  f7fffffe          BL       CS546x_Init
;;;660                printf("CS546x_Init.\r\n");
00013a  a047              ADR      r0,|L16.600|
00013c  f7fffffe          BL       __2printf
000140  e054              B        |L16.492|
                  |L16.322|
;;;661            }
;;;662        }
;;;663        else if(Channal==Channal_C)
000142  4834              LDR      r0,|L16.532|
000144  7800              LDRB     r0,[r0,#0]  ; Channal
000146  2803              CMP      r0,#3
000148  d14a              BNE      |L16.480|
;;;664        {
;;;665            SetInput_CSCD4051Switch(IV_C);	//C相电压通道选择
00014a  2000              MOVS     r0,#0
00014c  f7fffffe          BL       SetInput_CSCD4051Switch
;;;666            SetInput_IICD4051Switch(II_C);	//C相电流通道选择
000150  2002              MOVS     r0,#2
000152  f7fffffe          BL       SetInput_IICD4051Switch
;;;667            delay_us(30);					//必要延时
000156  201e              MOVS     r0,#0x1e
000158  f7fffffe          BL       delay_us
;;;668            printf("Channal_C,");
00015c  a04c              ADR      r0,|L16.656|
00015e  f7fffffe          BL       __2printf
;;;669            CS546x_Sta	= CS5463_GetStaReg_Val();			//检测中断产生的原因
000162  f7fffffe          BL       CS5463_GetStaReg_Val
000166  4605              MOV      r5,r0
;;;670            TimeCount = 10;
000168  240a              MOVS     r4,#0xa
;;;671            while((0x01!=(CS546x_Sta&0x01))&&(TimeCount>0))
00016a  e007              B        |L16.380|
                  |L16.364|
;;;672            {
;;;673                TimeCount--;delay_ms(10);
00016c  1e60              SUBS     r0,r4,#1
00016e  b2c4              UXTB     r4,r0
000170  200a              MOVS     r0,#0xa
000172  f7fffffe          BL       delay_ms
;;;674                CS546x_Sta	= CS5463_GetStaReg_Val();			//检测中断产生的原因
000176  f7fffffe          BL       CS5463_GetStaReg_Val
00017a  4605              MOV      r5,r0
                  |L16.380|
00017c  f0050001          AND      r0,r5,#1              ;671
000180  b908              CBNZ     r0,|L16.390|
000182  2c00              CMP      r4,#0                 ;671
000184  dcf2              BGT      |L16.364|
                  |L16.390|
;;;675            }            
;;;676            printf("TimeCount:%2d. ",TimeCount);
000186  4621              MOV      r1,r4
000188  a026              ADR      r0,|L16.548|
00018a  f7fffffe          BL       __2printf
;;;677            if(TimeCount>0)
00018e  2c00              CMP      r4,#0
000190  dd1f              BLE      |L16.466|
;;;678            {
;;;679                Voltage_VA.u32 = CS546x_Get_Vrms(); 
000192  f7fffffe          BL       CS546x_Get_Vrms
000196  4927              LDR      r1,|L16.564|
000198  6008              STR      r0,[r1,#0]  ; Voltage_VA
;;;680                Voltage_IA.u32 = CS546x_Get_Irms(); 	//读有效电流值
00019a  f7fffffe          BL       CS546x_Get_Irms
00019e  4926              LDR      r1,|L16.568|
0001a0  6008              STR      r0,[r1,#0]  ; Voltage_IA
;;;681                printf("C V:%3d.%dV , I:%3dmA.\r\n",Voltage_VA.u16[0]/10,Voltage_VA.u16[0]%10,Voltage_IA.u32);
0001a2  4824              LDR      r0,|L16.564|
0001a4  8800              LDRH     r0,[r0,#0]  ; Voltage_VA
0001a6  210a              MOVS     r1,#0xa
0001a8  fb90f2f1          SDIV     r2,r0,r1
0001ac  fb010612          MLS      r6,r1,r2,r0
0001b0  4820              LDR      r0,|L16.564|
0001b2  8800              LDRH     r0,[r0,#0]  ; Voltage_VA
0001b4  fb90f7f1          SDIV     r7,r0,r1
0001b8  481f              LDR      r0,|L16.568|
0001ba  4632              MOV      r2,r6
0001bc  4639              MOV      r1,r7
0001be  6803              LDR      r3,[r0,#0]  ; Voltage_IA
0001c0  a036              ADR      r0,|L16.668|
0001c2  f7fffffe          BL       __2printf
;;;682                CS546x_ResetStaReg();
0001c6  f7fffffe          BL       CS546x_ResetStaReg
;;;683                Channal=Channal_A;
0001ca  2001              MOVS     r0,#1
0001cc  4911              LDR      r1,|L16.532|
0001ce  7008              STRB     r0,[r1,#0]
0001d0  e00c              B        |L16.492|
                  |L16.466|
;;;684            }
;;;685            else
;;;686            {
;;;687                CS546x_Init(0);
0001d2  2000              MOVS     r0,#0
0001d4  f7fffffe          BL       CS546x_Init
;;;688                printf("CS546x_Init.\r\n");
0001d8  a01f              ADR      r0,|L16.600|
0001da  f7fffffe          BL       __2printf
0001de  e005              B        |L16.492|
                  |L16.480|
;;;689            }
;;;690        }
;;;691        else
;;;692        {
;;;693            printf("Channal Error,goto Channal_A!\r\n");
0001e0  a035              ADR      r0,|L16.696|
0001e2  f7fffffe          BL       __2printf
;;;694            Channal=Channal_A;
0001e6  2001              MOVS     r0,#1
0001e8  490a              LDR      r1,|L16.532|
0001ea  7008              STRB     r0,[r1,#0]
                  |L16.492|
;;;695        }
;;;696        g_ShowDat[0] = (uint16_t)Voltage_VA.u16[0]/10;    //电压
0001ec  4811              LDR      r0,|L16.564|
0001ee  8800              LDRH     r0,[r0,#0]  ; Voltage_VA
0001f0  210a              MOVS     r1,#0xa
0001f2  fb90f0f1          SDIV     r0,r0,r1
0001f6  4938              LDR      r1,|L16.728|
0001f8  8008              STRH     r0,[r1,#0]
;;;697        g_ShowDat[1] = (uint16_t)Voltage_IA.u32;          //电压
0001fa  480f              LDR      r0,|L16.568|
0001fc  8800              LDRH     r0,[r0,#0]  ; Voltage_IA
0001fe  8048              STRH     r0,[r1,#2]
;;;698    }
000200  e8bd81f0          POP      {r4-r8,pc}
;;;699    
                          ENDP

                  |L16.516|
000204  43533534          DCB      "CS5463",188,236,178,226,", ",0
000208  3633bcec
00020c  b2e22c20
000210  00      
000211  00                DCB      0
000212  00                DCB      0
000213  00                DCB      0
                  |L16.532|
                          DCD      Channal
                  |L16.536|
000218  4368616e          DCB      "Channal_A,",0
00021c  6e616c5f
000220  412c00  
000223  00                DCB      0
                  |L16.548|
000224  54696d65          DCB      "TimeCount:%2d. ",0
000228  436f756e
00022c  743a2532
000230  642e2000
                  |L16.564|
                          DCD      Voltage_VA
                  |L16.568|
                          DCD      Voltage_IA
                  |L16.572|
00023c  4120563a          DCB      "A V:%3d.%dV , I:%3dmA.\r\n",0
000240  2533642e
000244  25645620
000248  2c20493a
00024c  2533646d
000250  412e0d0a
000254  00      
000255  00                DCB      0
000256  00                DCB      0
000257  00                DCB      0
                  |L16.600|
000258  43533534          DCB      "CS546x_Init.\r\n",0
00025c  36785f49
000260  6e69742e
000264  0d0a00  
000267  00                DCB      0
                  |L16.616|
000268  4368616e          DCB      "Channal_B,",0
00026c  6e616c5f
000270  422c00  
000273  00                DCB      0
                  |L16.628|
000274  4220563a          DCB      "B V:%3d.%dV , I:%3dmA.\r\n",0
000278  2533642e
00027c  25645620
000280  2c20493a
000284  2533646d
000288  412e0d0a
00028c  00      
00028d  00                DCB      0
00028e  00                DCB      0
00028f  00                DCB      0
                  |L16.656|
000290  4368616e          DCB      "Channal_C,",0
000294  6e616c5f
000298  432c00  
00029b  00                DCB      0
                  |L16.668|
00029c  4320563a          DCB      "C V:%3d.%dV , I:%3dmA.\r\n",0
0002a0  2533642e
0002a4  25645620
0002a8  2c20493a
0002ac  2533646d
0002b0  412e0d0a
0002b4  00      
0002b5  00                DCB      0
0002b6  00                DCB      0
0002b7  00                DCB      0
                  |L16.696|
0002b8  4368616e          DCB      "Channal Error,goto Channal_A!\r\n",0
0002bc  6e616c20
0002c0  4572726f
0002c4  722c676f
0002c8  746f2043
0002cc  68616e6e
0002d0  616c5f41
0002d4  210d0a00
                  |L16.728|
                          DCD      g_ShowDat

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  Board_Phase
                          %        12

                          AREA ||.data||, DATA, ALIGN=2

                  CS546x_Buff
                          DCD      0x00000000
                  RX_Buff
                          DCD      0x00000000
                  ||sta||
000008  00000000          DCB      0x00,0x00,0x00,0x00
                  Voltage_VA
                          DCD      0x00000000
                  Voltage_IA
                          DCD      0x00000000
                  Channal
000014  01                DCB      0x01
