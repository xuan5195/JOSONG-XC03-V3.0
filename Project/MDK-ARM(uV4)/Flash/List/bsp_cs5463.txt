; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_cs5463.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_cs5463.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User -I"C:\Users\xuan5\Desktop\JOSONG-XS03 V3.0\Project\MDK-ARM(uV4)\RTE" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=521 -D_RTE_ -DSTM32F10X_MD -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=.\flash\obj\bsp_cs5463.crf ..\..\User\bsp\bsp_cs5463.c]
                          THUMB

                          AREA ||i.Bsp_CS5463_Config||, CODE, READONLY, ALIGN=2

                  Bsp_CS5463_Config PROC
;;;17     
;;;18     void Bsp_CS5463_Config(void) 
000000  b508              PUSH     {r3,lr}
;;;19     {
;;;20     	GPIO_InitTypeDef GPIO_InitStructure;
;;;21     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOB, ENABLE); 
000002  2101              MOVS     r1,#1
000004  200c              MOVS     r0,#0xc
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;22     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5|GPIO_Pin_7;
00000a  20a0              MOVS     r0,#0xa0
00000c  f8ad0000          STRH     r0,[sp,#0]
;;;23     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
000010  2010              MOVS     r0,#0x10
000012  f88d0003          STRB     r0,[sp,#3]
;;;24     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000016  2003              MOVS     r0,#3
000018  f88d0002          STRB     r0,[sp,#2]
;;;25     	GPIO_Init(GPIOA, &GPIO_InitStructure);
00001c  4669              MOV      r1,sp
00001e  480d              LDR      r0,|L1.84|
000020  f7fffffe          BL       GPIO_Init
;;;26     
;;;27     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3|GPIO_Pin_4|GPIO_Pin_5;
000024  2038              MOVS     r0,#0x38
000026  f8ad0000          STRH     r0,[sp,#0]
;;;28     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
00002a  2010              MOVS     r0,#0x10
00002c  f88d0003          STRB     r0,[sp,#3]
;;;29     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000030  2003              MOVS     r0,#3
000032  f88d0002          STRB     r0,[sp,#2]
;;;30     	GPIO_Init(GPIOB, &GPIO_InitStructure);
000036  4669              MOV      r1,sp
000038  4807              LDR      r0,|L1.88|
00003a  f7fffffe          BL       GPIO_Init
;;;31     	
;;;32     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
00003e  2040              MOVS     r0,#0x40
000040  f8ad0000          STRH     r0,[sp,#0]
;;;33     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;	//上拉输入
000044  2048              MOVS     r0,#0x48
000046  f88d0003          STRB     r0,[sp,#3]
;;;34     	GPIO_Init(GPIOA, &GPIO_InitStructure);
00004a  4669              MOV      r1,sp
00004c  4801              LDR      r0,|L1.84|
00004e  f7fffffe          BL       GPIO_Init
;;;35     }
000052  bd08              POP      {r3,pc}
;;;36     
                          ENDP

                  |L1.84|
                          DCD      0x40010800
                  |L1.88|
                          DCD      0x40010c00

                          AREA ||i.CS5463CMD||, CODE, READONLY, ALIGN=2

                  CS5463CMD PROC
;;;182    */
;;;183    static void CS5463CMD(u8 cmd)
000000  b570              PUSH     {r4-r6,lr}
;;;184    {
000002  4604              MOV      r4,r0
;;;185        u8 i;
;;;186        CS546x_SET_CLK;		//SCLK = 1;
000004  2120              MOVS     r1,#0x20
000006  481a              LDR      r0,|L2.112|
000008  f7fffffe          BL       GPIO_SetBits
;;;187        CS546x_RESET_CS;	//CS = 0;
00000c  2120              MOVS     r1,#0x20
00000e  4819              LDR      r0,|L2.116|
000010  f7fffffe          BL       GPIO_ResetBits
;;;188        i = 0;
000014  2500              MOVS     r5,#0
;;;189        while(i<8)
000016  e01d              B        |L2.84|
                  |L2.24|
;;;190        {
;;;191            delay_us(50);		//uDelay(50);
000018  2032              MOVS     r0,#0x32
00001a  f7fffffe          BL       delay_us
;;;192            CS546x_RESET_CLK;	//SCLK = 0;
00001e  2120              MOVS     r1,#0x20
000020  4813              LDR      r0,|L2.112|
000022  f7fffffe          BL       GPIO_ResetBits
;;;193            if(cmd&0x80)    CS546x_SET_SDI;		//MOSI = 1;
000026  f0040080          AND      r0,r4,#0x80
00002a  b120              CBZ      r0,|L2.54|
00002c  2180              MOVS     r1,#0x80
00002e  4810              LDR      r0,|L2.112|
000030  f7fffffe          BL       GPIO_SetBits
000034  e003              B        |L2.62|
                  |L2.54|
;;;194            else		    CS546x_RESET_SDI;	//MOSI = 0;
000036  2180              MOVS     r1,#0x80
000038  480d              LDR      r0,|L2.112|
00003a  f7fffffe          BL       GPIO_ResetBits
                  |L2.62|
;;;195            delay_us(50);		//uDelay(50);
00003e  2032              MOVS     r0,#0x32
000040  f7fffffe          BL       delay_us
;;;196            CS546x_SET_CLK;		//SCLK = 1;			 		//在时钟上升沿，数据被写入CS5463
000044  2120              MOVS     r1,#0x20
000046  480a              LDR      r0,|L2.112|
000048  f7fffffe          BL       GPIO_SetBits
;;;197            cmd <<= 1;
00004c  0660              LSLS     r0,r4,#25
00004e  0e04              LSRS     r4,r0,#24
;;;198            i++;
000050  1c68              ADDS     r0,r5,#1
000052  b2c5              UXTB     r5,r0
                  |L2.84|
000054  2d08              CMP      r5,#8                 ;189
000056  dbdf              BLT      |L2.24|
;;;199        }
;;;200        delay_us(50);		//uDelay(50);
000058  2032              MOVS     r0,#0x32
00005a  f7fffffe          BL       delay_us
;;;201        CS546x_SET_SDI;		//MOSI = 1;
00005e  2180              MOVS     r1,#0x80
000060  4803              LDR      r0,|L2.112|
000062  f7fffffe          BL       GPIO_SetBits
;;;202        CS546x_SET_CS;		//CS = 1;
000066  2120              MOVS     r1,#0x20
000068  4802              LDR      r0,|L2.116|
00006a  f7fffffe          BL       GPIO_SetBits
;;;203    }
00006e  bd70              POP      {r4-r6,pc}
;;;204    
                          ENDP

                  |L2.112|
                          DCD      0x40010800
                  |L2.116|
                          DCD      0x40010c00

                          AREA ||i.CS5463ReadReg||, CODE, READONLY, ALIGN=2

                  CS5463ReadReg PROC
;;;265    */
;;;266    void CS5463ReadReg(u8 addr,u8 *p)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;267    {	
000004  4605              MOV      r5,r0
000006  4688              MOV      r8,r1
;;;268        u8 i,j;
;;;269        u8 dat;
;;;270        CS546x_RESET_CS;	//CS = 0;
000008  2120              MOVS     r1,#0x20
00000a  4837              LDR      r0,|L3.232|
00000c  f7fffffe          BL       GPIO_ResetBits
;;;271        addr &= READ_MASK;
000010  f00505bf          AND      r5,r5,#0xbf
;;;272        i = 0;
000014  2400              MOVS     r4,#0
;;;273        while(i<8)
000016  e01d              B        |L3.84|
                  |L3.24|
;;;274        {
;;;275            delay_us(50);		//uDelay(50);
000018  2032              MOVS     r0,#0x32
00001a  f7fffffe          BL       delay_us
;;;276            CS546x_RESET_CLK;	//SCLK = 0;
00001e  2120              MOVS     r1,#0x20
000020  4832              LDR      r0,|L3.236|
000022  f7fffffe          BL       GPIO_ResetBits
;;;277            if(addr&0x80)CS546x_SET_SDI;	//MOSI = 1;
000026  f0050080          AND      r0,r5,#0x80
00002a  b120              CBZ      r0,|L3.54|
00002c  2180              MOVS     r1,#0x80
00002e  482f              LDR      r0,|L3.236|
000030  f7fffffe          BL       GPIO_SetBits
000034  e003              B        |L3.62|
                  |L3.54|
;;;278            else		 CS546x_RESET_SDI;	//MOSI = 0;
000036  2180              MOVS     r1,#0x80
000038  482c              LDR      r0,|L3.236|
00003a  f7fffffe          BL       GPIO_ResetBits
                  |L3.62|
;;;279            delay_us(50);		//uDelay(50);
00003e  2032              MOVS     r0,#0x32
000040  f7fffffe          BL       delay_us
;;;280            CS546x_SET_CLK;		//SCLK = 1;
000044  2120              MOVS     r1,#0x20
000046  4829              LDR      r0,|L3.236|
000048  f7fffffe          BL       GPIO_SetBits
;;;281            addr <<= 1;	//在时钟上升沿，数据被写入CS5463
00004c  0668              LSLS     r0,r5,#25
00004e  0e05              LSRS     r5,r0,#24
;;;282            i++;
000050  1c60              ADDS     r0,r4,#1
000052  b2c4              UXTB     r4,r0
                  |L3.84|
000054  2c08              CMP      r4,#8                 ;273
000056  dbdf              BLT      |L3.24|
;;;283        }
;;;284    
;;;285        CS546x_SET_SDI;		//MOSI = 1;
000058  2180              MOVS     r1,#0x80
00005a  4824              LDR      r0,|L3.236|
00005c  f7fffffe          BL       GPIO_SetBits
;;;286        j = 0;
000060  2600              MOVS     r6,#0
;;;287        while(j<3)
000062  e032              B        |L3.202|
                  |L3.100|
;;;288        {
;;;289            i = 0;
000064  2400              MOVS     r4,#0
;;;290            dat = 0;
000066  2700              MOVS     r7,#0
;;;291            while(i<8)
000068  e029              B        |L3.190|
                  |L3.106|
;;;292            {
;;;293                delay_us(50);		//uDelay(50);
00006a  2032              MOVS     r0,#0x32
00006c  f7fffffe          BL       delay_us
;;;294                CS546x_RESET_CLK;	//SCLK = 0;
000070  2120              MOVS     r1,#0x20
000072  481e              LDR      r0,|L3.236|
000074  f7fffffe          BL       GPIO_ResetBits
;;;295                if(i==7)CS546x_RESET_SDI;	//MOSI = 0;
000078  2c07              CMP      r4,#7
00007a  d104              BNE      |L3.134|
00007c  2180              MOVS     r1,#0x80
00007e  481b              LDR      r0,|L3.236|
000080  f7fffffe          BL       GPIO_ResetBits
000084  e003              B        |L3.142|
                  |L3.134|
;;;296                else	CS546x_SET_SDI;		//MOSI = 1;
000086  2180              MOVS     r1,#0x80
000088  4818              LDR      r0,|L3.236|
00008a  f7fffffe          BL       GPIO_SetBits
                  |L3.142|
;;;297                delay_us(50);		//uDelay(50);
00008e  2032              MOVS     r0,#0x32
000090  f7fffffe          BL       delay_us
;;;298                dat <<= 1;			 			
000094  0678              LSLS     r0,r7,#25
000096  0e07              LSRS     r7,r0,#24
;;;299                if(CS546x_Get_SDO)	dat |= 0x01;
000098  2140              MOVS     r1,#0x40
00009a  4814              LDR      r0,|L3.236|
00009c  f7fffffe          BL       GPIO_ReadInputDataBit
0000a0  b110              CBZ      r0,|L3.168|
0000a2  f0470701          ORR      r7,r7,#1
0000a6  e001              B        |L3.172|
                  |L3.168|
;;;300                else				dat &= 0xFE;
0000a8  f00707fe          AND      r7,r7,#0xfe
                  |L3.172|
;;;301                CS546x_SET_CLK;		//SCLK = 1;
0000ac  2120              MOVS     r1,#0x20
0000ae  480f              LDR      r0,|L3.236|
0000b0  f7fffffe          BL       GPIO_SetBits
;;;302                delay_us(50);		//uDelay(50);					 		
0000b4  2032              MOVS     r0,#0x32
0000b6  f7fffffe          BL       delay_us
;;;303                i++;
0000ba  1c60              ADDS     r0,r4,#1
0000bc  b2c4              UXTB     r4,r0
                  |L3.190|
0000be  2c08              CMP      r4,#8                 ;291
0000c0  dbd3              BLT      |L3.106|
;;;304            }
;;;305            *(p+j) = dat;
0000c2  f8087006          STRB     r7,[r8,r6]
;;;306            j++;
0000c6  1c70              ADDS     r0,r6,#1
0000c8  b2c6              UXTB     r6,r0
                  |L3.202|
0000ca  2e03              CMP      r6,#3                 ;287
0000cc  dbca              BLT      |L3.100|
;;;307        }
;;;308        delay_us(50);		//uDelay(50);
0000ce  2032              MOVS     r0,#0x32
0000d0  f7fffffe          BL       delay_us
;;;309        CS546x_SET_SDI;		//MOSI = 1;
0000d4  2180              MOVS     r1,#0x80
0000d6  4805              LDR      r0,|L3.236|
0000d8  f7fffffe          BL       GPIO_SetBits
;;;310        CS546x_SET_CS;		//CS = 1;
0000dc  2120              MOVS     r1,#0x20
0000de  4802              LDR      r0,|L3.232|
0000e0  f7fffffe          BL       GPIO_SetBits
;;;311    }
0000e4  e8bd81f0          POP      {r4-r8,pc}
;;;312    
                          ENDP

                  |L3.232|
                          DCD      0x40010c00
                  |L3.236|
                          DCD      0x40010800

                          AREA ||i.CS5463WriteReg||, CODE, READONLY, ALIGN=2

                  CS5463WriteReg PROC
;;;214    */
;;;215    void CS5463WriteReg(u8 addr,u8 *p)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;216    {	
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
;;;217        u8 i,j;
;;;218        u8 dat;
;;;219        CS546x_RESET_CS;	//CS = 0;
000008  2120              MOVS     r1,#0x20
00000a  4832              LDR      r0,|L4.212|
00000c  f7fffffe          BL       GPIO_ResetBits
;;;220        i = 0;
000010  2400              MOVS     r4,#0
;;;221        while(i<8)
000012  e01d              B        |L4.80|
                  |L4.20|
;;;222        {
;;;223            delay_us(50);		//uDelay(50);
000014  2032              MOVS     r0,#0x32
000016  f7fffffe          BL       delay_us
;;;224            CS546x_RESET_CLK;	//SCLK = 0;
00001a  2120              MOVS     r1,#0x20
00001c  482e              LDR      r0,|L4.216|
00001e  f7fffffe          BL       GPIO_ResetBits
;;;225            if(addr&0x80)CS546x_SET_SDI;	//MOSI = 1;
000022  f0060080          AND      r0,r6,#0x80
000026  b120              CBZ      r0,|L4.50|
000028  2180              MOVS     r1,#0x80
00002a  482b              LDR      r0,|L4.216|
00002c  f7fffffe          BL       GPIO_SetBits
000030  e003              B        |L4.58|
                  |L4.50|
;;;226            else		 CS546x_RESET_SDI;	//MOSI = 0;
000032  2180              MOVS     r1,#0x80
000034  4828              LDR      r0,|L4.216|
000036  f7fffffe          BL       GPIO_ResetBits
                  |L4.58|
;;;227            delay_us(50);		//uDelay(50);
00003a  2032              MOVS     r0,#0x32
00003c  f7fffffe          BL       delay_us
;;;228            CS546x_SET_CLK;		//SCLK = 1;	//在时钟上升沿，数据被写入CS5463
000040  2120              MOVS     r1,#0x20
000042  4825              LDR      r0,|L4.216|
000044  f7fffffe          BL       GPIO_SetBits
;;;229            addr <<= 1;
000048  0670              LSLS     r0,r6,#25
00004a  0e06              LSRS     r6,r0,#24
;;;230            i++;
00004c  1c60              ADDS     r0,r4,#1
00004e  b2c4              UXTB     r4,r0
                  |L4.80|
000050  2c08              CMP      r4,#8                 ;221
000052  dbdf              BLT      |L4.20|
;;;231        }
;;;232        j = 0;
000054  2500              MOVS     r5,#0
;;;233        delay_us(50);		//uDelay(50);
000056  2032              MOVS     r0,#0x32
000058  f7fffffe          BL       delay_us
;;;234        while(j<3)
00005c  e02a              B        |L4.180|
                  |L4.94|
;;;235        {
;;;236            dat = *(p+j);
00005e  f8178005          LDRB     r8,[r7,r5]
;;;237            i = 0;
000062  2400              MOVS     r4,#0
;;;238            while(i<8)
000064  e01f              B        |L4.166|
                  |L4.102|
;;;239            {
;;;240                delay_us(50);		//uDelay(50);
000066  2032              MOVS     r0,#0x32
000068  f7fffffe          BL       delay_us
;;;241                CS546x_RESET_CLK;	//SCLK = 0;
00006c  2120              MOVS     r1,#0x20
00006e  481a              LDR      r0,|L4.216|
000070  f7fffffe          BL       GPIO_ResetBits
;;;242                if(dat&0x80)CS546x_SET_SDI;		//MOSI = 1;
000074  f0080080          AND      r0,r8,#0x80
000078  b120              CBZ      r0,|L4.132|
00007a  2180              MOVS     r1,#0x80
00007c  4816              LDR      r0,|L4.216|
00007e  f7fffffe          BL       GPIO_SetBits
000082  e003              B        |L4.140|
                  |L4.132|
;;;243                else		CS546x_RESET_SDI;	//MOSI = 0;
000084  2180              MOVS     r1,#0x80
000086  4814              LDR      r0,|L4.216|
000088  f7fffffe          BL       GPIO_ResetBits
                  |L4.140|
;;;244                delay_us(50);		//uDelay(50);
00008c  2032              MOVS     r0,#0x32
00008e  f7fffffe          BL       delay_us
;;;245                CS546x_SET_CLK;		//SCLK = 1;   //在时钟上升沿，数据被写入CS5463
000092  2120              MOVS     r1,#0x20
000094  4810              LDR      r0,|L4.216|
000096  f7fffffe          BL       GPIO_SetBits
;;;246                dat <<= 1;
00009a  ea4f6048          LSL      r0,r8,#25
00009e  ea4f6810          LSR      r8,r0,#24
;;;247                i++;
0000a2  1c60              ADDS     r0,r4,#1
0000a4  b2c4              UXTB     r4,r0
                  |L4.166|
0000a6  2c08              CMP      r4,#8                 ;238
0000a8  dbdd              BLT      |L4.102|
;;;248            }
;;;249            delay_us(50);		//uDelay(50);
0000aa  2032              MOVS     r0,#0x32
0000ac  f7fffffe          BL       delay_us
;;;250            j++;
0000b0  1c68              ADDS     r0,r5,#1
0000b2  b2c5              UXTB     r5,r0
                  |L4.180|
0000b4  2d03              CMP      r5,#3                 ;234
0000b6  dbd2              BLT      |L4.94|
;;;251        }
;;;252        CS546x_SET_SDI;		//MOSI = 1;
0000b8  2180              MOVS     r1,#0x80
0000ba  4807              LDR      r0,|L4.216|
0000bc  f7fffffe          BL       GPIO_SetBits
;;;253        CS546x_SET_CS;		//CS = 1;
0000c0  2120              MOVS     r1,#0x20
0000c2  4804              LDR      r0,|L4.212|
0000c4  f7fffffe          BL       GPIO_SetBits
;;;254        delay_us(50);		//uDelay(50);	
0000c8  2032              MOVS     r0,#0x32
0000ca  f7fffffe          BL       delay_us
;;;255    }
0000ce  e8bd81f0          POP      {r4-r8,pc}
;;;256    
                          ENDP

0000d2  0000              DCW      0x0000
                  |L4.212|
                          DCD      0x40010c00
                  |L4.216|
                          DCD      0x40010800

                          AREA ||i.CS5463_GetStaReg_Val||, CODE, READONLY, ALIGN=2

                  CS5463_GetStaReg_Val PROC
;;;375    */
;;;376    u8 CS5463_GetStaReg_Val(void)
000000  b510              PUSH     {r4,lr}
;;;377    {
;;;378    	u8 ret=0;
000002  2400              MOVS     r4,#0
;;;379    
;;;380    	CS5463ReadReg(Status | REG_RD,CS546x_Buff.u8);
000004  490c              LDR      r1,|L5.56|
000006  201e              MOVS     r0,#0x1e
000008  f7fffffe          BL       CS5463ReadReg
;;;381    	if(CS546x_Buff.u8[0] & 0x80)
00000c  480a              LDR      r0,|L5.56|
00000e  7800              LDRB     r0,[r0,#0]  ; CS546x_Buff
000010  f0000080          AND      r0,r0,#0x80
000014  b170              CBZ      r0,|L5.52|
;;;382    	{
;;;383    		//检测电流/电压是否超出范围
;;;384    		//检测电流有效值/电压有效值/电能是否超出范围
;;;385    		if((CS546x_Buff.u8[0]&0x03)||(CS546x_Buff.u8[1]&0x70))
000016  4808              LDR      r0,|L5.56|
000018  7800              LDRB     r0,[r0,#0]  ; CS546x_Buff
00001a  f0000003          AND      r0,r0,#3
00001e  b920              CBNZ     r0,|L5.42|
000020  4805              LDR      r0,|L5.56|
000022  7840              LDRB     r0,[r0,#1]  ; CS546x_Buff
000024  f0000070          AND      r0,r0,#0x70
000028  b110              CBZ      r0,|L5.48|
                  |L5.42|
;;;386    		{
;;;387    		 	CS546x_ResetStaReg();		//复位状态寄存器
00002a  f7fffffe          BL       CS546x_ResetStaReg
00002e  e001              B        |L5.52|
                  |L5.48|
;;;388    		}else
;;;389    		{
;;;390    			ret |= 0x01;//B0000_0001;	//这什么意思 还可以这样写吗？ PT2017-2-8   分隔符吗？ 
000030  f0440401          ORR      r4,r4,#1
                  |L5.52|
;;;391    		}
;;;392    	}
;;;393    
;;;394    	return ret;
000034  4620              MOV      r0,r4
;;;395    }
000036  bd10              POP      {r4,pc}
;;;396    
                          ENDP

                  |L5.56|
                          DCD      CS546x_Buff

                          AREA ||i.CS5463_GetStatusReg||, CODE, READONLY, ALIGN=2

                  CS5463_GetStatusReg PROC
;;;338    */
;;;339    u8 CS5463_GetStatusReg(void)
000000  b510              PUSH     {r4,lr}
;;;340    { 
;;;341    	u8 sta=0;
000002  2400              MOVS     r4,#0
;;;342    
;;;343    	CS5463ReadReg(0x1E,RX_Buff);	   //1E 是什么？   状态寄存器
000004  4910              LDR      r1,|L6.72|
000006  201e              MOVS     r0,#0x1e
000008  f7fffffe          BL       CS5463ReadReg
;;;344    	if(RX_Buff[0]&0x80)		   			//检测：电流、电压、功率测量是否完毕
00000c  480e              LDR      r0,|L6.72|
00000e  7800              LDRB     r0,[r0,#0]  ; RX_Buff
000010  f0000080          AND      r0,r0,#0x80
000014  b170              CBZ      r0,|L6.52|
;;;345    	{
;;;346    		//检测电流/电压是否超出范围
;;;347    		//检测电流有效值/电压有效值/电能是否超出范围
;;;348    		if((RX_Buff[0]&0x03)||(RX_Buff[1]&0x70))
000016  480c              LDR      r0,|L6.72|
000018  7800              LDRB     r0,[r0,#0]  ; RX_Buff
00001a  f0000003          AND      r0,r0,#3
00001e  b920              CBNZ     r0,|L6.42|
000020  4809              LDR      r0,|L6.72|
000022  7840              LDRB     r0,[r0,#1]  ; RX_Buff
000024  f0000070          AND      r0,r0,#0x70
000028  b110              CBZ      r0,|L6.48|
                  |L6.42|
;;;349    		{
;;;350    			CS5463_ResetStatusReg();		//复位状态寄存器
00002a  f7fffffe          BL       CS5463_ResetStatusReg
00002e  e001              B        |L6.52|
                  |L6.48|
;;;351    		}
;;;352    		else
;;;353    		{
;;;354    			sta |= 0x01;//B0000_0001;	//这什么意思 还可以这样写吗？ PT2017-2-8   分隔符吗？ 
000030  f0440401          ORR      r4,r4,#1
                  |L6.52|
;;;355    		}
;;;356    	}
;;;357    
;;;358    	if(RX_Buff[2]&0x80)			   	//检测：温度测量是否完毕
000034  4804              LDR      r0,|L6.72|
000036  7880              LDRB     r0,[r0,#2]  ; RX_Buff
000038  f0000080          AND      r0,r0,#0x80
00003c  b108              CBZ      r0,|L6.66|
;;;359    	{
;;;360    		sta |=0x02; //B0000_0010;
00003e  f0440402          ORR      r4,r4,#2
                  |L6.66|
;;;361    	} 
;;;362    	return(sta);	
000042  4620              MOV      r0,r4
;;;363    }  
000044  bd10              POP      {r4,pc}
;;;364    
                          ENDP

000046  0000              DCW      0x0000
                  |L6.72|
                          DCD      RX_Buff

                          AREA ||i.CS5463_ResetStatusReg||, CODE, READONLY, ALIGN=2

                  CS5463_ResetStatusReg PROC
;;;321    */
;;;322    static void CS5463_ResetStatusReg(void)
000000  b510              PUSH     {r4,lr}
;;;323    {
;;;324        RX_Buff[0] = 0xFF;
000002  20ff              MOVS     r0,#0xff
000004  4903              LDR      r1,|L7.20|
000006  7008              STRB     r0,[r1,#0]
;;;325        RX_Buff[1] = 0xFF;
000008  7048              STRB     r0,[r1,#1]
;;;326        RX_Buff[2] = 0xFF;
00000a  7088              STRB     r0,[r1,#2]
;;;327        CS5463WriteReg(0x5E,RX_Buff);		//复位状态寄存器	#define REG_STATUSR 	0x5E 	//状态  
00000c  205e              MOVS     r0,#0x5e
00000e  f7fffffe          BL       CS5463WriteReg
;;;328    }
000012  bd10              POP      {r4,pc}
;;;329    
                          ENDP

                  |L7.20|
                          DCD      RX_Buff

                          AREA ||i.CS546x_Get_Irms||, CODE, READONLY, ALIGN=2

                  CS546x_Get_Irms PROC
;;;467    */
;;;468    u32 CS546x_Get_Irms()
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;469    {
;;;470    	float Tmp;
;;;471    	UN32 ResceBuf;
;;;472        u8 DustBuf[4]={0};
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;473    
;;;474        
;;;475    	ResceBuf.u32 = 0;
000008  9001              STR      r0,[sp,#4]
;;;476    	Tmp = 0;
00000a  2400              MOVS     r4,#0
;;;477    	CS5463ReadReg(REG_RD|Irms,DustBuf);
00000c  4669              MOV      r1,sp
00000e  2016              MOVS     r0,#0x16
000010  f7fffffe          BL       CS5463ReadReg
;;;478    	ResceBuf.u8[0] =  DustBuf[2];
000014  f89d0002          LDRB     r0,[sp,#2]
000018  f88d0004          STRB     r0,[sp,#4]
;;;479    	ResceBuf.u8[1] =  DustBuf[1];
00001c  f89d0001          LDRB     r0,[sp,#1]
000020  f88d0005          STRB     r0,[sp,#5]
;;;480    	ResceBuf.u8[2] =  DustBuf[0];
000024  f89d0000          LDRB     r0,[sp,#0]
000028  f88d0006          STRB     r0,[sp,#6]
;;;481    	Tmp = ResceBuf.u32/16777215.0;
00002c  9801              LDR      r0,[sp,#4]
00002e  f7fffffe          BL       __aeabi_ui2d
000032  4607              MOV      r7,r0
000034  f04f4260          MOV      r2,#0xe0000000
000038  4b0b              LDR      r3,|L8.104|
00003a  f7fffffe          BL       __aeabi_ddiv
00003e  4605              MOV      r5,r0
000040  f7fffffe          BL       __aeabi_d2f
000044  4604              MOV      r4,r0
;;;482    	Tmp = Tmp*CS5463_IScale;//I_Coff;		//计算电流值 暂时不用 
000046  4909              LDR      r1,|L8.108|
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       __aeabi_fmul
00004e  4604              MOV      r4,r0
;;;483    	Tmp *= 1000;
000050  4907              LDR      r1,|L8.112|
000052  4620              MOV      r0,r4
000054  f7fffffe          BL       __aeabi_fmul
000058  4604              MOV      r4,r0
;;;484    	ResceBuf.u32 = (u32)Tmp;
00005a  4620              MOV      r0,r4
00005c  f7fffffe          BL       __aeabi_f2uiz
000060  9001              STR      r0,[sp,#4]
;;;485    	
;;;486    	return ResceBuf.u32;
000062  9801              LDR      r0,[sp,#4]
;;;487    }
000064  e8bd81fc          POP      {r2-r8,pc}
;;;488    
                          ENDP

                  |L8.104|
                          DCD      0x416fffff
                  |L8.108|
                          DCD      0x41100000
                  |L8.112|
                          DCD      0x447a0000

                          AREA ||i.CS546x_Get_Vrms||, CODE, READONLY, ALIGN=2

                  CS546x_Get_Vrms PROC
;;;414    */
;;;415    u32 CS546x_Get_Vrms()
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;416    {
;;;417    	float Tmp;
;;;418    	UN32 ResceBuf;
;;;419    	u8 DustBuf[4]={0};
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;420    	
;;;421    	ResceBuf.u32 = 0;
000008  9001              STR      r0,[sp,#4]
;;;422    	CS5463ReadReg(REG_RD|Vrms,DustBuf);
00000a  4669              MOV      r1,sp
00000c  2018              MOVS     r0,#0x18
00000e  f7fffffe          BL       CS5463ReadReg
;;;423    //	ShowHex(DustBuf,4);						//打印原始数据
;;;424    
;;;425    	ResceBuf.u8[0] =  DustBuf[2];
000012  f89d0002          LDRB     r0,[sp,#2]
000016  f88d0004          STRB     r0,[sp,#4]
;;;426    	ResceBuf.u8[1] =  DustBuf[1];
00001a  f89d0001          LDRB     r0,[sp,#1]
00001e  f88d0005          STRB     r0,[sp,#5]
;;;427    	ResceBuf.u8[2] =  DustBuf[0];
000022  f89d0000          LDRB     r0,[sp,#0]
000026  f88d0006          STRB     r0,[sp,#6]
;;;428    	Tmp = ResceBuf.u32/16777215.0;
00002a  9801              LDR      r0,[sp,#4]
00002c  f7fffffe          BL       __aeabi_ui2d
000030  4607              MOV      r7,r0
000032  f04f4260          MOV      r2,#0xe0000000
000036  4b0c              LDR      r3,|L9.104|
000038  f7fffffe          BL       __aeabi_ddiv
00003c  4605              MOV      r5,r0
00003e  f7fffffe          BL       __aeabi_d2f
000042  4604              MOV      r4,r0
;;;429    //	printf("result-K: %f\r\n",Tmp);		//转为小数点数值    
;;;430    	Tmp = Tmp*CS5463_VScale;		//V_Coff;     //计算电压值220V*250mv/(110mv/1.414)=704.8V
000044  4909              LDR      r1,|L9.108|
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       __aeabi_fmul
00004c  4604              MOV      r4,r0
;;;431    //    printf("电压: %f\r\n",Tmp);		//转为小数点数值   
;;;432        Tmp *= 10;						//放大十倍
00004e  4908              LDR      r1,|L9.112|
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       __aeabi_fmul
000056  4604              MOV      r4,r0
;;;433    	ResceBuf.u32 = (u32)Tmp;
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       __aeabi_f2uiz
00005e  9001              STR      r0,[sp,#4]
;;;434    //	memcpy(DustBuf,ResceBuf.u8,4);
;;;435    
;;;436    	return ResceBuf.u32;
000060  9801              LDR      r0,[sp,#4]
;;;437    }
000062  e8bd81fc          POP      {r2-r8,pc}
;;;438    
                          ENDP

000066  0000              DCW      0x0000
                  |L9.104|
                          DCD      0x416fffff
                  |L9.108|
                          DCD      0x44768000
                  |L9.112|
                          DCD      0x41200000

                          AREA ||i.CS546x_Init||, CODE, READONLY, ALIGN=2

                  CS546x_Init PROC
;;;498    */
;;;499    void CS546x_Init(unsigned char IsReadEEP)
000000  b510              PUSH     {r4,lr}
;;;500    {
000002  4604              MOV      r4,r0
;;;501    	CS546x_CLR_RST;
000004  2110              MOVS     r1,#0x10
000006  485c              LDR      r0,|L10.376|
000008  f7fffffe          BL       GPIO_ResetBits
;;;502    	delay_ms(10);
00000c  200a              MOVS     r0,#0xa
00000e  f7fffffe          BL       delay_ms
;;;503    	CS546x_SET_RST;
000012  2110              MOVS     r1,#0x10
000014  4858              LDR      r0,|L10.376|
000016  f7fffffe          BL       GPIO_SetBits
;;;504    
;;;505    	if(IsReadEEP)
00001a  2c00              CMP      r4,#0
00001c  d054              BEQ      |L10.200|
;;;506    	{			
;;;507    		CS546x_Buff.u8[0] = SYNC1;
00001e  20ff              MOVS     r0,#0xff
000020  4956              LDR      r1,|L10.380|
000022  7008              STRB     r0,[r1,#0]
;;;508    		CS546x_Buff.u8[1] = SYNC1;
000024  7048              STRB     r0,[r1,#1]
;;;509    		CS546x_Buff.u8[2] = SYNC0;
000026  20fe              MOVS     r0,#0xfe
000028  7088              STRB     r0,[r1,#2]
;;;510    		CS5463WriteReg(SYNC1,CS546x_Buff.u8); 			//同步串口
00002a  20ff              MOVS     r0,#0xff
00002c  f7fffffe          BL       CS5463WriteReg
;;;511    
;;;512    		CS546x_Buff.u8[0] = 0x00;
000030  2000              MOVS     r0,#0
000032  4952              LDR      r1,|L10.380|
000034  7008              STRB     r0,[r1,#0]
;;;513    		CS546x_Buff.u8[1] = 0x0f;
000036  200f              MOVS     r0,#0xf
000038  7048              STRB     r0,[r1,#1]
;;;514    		CS546x_Buff.u8[2] = 0xA0;
00003a  20a0              MOVS     r0,#0xa0
00003c  7088              STRB     r0,[r1,#2]
;;;515    		CS5463WriteReg(CycleCount | REG_WR,CS546x_Buff.u8); //配置每个计算周期的A/D转换数->4000
00003e  204a              MOVS     r0,#0x4a
000040  f7fffffe          BL       CS5463WriteReg
;;;516    
;;;517    		CS546x_Buff.u8[0] = 0x00;
000044  2000              MOVS     r0,#0
000046  494d              LDR      r1,|L10.380|
000048  7008              STRB     r0,[r1,#0]
;;;518    		CS546x_Buff.u8[1] = 0x00;
00004a  7048              STRB     r0,[r1,#1]
;;;519    		CS546x_Buff.u8[2] = 0x00;
00004c  7088              STRB     r0,[r1,#2]
;;;520    		CS5463WriteReg(Mode| REG_WR,CS546x_Buff.u8);	//开启高通滤波
00004e  2064              MOVS     r0,#0x64
000050  f7fffffe          BL       CS5463WriteReg
;;;521    
;;;522    		CS546x_Buff.u8[0] = 0x00;
000054  2000              MOVS     r0,#0
000056  4949              LDR      r1,|L10.380|
000058  7008              STRB     r0,[r1,#0]
;;;523    		CS546x_Buff.u8[1] = 0x00;
00005a  7048              STRB     r0,[r1,#1]
;;;524    		CS546x_Buff.u8[2] = 0x01;
00005c  2001              MOVS     r0,#1
00005e  7088              STRB     r0,[r1,#2]
;;;525    		CS5463WriteReg(Cfg | REG_WR,CS546x_Buff.u8);	//配置寄存器
000060  2040              MOVS     r0,#0x40
000062  f7fffffe          BL       CS5463WriteReg
;;;526    
;;;527    		CS546x_Buff.u8[0] = 0xFF;
000066  20ff              MOVS     r0,#0xff
000068  4944              LDR      r1,|L10.380|
00006a  7008              STRB     r0,[r1,#0]
;;;528    		CS546x_Buff.u8[1] = 0xFF;
00006c  7048              STRB     r0,[r1,#1]
;;;529    		CS546x_Buff.u8[2] = 0xFF;
00006e  7088              STRB     r0,[r1,#2]
;;;530    		CS5463WriteReg(Status | REG_WR,CS546x_Buff.u8);//clear state reg
000070  205e              MOVS     r0,#0x5e
000072  f7fffffe          BL       CS5463WriteReg
;;;531    
;;;532    		CS546x_Buff.u8[0] = 0x80;
000076  2080              MOVS     r0,#0x80
000078  4940              LDR      r1,|L10.380|
00007a  7008              STRB     r0,[r1,#0]
;;;533    		CS546x_Buff.u8[1] = 0x00;
00007c  2000              MOVS     r0,#0
00007e  7048              STRB     r0,[r1,#1]
;;;534    		CS546x_Buff.u8[2] = 0x00;
000080  7088              STRB     r0,[r1,#2]
;;;535    		CS5463WriteReg(MASK | REG_WR,CS546x_Buff.u8);	// allow int
000082  2074              MOVS     r0,#0x74
000084  f7fffffe          BL       CS5463WriteReg
;;;536    
;;;537    		CS546x_Buff.u8[0] = 0x00;
000088  2000              MOVS     r0,#0
00008a  493c              LDR      r1,|L10.380|
00008c  7008              STRB     r0,[r1,#0]
;;;538    		CS546x_Buff.u8[1] = 0x00;
00008e  7048              STRB     r0,[r1,#1]
;;;539    		CS546x_Buff.u8[2] = 0x00;
000090  7088              STRB     r0,[r1,#2]
;;;540    		CS5463WriteReg(Ctrl | REG_WR,CS546x_Buff.u8);	//初始化控制寄存器
000092  2078              MOVS     r0,#0x78
000094  f7fffffe          BL       CS5463WriteReg
;;;541    
;;;542    		CS546x_Buff.u8[0] = SYNC1;
000098  20ff              MOVS     r0,#0xff
00009a  4938              LDR      r1,|L10.380|
00009c  7008              STRB     r0,[r1,#0]
;;;543    		CS546x_Buff.u8[1] = SYNC1;
00009e  7048              STRB     r0,[r1,#1]
;;;544    		CS546x_Buff.u8[2] = SYNC0;
0000a0  20fe              MOVS     r0,#0xfe
0000a2  7088              STRB     r0,[r1,#2]
;;;545    		CS5463WriteReg(SYNC1,CS546x_Buff.u8); 			//同步串口
0000a4  20ff              MOVS     r0,#0xff
0000a6  f7fffffe          BL       CS5463WriteReg
;;;546    
;;;547    		CS546x_RESET_CS;
0000aa  2120              MOVS     r1,#0x20
0000ac  4832              LDR      r0,|L10.376|
0000ae  f7fffffe          BL       GPIO_ResetBits
;;;548    		delay_us(10);
0000b2  200a              MOVS     r0,#0xa
0000b4  f7fffffe          BL       delay_us
;;;549    		CS5463CMD(0xe8);  						//采用连续计算周期测量模式
0000b8  20e8              MOVS     r0,#0xe8
0000ba  f7fffffe          BL       CS5463CMD
;;;550    		CS546x_SET_CS;
0000be  2120              MOVS     r1,#0x20
0000c0  482d              LDR      r0,|L10.376|
0000c2  f7fffffe          BL       GPIO_SetBits
0000c6  e055              B        |L10.372|
                  |L10.200|
;;;551    	}
;;;552    	else
;;;553    	{			
;;;554    		CS546x_Buff.u8[0] = SYNC1;
0000c8  20ff              MOVS     r0,#0xff
0000ca  492c              LDR      r1,|L10.380|
0000cc  7008              STRB     r0,[r1,#0]
;;;555    		CS546x_Buff.u8[1] = SYNC1;
0000ce  7048              STRB     r0,[r1,#1]
;;;556    		CS546x_Buff.u8[2] = SYNC0;
0000d0  20fe              MOVS     r0,#0xfe
0000d2  7088              STRB     r0,[r1,#2]
;;;557    		CS5463WriteReg(SYNC1,CS546x_Buff.u8);  			//串口重新初始化序列  ->SYNC1命令
0000d4  20ff              MOVS     r0,#0xff
0000d6  f7fffffe          BL       CS5463WriteReg
;;;558    
;;;559    		CS546x_Buff.u8[0] = 0x00;
0000da  2000              MOVS     r0,#0
0000dc  4927              LDR      r1,|L10.380|
0000de  7008              STRB     r0,[r1,#0]
;;;560    		CS546x_Buff.u8[1] = 0x00;
0000e0  7048              STRB     r0,[r1,#1]
;;;561    		CS546x_Buff.u8[2] = 0x01;
0000e2  2001              MOVS     r0,#1
0000e4  7088              STRB     r0,[r1,#2]
;;;562    		CS5463WriteReg(Cfg | REG_WR,CS546x_Buff.u8);	//配置寄存器						
0000e6  2040              MOVS     r0,#0x40
0000e8  f7fffffe          BL       CS5463WriteReg
;;;563    
;;;564    		CS546x_Buff.u8[0] = 0x00;
0000ec  2000              MOVS     r0,#0
0000ee  4923              LDR      r1,|L10.380|
0000f0  7008              STRB     r0,[r1,#0]
;;;565    		CS546x_Buff.u8[1] = 0x00;
0000f2  7048              STRB     r0,[r1,#1]
;;;566    		CS546x_Buff.u8[2] = 0x60;                       //开启电流和电压高通滤波器
0000f4  2060              MOVS     r0,#0x60
0000f6  7088              STRB     r0,[r1,#2]
;;;567    		CS5463WriteReg(Mode | REG_WR,CS546x_Buff.u8);	//工作模式寄存器	
0000f8  2064              MOVS     r0,#0x64
0000fa  f7fffffe          BL       CS5463WriteReg
;;;568    		
;;;569    		CS546x_Buff.u8[0] = 0x00;
0000fe  2000              MOVS     r0,#0
000100  491e              LDR      r1,|L10.380|
000102  7008              STRB     r0,[r1,#0]
;;;570    		CS546x_Buff.u8[1] = 0x0f;
000104  200f              MOVS     r0,#0xf
000106  7048              STRB     r0,[r1,#1]
;;;571    		CS546x_Buff.u8[2] = 0xA0;
000108  20a0              MOVS     r0,#0xa0
00010a  7088              STRB     r0,[r1,#2]
;;;572    		CS5463WriteReg(CycleCount | REG_WR,CS546x_Buff.u8);	//配置每个计算周期的A/D转换数->4000
00010c  204a              MOVS     r0,#0x4a
00010e  f7fffffe          BL       CS5463WriteReg
;;;573    
;;;574    		CS546x_Buff.u8[0] = 0xFF;
000112  20ff              MOVS     r0,#0xff
000114  4919              LDR      r1,|L10.380|
000116  7008              STRB     r0,[r1,#0]
;;;575    		CS546x_Buff.u8[1] = 0xFF;
000118  7048              STRB     r0,[r1,#1]
;;;576    		CS546x_Buff.u8[2] = 0xFF;
00011a  7088              STRB     r0,[r1,#2]
;;;577    		CS5463WriteReg(Status | REG_WR,CS546x_Buff.u8);//clear state reg
00011c  205e              MOVS     r0,#0x5e
00011e  f7fffffe          BL       CS5463WriteReg
;;;578    
;;;579    		CS546x_Buff.u8[0] = 0x80;
000122  2080              MOVS     r0,#0x80
000124  4915              LDR      r1,|L10.380|
000126  7008              STRB     r0,[r1,#0]
;;;580    		CS546x_Buff.u8[1] = 0x00;
000128  2000              MOVS     r0,#0
00012a  7048              STRB     r0,[r1,#1]
;;;581    		CS546x_Buff.u8[2] = 0x80;
00012c  2080              MOVS     r0,#0x80
00012e  7088              STRB     r0,[r1,#2]
;;;582    		CS5463WriteReg(MASK | REG_WR,CS546x_Buff.u8);	// allow int
000130  2074              MOVS     r0,#0x74
000132  f7fffffe          BL       CS5463WriteReg
;;;583    
;;;584    		CS546x_Buff.u8[0] = 0x00;
000136  2000              MOVS     r0,#0
000138  4910              LDR      r1,|L10.380|
00013a  7008              STRB     r0,[r1,#0]
;;;585    		CS546x_Buff.u8[1] = 0x00;
00013c  7048              STRB     r0,[r1,#1]
;;;586    		CS546x_Buff.u8[2] = 0x00;
00013e  7088              STRB     r0,[r1,#2]
;;;587    		CS5463WriteReg(Ctrl | REG_WR,CS546x_Buff.u8);	//初始化控制寄存器		
000140  2078              MOVS     r0,#0x78
000142  f7fffffe          BL       CS5463WriteReg
;;;588    
;;;589    		CS546x_Buff.u8[0] = SYNC1;
000146  20ff              MOVS     r0,#0xff
000148  490c              LDR      r1,|L10.380|
00014a  7008              STRB     r0,[r1,#0]
;;;590    		CS546x_Buff.u8[1] = SYNC1;
00014c  7048              STRB     r0,[r1,#1]
;;;591    		CS546x_Buff.u8[2] = SYNC0;
00014e  20fe              MOVS     r0,#0xfe
000150  7088              STRB     r0,[r1,#2]
;;;592    		CS5463WriteReg(SYNC1,CS546x_Buff.u8); 			//同步串口
000152  20ff              MOVS     r0,#0xff
000154  f7fffffe          BL       CS5463WriteReg
;;;593    
;;;594    		CS546x_RESET_CS;
000158  2120              MOVS     r1,#0x20
00015a  4807              LDR      r0,|L10.376|
00015c  f7fffffe          BL       GPIO_ResetBits
;;;595    		delay_us(10);
000160  200a              MOVS     r0,#0xa
000162  f7fffffe          BL       delay_us
;;;596    		CS5463CMD(0xe8);  						//采用连续计算周期测量模式,开启测量
000166  20e8              MOVS     r0,#0xe8
000168  f7fffffe          BL       CS5463CMD
;;;597    		CS546x_SET_CS;
00016c  2120              MOVS     r1,#0x20
00016e  4802              LDR      r0,|L10.376|
000170  f7fffffe          BL       GPIO_SetBits
                  |L10.372|
;;;598    	}
;;;599    }
000174  bd10              POP      {r4,pc}
;;;600    extern uint16_t g_ShowDat[6];
                          ENDP

000176  0000              DCW      0x0000
                  |L10.376|
                          DCD      0x40010c00
                  |L10.380|
                          DCD      CS546x_Buff

                          AREA ||i.CS546x_Read_Byte||, CODE, READONLY, ALIGN=2

                  CS546x_Read_Byte PROC
;;;45     */
;;;46     u8 CS546x_Read_Byte(void)
000000  b570              PUSH     {r4-r6,lr}
;;;47     {	
;;;48     	u8 ReceiveDat,i;	
;;;49     	ReceiveDat = 0;
000002  2400              MOVS     r4,#0
;;;50     	CS546x_SET_SDI;
000004  2180              MOVS     r1,#0x80
000006  4811              LDR      r0,|L11.76|
000008  f7fffffe          BL       GPIO_SetBits
;;;51     //	delay_us(10);
;;;52     	for(i=0;i<7;i++) 
00000c  2500              MOVS     r5,#0
00000e  e018              B        |L11.66|
                  |L11.16|
;;;53     	{
;;;54     		CS546x_RESET_CLK;
000010  2120              MOVS     r1,#0x20
000012  480e              LDR      r0,|L11.76|
000014  f7fffffe          BL       GPIO_ResetBits
;;;55     		delay_us(5);
000018  2005              MOVS     r0,#5
00001a  f7fffffe          BL       delay_us
;;;56     		CS546x_SET_CLK;
00001e  2120              MOVS     r1,#0x20
000020  480a              LDR      r0,|L11.76|
000022  f7fffffe          BL       GPIO_SetBits
;;;57     		delay_us(5);
000026  2005              MOVS     r0,#5
000028  f7fffffe          BL       delay_us
;;;58     		if(CS546x_Get_SDO)	ReceiveDat |= 1;
00002c  2140              MOVS     r1,#0x40
00002e  4807              LDR      r0,|L11.76|
000030  f7fffffe          BL       GPIO_ReadInputDataBit
000034  b108              CBZ      r0,|L11.58|
000036  f0440401          ORR      r4,r4,#1
                  |L11.58|
;;;59     		ReceiveDat <<= 1;	
00003a  0660              LSLS     r0,r4,#25
00003c  0e04              LSRS     r4,r0,#24
00003e  1c68              ADDS     r0,r5,#1              ;52
000040  b2c5              UXTB     r5,r0                 ;52
                  |L11.66|
000042  2d07              CMP      r5,#7                 ;52
000044  dbe4              BLT      |L11.16|
;;;60     	}	
;;;61     	return ReceiveDat;
000046  4620              MOV      r0,r4
;;;62     }
000048  bd70              POP      {r4-r6,pc}
;;;63     /*
                          ENDP

00004a  0000              DCW      0x0000
                  |L11.76|
                          DCD      0x40010800

                          AREA ||i.CS546x_RedReg||, CODE, READONLY, ALIGN=2

                  CS546x_RedReg PROC
;;;97     */
;;;98     void CS546x_RedReg(u8 RegAddr,u8 *DustBuf)
000000  b570              PUSH     {r4-r6,lr}
;;;99     {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;100    	u8 i;	
;;;101    	CS546x_RESET_CS;
000006  2120              MOVS     r1,#0x20
000008  480b              LDR      r0,|L12.56|
00000a  f7fffffe          BL       GPIO_ResetBits
;;;102    	delay_us(10);
00000e  200a              MOVS     r0,#0xa
000010  f7fffffe          BL       delay_us
;;;103    	CS546x_Write_Byte(RegAddr);
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       CS546x_Write_Byte
;;;104    	for(i=0;i<3;i++)
00001a  2400              MOVS     r4,#0
00001c  e004              B        |L12.40|
                  |L12.30|
;;;105    	{
;;;106    		*(DustBuf+i) = CS546x_Read_Byte();
00001e  f7fffffe          BL       CS546x_Read_Byte
000022  5528              STRB     r0,[r5,r4]
000024  1c60              ADDS     r0,r4,#1              ;104
000026  b2c4              UXTB     r4,r0                 ;104
                  |L12.40|
000028  2c03              CMP      r4,#3                 ;104
00002a  dbf8              BLT      |L12.30|
;;;107    	}
;;;108    	CS546x_SET_CS;
00002c  2120              MOVS     r1,#0x20
00002e  4802              LDR      r0,|L12.56|
000030  f7fffffe          BL       GPIO_SetBits
;;;109    
;;;110    }
000034  bd70              POP      {r4-r6,pc}
;;;111    
                          ENDP

000036  0000              DCW      0x0000
                  |L12.56|
                          DCD      0x40010c00

                          AREA ||i.CS546x_ResetStaReg||, CODE, READONLY, ALIGN=2

                  CS546x_ResetStaReg PROC
;;;143    */
;;;144    void CS546x_ResetStaReg()
000000  b510              PUSH     {r4,lr}
;;;145    {
;;;146    	CS546x_Buff.u8[0] = 0xFF;
000002  20ff              MOVS     r0,#0xff
000004  4903              LDR      r1,|L13.20|
000006  7008              STRB     r0,[r1,#0]
;;;147    	CS546x_Buff.u8[1] = 0xFF;
000008  7048              STRB     r0,[r1,#1]
;;;148    	CS546x_Buff.u8[2] = 0xFF;
00000a  7088              STRB     r0,[r1,#2]
;;;149    
;;;150    	CS546x_WriteReg(Status | REG_WR,CS546x_Buff.u8);
00000c  205e              MOVS     r0,#0x5e
00000e  f7fffffe          BL       CS546x_WriteReg
;;;151    }
000012  bd10              POP      {r4,pc}
;;;152    
                          ENDP

                  |L13.20|
                          DCD      CS546x_Buff

                          AREA ||i.CS546x_WriteReg||, CODE, READONLY, ALIGN=2

                  CS546x_WriteReg PROC
;;;120    */
;;;121    void CS546x_WriteReg(u8 RegAddr,u8 *DustBuf)
000000  b570              PUSH     {r4-r6,lr}
;;;122    {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;123    	u8 i;	
;;;124    	CS546x_RESET_CS;
000006  2120              MOVS     r1,#0x20
000008  480b              LDR      r0,|L14.56|
00000a  f7fffffe          BL       GPIO_ResetBits
;;;125    	delay_us(10);
00000e  200a              MOVS     r0,#0xa
000010  f7fffffe          BL       delay_us
;;;126    	CS546x_Write_Byte(RegAddr);
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       CS546x_Write_Byte
;;;127    	for(i=0;i<3;i++)
00001a  2400              MOVS     r4,#0
00001c  e004              B        |L14.40|
                  |L14.30|
;;;128    	{
;;;129    		CS546x_Write_Byte(*(DustBuf+i));
00001e  5d28              LDRB     r0,[r5,r4]
000020  f7fffffe          BL       CS546x_Write_Byte
000024  1c60              ADDS     r0,r4,#1              ;127
000026  b2c4              UXTB     r4,r0                 ;127
                  |L14.40|
000028  2c03              CMP      r4,#3                 ;127
00002a  dbf8              BLT      |L14.30|
;;;130    	}
;;;131    	CS546x_SET_CS;
00002c  2120              MOVS     r1,#0x20
00002e  4802              LDR      r0,|L14.56|
000030  f7fffffe          BL       GPIO_SetBits
;;;132    
;;;133    }
000034  bd70              POP      {r4-r6,pc}
;;;134    
                          ENDP

000036  0000              DCW      0x0000
                  |L14.56|
                          DCD      0x40010c00

                          AREA ||i.CS546x_Write_Byte||, CODE, READONLY, ALIGN=2

                  CS546x_Write_Byte PROC
;;;71     */
;;;72     void CS546x_Write_Byte(u8 WrDat)
000000  b570              PUSH     {r4-r6,lr}
;;;73     {
000002  4604              MOV      r4,r0
;;;74     	u8  tmp_8u,i;
;;;75     	tmp_8u = WrDat;
000004  4625              MOV      r5,r4
;;;76     	for(i=0;i<8;i++)
000006  2600              MOVS     r6,#0
000008  e01d              B        |L15.70|
                  |L15.10|
;;;77     	{
;;;78     		delay_us(10);
00000a  200a              MOVS     r0,#0xa
00000c  f7fffffe          BL       delay_us
;;;79     		CS546x_RESET_CLK;
000010  2120              MOVS     r1,#0x20
000012  4812              LDR      r0,|L15.92|
000014  f7fffffe          BL       GPIO_ResetBits
;;;80     		if((tmp_8u&0x80)==0)	CS546x_RESET_SDI;
000018  f0050080          AND      r0,r5,#0x80
00001c  b920              CBNZ     r0,|L15.40|
00001e  2180              MOVS     r1,#0x80
000020  480e              LDR      r0,|L15.92|
000022  f7fffffe          BL       GPIO_ResetBits
000026  e003              B        |L15.48|
                  |L15.40|
;;;81     		else					CS546x_SET_SDI;
000028  2180              MOVS     r1,#0x80
00002a  480c              LDR      r0,|L15.92|
00002c  f7fffffe          BL       GPIO_SetBits
                  |L15.48|
;;;82     		delay_us(2);
000030  2002              MOVS     r0,#2
000032  f7fffffe          BL       delay_us
;;;83     		tmp_8u <<= 1;
000036  0668              LSLS     r0,r5,#25
000038  0e05              LSRS     r5,r0,#24
;;;84     		CS546x_SET_CLK;
00003a  2120              MOVS     r1,#0x20
00003c  4807              LDR      r0,|L15.92|
00003e  f7fffffe          BL       GPIO_SetBits
000042  1c70              ADDS     r0,r6,#1              ;76
000044  b2c6              UXTB     r6,r0                 ;76
                  |L15.70|
000046  2e08              CMP      r6,#8                 ;76
000048  dbdf              BLT      |L15.10|
;;;85     	}
;;;86     	delay_us(10);
00004a  200a              MOVS     r0,#0xa
00004c  f7fffffe          BL       delay_us
;;;87     	CS546x_RESET_CLK;
000050  2120              MOVS     r1,#0x20
000052  4802              LDR      r0,|L15.92|
000054  f7fffffe          BL       GPIO_ResetBits
;;;88     }
000058  bd70              POP      {r4-r6,pc}
;;;89     /*
                          ENDP

00005a  0000              DCW      0x0000
                  |L15.92|
                          DCD      0x40010800

                          AREA ||i.Get_InputValue||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  Get_InputValue PROC
;;;602    //Channal 检测通道
;;;603    void Get_InputValue(void)
000000  b570              PUSH     {r4-r6,lr}
;;;604    {
;;;605    	static UN32 Voltage_VA,Voltage_IA;
;;;606    	u8 CS546x_Sta;
;;;607        static u8 Channal=Channal_A;
;;;608        if(Channal==Channal_A)
000002  4854              LDR      r0,|L16.340|
000004  7800              LDRB     r0,[r0,#0]  ; Channal
000006  2801              CMP      r0,#1
000008  d131              BNE      |L16.110|
;;;609        {
;;;610            SetInput_CSCD4051Switch(IV_A);	//A相电压通道选择
00000a  2002              MOVS     r0,#2
00000c  f7fffffe          BL       SetInput_CSCD4051Switch
;;;611            SetInput_IICD4051Switch(II_A);	//A相电流通道选择
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       SetInput_IICD4051Switch
;;;612            delay_us(30);					//必要延时
000016  201e              MOVS     r0,#0x1e
000018  f7fffffe          BL       delay_us
;;;613            CS546x_Sta	= CS5463_GetStaReg_Val();			//检测中断产生的原因
00001c  f7fffffe          BL       CS5463_GetStaReg_Val
000020  4604              MOV      r4,r0
;;;614            if(0x01==(CS546x_Sta&0x01))  
000022  f0040001          AND      r0,r4,#1
000026  2800              CMP      r0,#0
000028  d020              BEQ      |L16.108|
;;;615            {
;;;616                Voltage_VA.u32 = CS546x_Get_Vrms(); 
00002a  f7fffffe          BL       CS546x_Get_Vrms
00002e  494a              LDR      r1,|L16.344|
000030  6008              STR      r0,[r1,#0]  ; Voltage_VA
;;;617                Voltage_IA.u32 = CS546x_Get_Irms(); 	//读有效电流值
000032  f7fffffe          BL       CS546x_Get_Irms
000036  4949              LDR      r1,|L16.348|
000038  6008              STR      r0,[r1,#0]  ; Voltage_IA
;;;618                printf("A V:%3d.%dV , I:%3dmA.\r\n",Voltage_VA.u16[0]/10,Voltage_VA.u16[0]%10,Voltage_IA.u32);
00003a  4847              LDR      r0,|L16.344|
00003c  8800              LDRH     r0,[r0,#0]  ; Voltage_VA
00003e  210a              MOVS     r1,#0xa
000040  fb90f2f1          SDIV     r2,r0,r1
000044  fb010512          MLS      r5,r1,r2,r0
000048  4843              LDR      r0,|L16.344|
00004a  8800              LDRH     r0,[r0,#0]  ; Voltage_VA
00004c  fb90f6f1          SDIV     r6,r0,r1
000050  4842              LDR      r0,|L16.348|
000052  462a              MOV      r2,r5
000054  4631              MOV      r1,r6
000056  6803              LDR      r3,[r0,#0]  ; Voltage_IA
000058  a041              ADR      r0,|L16.352|
00005a  f7fffffe          BL       __2printf
;;;619                CS546x_ResetStaReg();
00005e  f7fffffe          BL       CS546x_ResetStaReg
;;;620                Channal++;
000062  483c              LDR      r0,|L16.340|
000064  7800              LDRB     r0,[r0,#0]  ; Channal
000066  1c40              ADDS     r0,r0,#1
000068  493a              LDR      r1,|L16.340|
00006a  7008              STRB     r0,[r1,#0]
                  |L16.108|
00006c  e067              B        |L16.318|
                  |L16.110|
;;;621            }
;;;622        }
;;;623        else if(Channal==Channal_B)
00006e  4839              LDR      r0,|L16.340|
000070  7800              LDRB     r0,[r0,#0]  ; Channal
000072  2802              CMP      r0,#2
000074  d131              BNE      |L16.218|
;;;624        {
;;;625            SetInput_CSCD4051Switch(IV_B);	//B相电压通道选择
000076  2001              MOVS     r0,#1
000078  f7fffffe          BL       SetInput_CSCD4051Switch
;;;626            SetInput_IICD4051Switch(II_B);	//B相电流通道选择
00007c  2001              MOVS     r0,#1
00007e  f7fffffe          BL       SetInput_IICD4051Switch
;;;627            delay_us(30);					//必要延时
000082  201e              MOVS     r0,#0x1e
000084  f7fffffe          BL       delay_us
;;;628            CS546x_Sta	= CS5463_GetStaReg_Val();			//检测中断产生的原因
000088  f7fffffe          BL       CS5463_GetStaReg_Val
00008c  4604              MOV      r4,r0
;;;629            if(0x01==(CS546x_Sta&0x01))  
00008e  f0040001          AND      r0,r4,#1
000092  2800              CMP      r0,#0
000094  d053              BEQ      |L16.318|
;;;630            {
;;;631                Voltage_VA.u32 = CS546x_Get_Vrms(); 
000096  f7fffffe          BL       CS546x_Get_Vrms
00009a  492f              LDR      r1,|L16.344|
00009c  6008              STR      r0,[r1,#0]  ; Voltage_VA
;;;632                Voltage_IA.u32 = CS546x_Get_Irms(); 	//读有效电流值
00009e  f7fffffe          BL       CS546x_Get_Irms
0000a2  492e              LDR      r1,|L16.348|
0000a4  6008              STR      r0,[r1,#0]  ; Voltage_IA
;;;633                printf("B V:%3d.%dV , I:%3dmA.\r\n",Voltage_VA.u16[0]/10,Voltage_VA.u16[0]%10,Voltage_IA.u32);
0000a6  482c              LDR      r0,|L16.344|
0000a8  8800              LDRH     r0,[r0,#0]  ; Voltage_VA
0000aa  210a              MOVS     r1,#0xa
0000ac  fb90f2f1          SDIV     r2,r0,r1
0000b0  fb010512          MLS      r5,r1,r2,r0
0000b4  4828              LDR      r0,|L16.344|
0000b6  8800              LDRH     r0,[r0,#0]  ; Voltage_VA
0000b8  fb90f6f1          SDIV     r6,r0,r1
0000bc  4827              LDR      r0,|L16.348|
0000be  462a              MOV      r2,r5
0000c0  4631              MOV      r1,r6
0000c2  6803              LDR      r3,[r0,#0]  ; Voltage_IA
0000c4  a02d              ADR      r0,|L16.380|
0000c6  f7fffffe          BL       __2printf
;;;634                CS546x_ResetStaReg();
0000ca  f7fffffe          BL       CS546x_ResetStaReg
;;;635                Channal++;
0000ce  4821              LDR      r0,|L16.340|
0000d0  7800              LDRB     r0,[r0,#0]  ; Channal
0000d2  1c40              ADDS     r0,r0,#1
0000d4  491f              LDR      r1,|L16.340|
0000d6  7008              STRB     r0,[r1,#0]
0000d8  e031              B        |L16.318|
                  |L16.218|
;;;636            }
;;;637        }
;;;638        else if(Channal==Channal_C)
0000da  481e              LDR      r0,|L16.340|
0000dc  7800              LDRB     r0,[r0,#0]  ; Channal
0000de  2803              CMP      r0,#3
0000e0  d12d              BNE      |L16.318|
;;;639        {
;;;640            SetInput_CSCD4051Switch(IV_C);	//C相电压通道选择
0000e2  2000              MOVS     r0,#0
0000e4  f7fffffe          BL       SetInput_CSCD4051Switch
;;;641            SetInput_IICD4051Switch(II_C);	//C相电流通道选择
0000e8  2002              MOVS     r0,#2
0000ea  f7fffffe          BL       SetInput_IICD4051Switch
;;;642            delay_us(30);					//必要延时
0000ee  201e              MOVS     r0,#0x1e
0000f0  f7fffffe          BL       delay_us
;;;643            CS546x_Sta	= CS5463_GetStaReg_Val();			//检测中断产生的原因
0000f4  f7fffffe          BL       CS5463_GetStaReg_Val
0000f8  4604              MOV      r4,r0
;;;644            if(0x01==(CS546x_Sta&0x01))  
0000fa  f0040001          AND      r0,r4,#1
0000fe  b1f0              CBZ      r0,|L16.318|
;;;645            {
;;;646                Voltage_VA.u32 = CS546x_Get_Vrms(); 
000100  f7fffffe          BL       CS546x_Get_Vrms
000104  4914              LDR      r1,|L16.344|
000106  6008              STR      r0,[r1,#0]  ; Voltage_VA
;;;647                Voltage_IA.u32 = CS546x_Get_Irms(); 	//读有效电流值
000108  f7fffffe          BL       CS546x_Get_Irms
00010c  4913              LDR      r1,|L16.348|
00010e  6008              STR      r0,[r1,#0]  ; Voltage_IA
;;;648                printf("C V:%3d.%dV , I:%3dmA.\r\n",Voltage_VA.u16[0]/10,Voltage_VA.u16[0]%10,Voltage_IA.u32);
000110  4811              LDR      r0,|L16.344|
000112  8800              LDRH     r0,[r0,#0]  ; Voltage_VA
000114  210a              MOVS     r1,#0xa
000116  fb90f2f1          SDIV     r2,r0,r1
00011a  fb010512          MLS      r5,r1,r2,r0
00011e  480e              LDR      r0,|L16.344|
000120  8800              LDRH     r0,[r0,#0]  ; Voltage_VA
000122  fb90f6f1          SDIV     r6,r0,r1
000126  480d              LDR      r0,|L16.348|
000128  462a              MOV      r2,r5
00012a  4631              MOV      r1,r6
00012c  6803              LDR      r3,[r0,#0]  ; Voltage_IA
00012e  a01a              ADR      r0,|L16.408|
000130  f7fffffe          BL       __2printf
;;;649                CS546x_ResetStaReg();
000134  f7fffffe          BL       CS546x_ResetStaReg
;;;650                Channal=Channal_A;
000138  2001              MOVS     r0,#1
00013a  4906              LDR      r1,|L16.340|
00013c  7008              STRB     r0,[r1,#0]
                  |L16.318|
;;;651            }
;;;652        }
;;;653        g_ShowDat[0] = (uint16_t)Voltage_VA.u16[0]/10;    //电压
00013e  4806              LDR      r0,|L16.344|
000140  8800              LDRH     r0,[r0,#0]  ; Voltage_VA
000142  210a              MOVS     r1,#0xa
000144  fb90f0f1          SDIV     r0,r0,r1
000148  491a              LDR      r1,|L16.436|
00014a  8008              STRH     r0,[r1,#0]
;;;654        g_ShowDat[1] = (uint16_t)Voltage_IA.u32;          //电压
00014c  4803              LDR      r0,|L16.348|
00014e  8800              LDRH     r0,[r0,#0]  ; Voltage_IA
000150  8048              STRH     r0,[r1,#2]
;;;655    }
000152  bd70              POP      {r4-r6,pc}
;;;656    
                          ENDP

                  |L16.340|
                          DCD      Channal
                  |L16.344|
                          DCD      Voltage_VA
                  |L16.348|
                          DCD      Voltage_IA
                  |L16.352|
000160  4120563a          DCB      "A V:%3d.%dV , I:%3dmA.\r\n",0
000164  2533642e
000168  25645620
00016c  2c20493a
000170  2533646d
000174  412e0d0a
000178  00      
000179  00                DCB      0
00017a  00                DCB      0
00017b  00                DCB      0
                  |L16.380|
00017c  4220563a          DCB      "B V:%3d.%dV , I:%3dmA.\r\n",0
000180  2533642e
000184  25645620
000188  2c20493a
00018c  2533646d
000190  412e0d0a
000194  00      
000195  00                DCB      0
000196  00                DCB      0
000197  00                DCB      0
                  |L16.408|
000198  4320563a          DCB      "C V:%3d.%dV , I:%3dmA.\r\n",0
00019c  2533642e
0001a0  25645620
0001a4  2c20493a
0001a8  2533646d
0001ac  412e0d0a
0001b0  00      
0001b1  00                DCB      0
0001b2  00                DCB      0
0001b3  00                DCB      0
                  |L16.436|
                          DCD      g_ShowDat

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  Board_Phase
                          %        12

                          AREA ||.data||, DATA, ALIGN=2

                  CS546x_Buff
                          DCD      0x00000000
                  RX_Buff
                          DCD      0x00000000
                  ||sta||
000008  00000000          DCB      0x00,0x00,0x00,0x00
                  Voltage_VA
                          DCD      0x00000000
                  Voltage_IA
                          DCD      0x00000000
                  Channal
000014  01                DCB      0x01
