; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_uart_fifo.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_uart_fifo.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User -I"C:\Users\xuan5\Desktop\JOSONG-XS03 V3.0\Project\MDK-ARM(uV4)\RTE" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=521 -D_RTE_ -DSTM32F10X_MD -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=.\flash\obj\bsp_uart_fifo.crf ..\..\User\bsp\bsp_uart_fifo.c]
                          THUMB

                          AREA ||i.ADD_RS485||, CODE, READONLY, ALIGN=1

                  ADD_RS485 PROC
;;;105    
;;;106    uint8_t ADD_RS485(void)
000000  b510              PUSH     {r4,lr}
;;;107    {
;;;108    	uint8_t Add=0;
000002  2400              MOVS     r4,#0
;;;109    	if( RS485ADD1() == 1 )	Add |= (1<<0);	else Add &= ~(1<<0);
000004  f7fffffe          BL       RS485ADD1
000008  2801              CMP      r0,#1
00000a  d102              BNE      |L1.18|
00000c  f0440401          ORR      r4,r4,#1
000010  e001              B        |L1.22|
                  |L1.18|
000012  f0240401          BIC      r4,r4,#1
                  |L1.22|
;;;110    	if( RS485ADD2() == 1 )	Add |= (1<<1);	else Add &= ~(1<<1);
000016  f7fffffe          BL       RS485ADD2
00001a  2801              CMP      r0,#1
00001c  d102              BNE      |L1.36|
00001e  f0440402          ORR      r4,r4,#2
000022  e001              B        |L1.40|
                  |L1.36|
000024  f0240402          BIC      r4,r4,#2
                  |L1.40|
;;;111    	if( RS485ADD3() == 1 )	Add |= (1<<2);	else Add &= ~(1<<2);
000028  f7fffffe          BL       RS485ADD3
00002c  2801              CMP      r0,#1
00002e  d102              BNE      |L1.54|
000030  f0440404          ORR      r4,r4,#4
000034  e001              B        |L1.58|
                  |L1.54|
000036  f0240404          BIC      r4,r4,#4
                  |L1.58|
;;;112    	if( RS485ADD4() == 1 )	Add |= (1<<3);	else Add &= ~(1<<3);
00003a  f7fffffe          BL       RS485ADD4
00003e  2801              CMP      r0,#1
000040  d102              BNE      |L1.72|
000042  f0440408          ORR      r4,r4,#8
000046  e001              B        |L1.76|
                  |L1.72|
000048  f0240408          BIC      r4,r4,#8
                  |L1.76|
;;;113    	if( RS485ADD5() == 1 )	Add |= (1<<4);	else Add &= ~(1<<4);
00004c  f7fffffe          BL       RS485ADD5
000050  2801              CMP      r0,#1
000052  d102              BNE      |L1.90|
000054  f0440410          ORR      r4,r4,#0x10
000058  e001              B        |L1.94|
                  |L1.90|
00005a  f0240410          BIC      r4,r4,#0x10
                  |L1.94|
;;;114    	if( RS485ADD6() == 1 )	Add |= (1<<5);	else Add &= ~(1<<5);
00005e  f7fffffe          BL       RS485ADD6
000062  2801              CMP      r0,#1
000064  d102              BNE      |L1.108|
000066  f0440420          ORR      r4,r4,#0x20
00006a  e001              B        |L1.112|
                  |L1.108|
00006c  f0240420          BIC      r4,r4,#0x20
                  |L1.112|
;;;115    	if( RS485ADD7() == 1 )	Add |= (1<<6);	else Add &= ~(1<<6);
000070  f7fffffe          BL       RS485ADD7
000074  2801              CMP      r0,#1
000076  d102              BNE      |L1.126|
000078  f0440440          ORR      r4,r4,#0x40
00007c  e001              B        |L1.130|
                  |L1.126|
00007e  f0240440          BIC      r4,r4,#0x40
                  |L1.130|
;;;116    	if( RS485ADD8() == 1 )	Add |= (1<<7);	else Add &= ~(1<<7);
000082  f7fffffe          BL       RS485ADD8
000086  2801              CMP      r0,#1
000088  d102              BNE      |L1.144|
00008a  f0440480          ORR      r4,r4,#0x80
00008e  e001              B        |L1.148|
                  |L1.144|
000090  f0240480          BIC      r4,r4,#0x80
                  |L1.148|
;;;117    	return Add;
000094  4620              MOV      r0,r4
;;;118    }
000096  bd10              POP      {r4,pc}
;;;119    
                          ENDP


                          AREA ||i.ComToUart||, CODE, READONLY, ALIGN=2

                  ComToUart PROC
;;;146    */
;;;147    UART_T *ComToUart(COM_PORT_E _ucPort)
000000  4601              MOV      r1,r0
;;;148    {
;;;149    	if (_ucPort == COM1)
000002  b909              CBNZ     r1,|L2.8|
;;;150    	{
;;;151    		#if UART1_FIFO_EN == 1
;;;152    			return &g_tUart1;
000004  4809              LDR      r0,|L2.44|
                  |L2.6|
;;;153    		#else
;;;154    			return 0;
;;;155    		#endif
;;;156    	}
;;;157    	else if (_ucPort == COM2)
;;;158    	{
;;;159    		#if UART2_FIFO_EN == 1
;;;160    			return &g_tUart2;
;;;161    		#else
;;;162    			return 0;
;;;163    		#endif
;;;164    	}
;;;165    	else if (_ucPort == COM3)
;;;166    	{
;;;167    		#if UART3_FIFO_EN == 1
;;;168    			return &g_tUart3;
;;;169    		#else
;;;170    			return 0;
;;;171    		#endif
;;;172    	}
;;;173    	else if (_ucPort == COM4)
;;;174    	{
;;;175    		#if UART4_FIFO_EN == 1
;;;176    			return &g_tUart4;
;;;177    		#else
;;;178    			return 0;
;;;179    		#endif
;;;180    	}
;;;181    	else if (_ucPort == COM5)
;;;182    	{
;;;183    		#if UART5_FIFO_EN == 1
;;;184    			return &g_tUart5;
;;;185    		#else
;;;186    			return 0;
;;;187    		#endif
;;;188    	}
;;;189    	else
;;;190    	{
;;;191    		/* 不做任何处理 */
;;;192    		return 0;
;;;193    	}
;;;194    }
000006  4770              BX       lr
                  |L2.8|
000008  2901              CMP      r1,#1                 ;157
00000a  d101              BNE      |L2.16|
00000c  2000              MOVS     r0,#0                 ;162
00000e  e7fa              B        |L2.6|
                  |L2.16|
000010  2902              CMP      r1,#2                 ;165
000012  d101              BNE      |L2.24|
000014  4806              LDR      r0,|L2.48|
000016  e7f6              B        |L2.6|
                  |L2.24|
000018  2903              CMP      r1,#3                 ;173
00001a  d101              BNE      |L2.32|
00001c  2000              MOVS     r0,#0                 ;178
00001e  e7f2              B        |L2.6|
                  |L2.32|
000020  2904              CMP      r1,#4                 ;181
000022  d101              BNE      |L2.40|
000024  2000              MOVS     r0,#0                 ;186
000026  e7ee              B        |L2.6|
                  |L2.40|
000028  2000              MOVS     r0,#0                 ;192
00002a  e7ec              B        |L2.6|
;;;195    
                          ENDP

                  |L2.44|
                          DCD      g_tUart1
                  |L2.48|
                          DCD      g_tUart3

                          AREA ||i.ConfigUartNVIC||, CODE, READONLY, ALIGN=1

                  ConfigUartNVIC PROC
;;;938    */
;;;939    static void ConfigUartNVIC(void)
000000  b508              PUSH     {r3,lr}
;;;940    {
;;;941    	NVIC_InitTypeDef NVIC_InitStructure;
;;;942    
;;;943    	/* Configure the NVIC Preemption Priority Bits */
;;;944    	/*	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);  --- 在 bsp.c 中 bsp_Init() 中配置中断优先级组 */
;;;945    
;;;946    #if UART1_FIFO_EN == 1
;;;947    	/* 使能串口1中断 */
;;;948    	NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
000002  2025              MOVS     r0,#0x25
000004  f88d0000          STRB     r0,[sp,#0]
;;;949    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000008  2000              MOVS     r0,#0
00000a  f88d0002          STRB     r0,[sp,#2]
;;;950    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00000e  2001              MOVS     r0,#1
000010  f88d0003          STRB     r0,[sp,#3]
;;;951    	NVIC_Init(&NVIC_InitStructure);
000014  4668              MOV      r0,sp
000016  f7fffffe          BL       NVIC_Init
;;;952    #endif
;;;953    
;;;954    #if UART2_FIFO_EN == 1
;;;955    	/* 使能串口2中断 */
;;;956    	NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;
;;;957    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
;;;958    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;959    	NVIC_Init(&NVIC_InitStructure);
;;;960    #endif
;;;961    
;;;962    #if UART3_FIFO_EN == 1
;;;963    	/* 使能串口3中断t */
;;;964    	NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQn;
00001a  2027              MOVS     r0,#0x27
00001c  f88d0000          STRB     r0,[sp,#0]
;;;965    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;
000020  2002              MOVS     r0,#2
000022  f88d0002          STRB     r0,[sp,#2]
;;;966    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000026  2001              MOVS     r0,#1
000028  f88d0003          STRB     r0,[sp,#3]
;;;967    	NVIC_Init(&NVIC_InitStructure);
00002c  4668              MOV      r0,sp
00002e  f7fffffe          BL       NVIC_Init
;;;968    #endif
;;;969    
;;;970    #if UART4_FIFO_EN == 1
;;;971    	/* 使能串口4中断t */
;;;972    	NVIC_InitStructure.NVIC_IRQChannel = UART4_IRQn;
;;;973    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;
;;;974    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;975    	NVIC_Init(&NVIC_InitStructure);
;;;976    #endif
;;;977    
;;;978    #if UART5_FIFO_EN == 1
;;;979    	/* 使能串口5中断t */
;;;980    	NVIC_InitStructure.NVIC_IRQChannel = UART5_IRQn;
;;;981    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 4;
;;;982    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;983    	NVIC_Init(&NVIC_InitStructure);
;;;984    #endif
;;;985    
;;;986    #if UART6_FIFO_EN == 1
;;;987    	/* 使能串口6中断t */
;;;988    	NVIC_InitStructure.NVIC_IRQChannel = USART6_IRQn;
;;;989    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 5;
;;;990    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;991    	NVIC_Init(&NVIC_InitStructure);
;;;992    #endif
;;;993    }
000032  bd08              POP      {r3,pc}
;;;994    
                          ENDP


                          AREA ||i.InitHardUart||, CODE, READONLY, ALIGN=2

                  InitHardUart PROC
;;;708    */
;;;709    static void InitHardUart(void)
000000  b500              PUSH     {lr}
;;;710    {
000002  b085              SUB      sp,sp,#0x14
;;;711    	GPIO_InitTypeDef GPIO_InitStructure;
;;;712    	USART_InitTypeDef USART_InitStructure;
;;;713    
;;;714    #if UART1_FIFO_EN == 1		/* 串口1 TX = PA9   RX = PA10 或 TX = PB6   RX = PB7*/
;;;715    
;;;716    	/* 第1步：打开GPIO和USART部件的时钟 */
;;;717    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);
000004  2101              MOVS     r1,#1
000006  2005              MOVS     r0,#5
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;718    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  0388              LSLS     r0,r1,#14
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;719    
;;;720    	/* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;721    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
000014  f44f7000          MOV      r0,#0x200
000018  f8ad0010          STRH     r0,[sp,#0x10]
;;;722    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
00001c  2018              MOVS     r0,#0x18
00001e  f88d0013          STRB     r0,[sp,#0x13]
;;;723    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000022  2003              MOVS     r0,#3
000024  f88d0012          STRB     r0,[sp,#0x12]
;;;724    	GPIO_Init(GPIOA, &GPIO_InitStructure);
000028  a904              ADD      r1,sp,#0x10
00002a  483b              LDR      r0,|L4.280|
00002c  f7fffffe          BL       GPIO_Init
;;;725    
;;;726    	/* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;727    		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;728    		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;729    	*/
;;;730    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
000030  f44f6080          MOV      r0,#0x400
000034  f8ad0010          STRH     r0,[sp,#0x10]
;;;731    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000038  2004              MOVS     r0,#4
00003a  f88d0013          STRB     r0,[sp,#0x13]
;;;732    	GPIO_Init(GPIOA, &GPIO_InitStructure);
00003e  a904              ADD      r1,sp,#0x10
000040  4835              LDR      r0,|L4.280|
000042  f7fffffe          BL       GPIO_Init
;;;733    	
;;;734    	/* 第4步： 配置串口硬件参数 */
;;;735    	USART_InitStructure.USART_BaudRate = UART1_BAUD;	/* 波特率 */
000046  f44f30e1          MOV      r0,#0x1c200
00004a  9000              STR      r0,[sp,#0]
;;;736    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
00004c  2000              MOVS     r0,#0
00004e  f8ad0004          STRH     r0,[sp,#4]
;;;737    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
000052  f8ad0006          STRH     r0,[sp,#6]
;;;738    	USART_InitStructure.USART_Parity = USART_Parity_No ;
000056  f8ad0008          STRH     r0,[sp,#8]
;;;739    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
00005a  f8ad000c          STRH     r0,[sp,#0xc]
;;;740    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00005e  200c              MOVS     r0,#0xc
000060  f8ad000a          STRH     r0,[sp,#0xa]
;;;741    	USART_Init(USART1, &USART_InitStructure);
000064  4669              MOV      r1,sp
000066  482d              LDR      r0,|L4.284|
000068  f7fffffe          BL       USART_Init
;;;742    
;;;743    	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
00006c  2201              MOVS     r2,#1
00006e  f2405125          MOV      r1,#0x525
000072  482a              LDR      r0,|L4.284|
000074  f7fffffe          BL       USART_ITConfig
;;;744    	/*
;;;745    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;746    		注意: 不要在此处打开发送中断
;;;747    		发送中断使能在SendUart()函数打开
;;;748    	*/
;;;749    	USART_Cmd(USART1, ENABLE);		/* 使能串口 */
000078  2101              MOVS     r1,#1
00007a  4828              LDR      r0,|L4.284|
00007c  f7fffffe          BL       USART_Cmd
;;;750    
;;;751    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;752    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;753    	USART_ClearFlag(USART1, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
000080  2140              MOVS     r1,#0x40
000082  4826              LDR      r0,|L4.284|
000084  f7fffffe          BL       USART_ClearFlag
;;;754    #endif
;;;755    
;;;756    #if UART2_FIFO_EN == 1		/* 串口2 TX = PA2， RX = PA3  */
;;;757    	/* 第1步：打开GPIO和USART部件的时钟 */
;;;758    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);
;;;759    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
;;;760    
;;;761    	/* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;762    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
;;;763    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
;;;764    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;765    	GPIO_Init(GPIOA, &GPIO_InitStructure);
;;;766    
;;;767    	/* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;768    		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;769    		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;770    	*/
;;;771    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
;;;772    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
;;;773    	GPIO_Init(GPIOA, &GPIO_InitStructure);
;;;774    	/*  第3步已经做了，因此这步可以不做
;;;775    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;776    	*/
;;;777    	GPIO_Init(GPIOA, &GPIO_InitStructure);
;;;778    
;;;779    	/* 第4步： 配置串口硬件参数 */
;;;780    	USART_InitStructure.USART_BaudRate = UART2_BAUD;	/* 波特率 */
;;;781    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
;;;782    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;783    	USART_InitStructure.USART_Parity = USART_Parity_No ;
;;;784    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;785    	USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;		/* 仅选择接收模式 */
;;;786    	USART_Init(USART2, &USART_InitStructure);
;;;787    
;;;788    	USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
;;;789    	/*
;;;790    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;791    		注意: 不要在此处打开发送中断
;;;792    		发送中断使能在SendUart()函数打开
;;;793    	*/
;;;794    	USART_Cmd(USART2, ENABLE);		/* 使能串口 */
;;;795    
;;;796    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;797    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;798    	USART_ClearFlag(USART2, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
;;;799    #endif
;;;800    
;;;801    #if UART3_FIFO_EN == 1			/* 串口3 TX = PB10   RX = PB11 */
;;;802    
;;;803    	/* 第1步： 开启GPIO和UART时钟 */
;;;804    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_AFIO, ENABLE);
000088  2101              MOVS     r1,#1
00008a  2009              MOVS     r0,#9
00008c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;805    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
000090  2101              MOVS     r1,#1
000092  0488              LSLS     r0,r1,#18
000094  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;806    
;;;807    	/* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;808    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
000098  f44f6080          MOV      r0,#0x400
00009c  f8ad0010          STRH     r0,[sp,#0x10]
;;;809    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
0000a0  2018              MOVS     r0,#0x18
0000a2  f88d0013          STRB     r0,[sp,#0x13]
;;;810    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
0000a6  2003              MOVS     r0,#3
0000a8  f88d0012          STRB     r0,[sp,#0x12]
;;;811    	GPIO_Init(GPIOB, &GPIO_InitStructure);
0000ac  a904              ADD      r1,sp,#0x10
0000ae  481c              LDR      r0,|L4.288|
0000b0  f7fffffe          BL       GPIO_Init
;;;812    
;;;813    	/* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;814    		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;815    		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;816    	*/
;;;817    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
0000b4  f44f6000          MOV      r0,#0x800
0000b8  f8ad0010          STRH     r0,[sp,#0x10]
;;;818    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
0000bc  2004              MOVS     r0,#4
0000be  f88d0013          STRB     r0,[sp,#0x13]
;;;819    	GPIO_Init(GPIOB, &GPIO_InitStructure);
0000c2  a904              ADD      r1,sp,#0x10
0000c4  4816              LDR      r0,|L4.288|
0000c6  f7fffffe          BL       GPIO_Init
;;;820    	/*  第3步已经做了，因此这步可以不做
;;;821    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;822    	*/
;;;823    	GPIO_Init(GPIOB, &GPIO_InitStructure);
0000ca  a904              ADD      r1,sp,#0x10
0000cc  4814              LDR      r0,|L4.288|
0000ce  f7fffffe          BL       GPIO_Init
;;;824    
;;;825    	/* 第4步： 配置串口硬件参数 */
;;;826    	USART_InitStructure.USART_BaudRate = UART3_BAUD;	/* 波特率 */
0000d2  f44f5096          MOV      r0,#0x12c0
0000d6  9000              STR      r0,[sp,#0]
;;;827    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
0000d8  2000              MOVS     r0,#0
0000da  f8ad0004          STRH     r0,[sp,#4]
;;;828    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
0000de  f8ad0006          STRH     r0,[sp,#6]
;;;829    	USART_InitStructure.USART_Parity = USART_Parity_No ;
0000e2  f8ad0008          STRH     r0,[sp,#8]
;;;830    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
0000e6  f8ad000c          STRH     r0,[sp,#0xc]
;;;831    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
0000ea  200c              MOVS     r0,#0xc
0000ec  f8ad000a          STRH     r0,[sp,#0xa]
;;;832    	USART_Init(USART3, &USART_InitStructure);
0000f0  4669              MOV      r1,sp
0000f2  480c              LDR      r0,|L4.292|
0000f4  f7fffffe          BL       USART_Init
;;;833    
;;;834    	USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
0000f8  2201              MOVS     r2,#1
0000fa  f2405125          MOV      r1,#0x525
0000fe  4809              LDR      r0,|L4.292|
000100  f7fffffe          BL       USART_ITConfig
;;;835    	/*
;;;836    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;837    		注意: 不要在此处打开发送中断
;;;838    		发送中断使能在SendUart()函数打开
;;;839    	*/
;;;840    	USART_Cmd(USART3, ENABLE);		/* 使能串口 */
000104  2101              MOVS     r1,#1
000106  4807              LDR      r0,|L4.292|
000108  f7fffffe          BL       USART_Cmd
;;;841    
;;;842    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;843    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;844    	USART_ClearFlag(USART3, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
00010c  2140              MOVS     r1,#0x40
00010e  4805              LDR      r0,|L4.292|
000110  f7fffffe          BL       USART_ClearFlag
;;;845    #endif
;;;846    
;;;847    #if UART4_FIFO_EN == 1			/* 串口4 TX = PC10   RX = PC11 */
;;;848    	/* 第1步： 开启GPIO和UART时钟 */
;;;849    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC | RCC_APB2Periph_AFIO, ENABLE);
;;;850    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4, ENABLE);   
;;;851        //GPIO_PinAFConfig(GPIOC, GPIO_PinSource10, GPIO_AF_USART4);
;;;852        //GPIO_PinAFConfig(GPIOC, GPIO_PinSource11, GPIO_AF_USART4);
;;;853    
;;;854    	/* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;855    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
;;;856    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
;;;857    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;858    	GPIO_Init(GPIOC, &GPIO_InitStructure);
;;;859    
;;;860    	/* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;861    		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;862    		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;863    	*/
;;;864    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
;;;865    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
;;;866    	GPIO_Init(GPIOC, &GPIO_InitStructure);
;;;867    
;;;868    	/* 第4步： 配置串口硬件参数 */
;;;869    	USART_InitStructure.USART_BaudRate = UART4_BAUD;	/* 波特率 */
;;;870    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
;;;871    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;872    	USART_InitStructure.USART_Parity = USART_Parity_No ;
;;;873    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;874    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
;;;875    	USART_Init(UART4, &USART_InitStructure);
;;;876    
;;;877    	USART_ITConfig(UART4, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
;;;878    	/*	USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;879    		注意: 不要在此处打开发送中断
;;;880    		发送中断使能在SendUart()函数打开	*/
;;;881    	USART_Cmd(UART4, ENABLE);		/* 使能串口 */
;;;882    
;;;883    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;884    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;885    	USART_ClearFlag(UART4, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
;;;886    #endif
;;;887    
;;;888    #if UART5_FIFO_EN == 1			/* 串口5 TX = PC12   RX = PD2 */
;;;889    	/* 第1步： 开启GPIO和UART时钟 */
;;;890    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC | RCC_APB2Periph_GPIOD | RCC_APB2Periph_AFIO, ENABLE);
;;;891    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART5, ENABLE);
;;;892    
;;;893    	/* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;894    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
;;;895    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
;;;896    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;897    	GPIO_Init(GPIOC, &GPIO_InitStructure);
;;;898    
;;;899    	/* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;900    		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;901    		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;902    	*/
;;;903    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
;;;904    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
;;;905    	GPIO_Init(GPIOD, &GPIO_InitStructure);
;;;906    
;;;907    
;;;908    	/* 第4步： 配置串口硬件参数 */
;;;909    	USART_InitStructure.USART_BaudRate = UART5_BAUD;	/* 波特率 */
;;;910    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
;;;911    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;912    	USART_InitStructure.USART_Parity = USART_Parity_No ;
;;;913    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;914    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
;;;915    	USART_Init(UART5, &USART_InitStructure);
;;;916    
;;;917    	USART_ITConfig(UART5, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
;;;918    	/*
;;;919    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;920    		注意: 不要在此处打开发送中断
;;;921    		发送中断使能在SendUart()函数打开
;;;922    	*/
;;;923    	USART_Cmd(UART5, ENABLE);		/* 使能串口 */
;;;924    
;;;925    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;926    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;927    	USART_ClearFlag(UART5, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
;;;928    #endif
;;;929    }
000114  b005              ADD      sp,sp,#0x14
000116  bd00              POP      {pc}
;;;930    
                          ENDP

                  |L4.280|
                          DCD      0x40010800
                  |L4.284|
                          DCD      0x40013800
                  |L4.288|
                          DCD      0x40010c00
                  |L4.292|
                          DCD      0x40004800

                          AREA ||i.RS485ADD1||, CODE, READONLY, ALIGN=2

                  RS485ADD1 PROC
;;;81     
;;;82     static uint8_t RS485ADD1(void) {if ((GPIOD->IDR & GPIO_Pin_11) == 0) return 1;else return 0;}
000000  4804              LDR      r0,|L5.20|
000002  6800              LDR      r0,[r0,#0]
000004  f4006000          AND      r0,r0,#0x800
000008  b908              CBNZ     r0,|L5.14|
00000a  2001              MOVS     r0,#1
                  |L5.12|
00000c  4770              BX       lr
                  |L5.14|
00000e  2000              MOVS     r0,#0
000010  e7fc              B        |L5.12|
;;;83     static uint8_t RS485ADD2(void) {if ((GPIOD->IDR & GPIO_Pin_10) == 0) return 1;else return 0;}
                          ENDP

000012  0000              DCW      0x0000
                  |L5.20|
                          DCD      0x40011408

                          AREA ||i.RS485ADD2||, CODE, READONLY, ALIGN=2

                  RS485ADD2 PROC
;;;82     static uint8_t RS485ADD1(void) {if ((GPIOD->IDR & GPIO_Pin_11) == 0) return 1;else return 0;}
;;;83     static uint8_t RS485ADD2(void) {if ((GPIOD->IDR & GPIO_Pin_10) == 0) return 1;else return 0;}
000000  4804              LDR      r0,|L6.20|
000002  6800              LDR      r0,[r0,#0]
000004  f4006080          AND      r0,r0,#0x400
000008  b908              CBNZ     r0,|L6.14|
00000a  2001              MOVS     r0,#1
                  |L6.12|
00000c  4770              BX       lr
                  |L6.14|
00000e  2000              MOVS     r0,#0
000010  e7fc              B        |L6.12|
;;;84     static uint8_t RS485ADD3(void) {if ((GPIOD->IDR & GPIO_Pin_9 ) == 0) return 1;else return 0;}
                          ENDP

000012  0000              DCW      0x0000
                  |L6.20|
                          DCD      0x40011408

                          AREA ||i.RS485ADD3||, CODE, READONLY, ALIGN=2

                  RS485ADD3 PROC
;;;83     static uint8_t RS485ADD2(void) {if ((GPIOD->IDR & GPIO_Pin_10) == 0) return 1;else return 0;}
;;;84     static uint8_t RS485ADD3(void) {if ((GPIOD->IDR & GPIO_Pin_9 ) == 0) return 1;else return 0;}
000000  4804              LDR      r0,|L7.20|
000002  6800              LDR      r0,[r0,#0]
000004  f4007000          AND      r0,r0,#0x200
000008  b908              CBNZ     r0,|L7.14|
00000a  2001              MOVS     r0,#1
                  |L7.12|
00000c  4770              BX       lr
                  |L7.14|
00000e  2000              MOVS     r0,#0
000010  e7fc              B        |L7.12|
;;;85     static uint8_t RS485ADD4(void) {if ((GPIOD->IDR & GPIO_Pin_8 ) == 0) return 1;else return 0;}
                          ENDP

000012  0000              DCW      0x0000
                  |L7.20|
                          DCD      0x40011408

                          AREA ||i.RS485ADD4||, CODE, READONLY, ALIGN=2

                  RS485ADD4 PROC
;;;84     static uint8_t RS485ADD3(void) {if ((GPIOD->IDR & GPIO_Pin_9 ) == 0) return 1;else return 0;}
;;;85     static uint8_t RS485ADD4(void) {if ((GPIOD->IDR & GPIO_Pin_8 ) == 0) return 1;else return 0;}
000000  4804              LDR      r0,|L8.20|
000002  6800              LDR      r0,[r0,#0]
000004  f4007080          AND      r0,r0,#0x100
000008  b908              CBNZ     r0,|L8.14|
00000a  2001              MOVS     r0,#1
                  |L8.12|
00000c  4770              BX       lr
                  |L8.14|
00000e  2000              MOVS     r0,#0
000010  e7fc              B        |L8.12|
;;;86     static uint8_t RS485ADD5(void) {if ((GPIOE->IDR & GPIO_Pin_11) == 0) return 1;else return 0;}
                          ENDP

000012  0000              DCW      0x0000
                  |L8.20|
                          DCD      0x40011408

                          AREA ||i.RS485ADD5||, CODE, READONLY, ALIGN=2

                  RS485ADD5 PROC
;;;85     static uint8_t RS485ADD4(void) {if ((GPIOD->IDR & GPIO_Pin_8 ) == 0) return 1;else return 0;}
;;;86     static uint8_t RS485ADD5(void) {if ((GPIOE->IDR & GPIO_Pin_11) == 0) return 1;else return 0;}
000000  4804              LDR      r0,|L9.20|
000002  6800              LDR      r0,[r0,#0]
000004  f4006000          AND      r0,r0,#0x800
000008  b908              CBNZ     r0,|L9.14|
00000a  2001              MOVS     r0,#1
                  |L9.12|
00000c  4770              BX       lr
                  |L9.14|
00000e  2000              MOVS     r0,#0
000010  e7fc              B        |L9.12|
;;;87     static uint8_t RS485ADD6(void) {if ((GPIOE->IDR & GPIO_Pin_10) == 0) return 1;else return 0;}
                          ENDP

000012  0000              DCW      0x0000
                  |L9.20|
                          DCD      0x40011808

                          AREA ||i.RS485ADD6||, CODE, READONLY, ALIGN=2

                  RS485ADD6 PROC
;;;86     static uint8_t RS485ADD5(void) {if ((GPIOE->IDR & GPIO_Pin_11) == 0) return 1;else return 0;}
;;;87     static uint8_t RS485ADD6(void) {if ((GPIOE->IDR & GPIO_Pin_10) == 0) return 1;else return 0;}
000000  4804              LDR      r0,|L10.20|
000002  6800              LDR      r0,[r0,#0]
000004  f4006080          AND      r0,r0,#0x400
000008  b908              CBNZ     r0,|L10.14|
00000a  2001              MOVS     r0,#1
                  |L10.12|
00000c  4770              BX       lr
                  |L10.14|
00000e  2000              MOVS     r0,#0
000010  e7fc              B        |L10.12|
;;;88     static uint8_t RS485ADD7(void) {if ((GPIOE->IDR & GPIO_Pin_9 ) == 0) return 1;else return 0;}
                          ENDP

000012  0000              DCW      0x0000
                  |L10.20|
                          DCD      0x40011808

                          AREA ||i.RS485ADD7||, CODE, READONLY, ALIGN=2

                  RS485ADD7 PROC
;;;87     static uint8_t RS485ADD6(void) {if ((GPIOE->IDR & GPIO_Pin_10) == 0) return 1;else return 0;}
;;;88     static uint8_t RS485ADD7(void) {if ((GPIOE->IDR & GPIO_Pin_9 ) == 0) return 1;else return 0;}
000000  4804              LDR      r0,|L11.20|
000002  6800              LDR      r0,[r0,#0]
000004  f4007000          AND      r0,r0,#0x200
000008  b908              CBNZ     r0,|L11.14|
00000a  2001              MOVS     r0,#1
                  |L11.12|
00000c  4770              BX       lr
                  |L11.14|
00000e  2000              MOVS     r0,#0
000010  e7fc              B        |L11.12|
;;;89     static uint8_t RS485ADD8(void) {if ((GPIOE->IDR & GPIO_Pin_8 ) == 0) return 1;else return 0;}
                          ENDP

000012  0000              DCW      0x0000
                  |L11.20|
                          DCD      0x40011808

                          AREA ||i.RS485ADD8||, CODE, READONLY, ALIGN=2

                  RS485ADD8 PROC
;;;88     static uint8_t RS485ADD7(void) {if ((GPIOE->IDR & GPIO_Pin_9 ) == 0) return 1;else return 0;}
;;;89     static uint8_t RS485ADD8(void) {if ((GPIOE->IDR & GPIO_Pin_8 ) == 0) return 1;else return 0;}
000000  4804              LDR      r0,|L12.20|
000002  6800              LDR      r0,[r0,#0]
000004  f4007080          AND      r0,r0,#0x100
000008  b908              CBNZ     r0,|L12.14|
00000a  2001              MOVS     r0,#1
                  |L12.12|
00000c  4770              BX       lr
                  |L12.14|
00000e  2000              MOVS     r0,#0
000010  e7fc              B        |L12.12|
;;;90     
                          ENDP

000012  0000              DCW      0x0000
                  |L12.20|
                          DCD      0x40011808

                          AREA ||i.RS485_InitTXE||, CODE, READONLY, ALIGN=2

                  RS485_InitTXE PROC
;;;427    */
;;;428    void RS485_InitTXE(void)
000000  b508              PUSH     {r3,lr}
;;;429    {
;;;430    	GPIO_InitTypeDef GPIO_InitStructure;
;;;431    
;;;432    	RCC_APB2PeriphClockCmd(RCC_RS485_TXEN, ENABLE);	/* 打开GPIO时钟 */
000002  2101              MOVS     r1,#1
000004  2008              MOVS     r0,#8
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;433    
;;;434    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00000a  2003              MOVS     r0,#3
00000c  f88d0002          STRB     r0,[sp,#2]
;;;435    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;	/* 推挽输出模式 */
000010  2010              MOVS     r0,#0x10
000012  f88d0003          STRB     r0,[sp,#3]
;;;436    	GPIO_InitStructure.GPIO_Pin = PIN_RS485_TXEN;
000016  2002              MOVS     r0,#2
000018  f8ad0000          STRH     r0,[sp,#0]
;;;437    	GPIO_Init(PORT_RS485_TXEN, &GPIO_InitStructure);
00001c  4669              MOV      r1,sp
00001e  4804              LDR      r0,|L13.48|
000020  f7fffffe          BL       GPIO_Init
;;;438    	RS485_RX_EN();
000024  2002              MOVS     r0,#2
000026  4902              LDR      r1,|L13.48|
000028  3114              ADDS     r1,r1,#0x14
00002a  6008              STR      r0,[r1,#0]
;;;439        
;;;440    }
00002c  bd08              POP      {r3,pc}
;;;441    
                          ENDP

00002e  0000              DCW      0x0000
                  |L13.48|
                          DCD      0x40010c00

                          AREA ||i.RS485_ReceiveDat||, CODE, READONLY, ALIGN=2

                  RS485_ReceiveDat PROC
;;;536    }
;;;537    void RS485_ReceiveDat(void)
000000  b538              PUSH     {r3-r5,lr}
;;;538    {
;;;539        uint8_t read,CRC_Dat;
;;;540        uint16_t i;
;;;541        for(i=0;i<UART3_TX_BUF_SIZE;i++)
000002  2500              MOVS     r5,#0
000004  e04c              B        |L14.160|
                  |L14.6|
;;;542        {
;;;543             if (comGetChar(COM3, &read))
000006  4669              MOV      r1,sp
000008  2002              MOVS     r0,#2
00000a  f7fffffe          BL       comGetChar
00000e  2800              CMP      r0,#0
000010  d044              BEQ      |L14.156|
;;;544            {
;;;545               if((RS485_Count&0x80)==0)//接收未完成；
000012  4825              LDR      r0,|L14.168|
000014  7800              LDRB     r0,[r0,#0]  ; RS485_Count
000016  f0000080          AND      r0,r0,#0x80
00001a  2800              CMP      r0,#0
00001c  d13e              BNE      |L14.156|
;;;546                {
;;;547                    RS485Dat[RS485_Count] = read;
00001e  f89d0000          LDRB     r0,[sp,#0]
000022  4922              LDR      r1,|L14.172|
000024  4a20              LDR      r2,|L14.168|
000026  7812              LDRB     r2,[r2,#0]  ; RS485_Count
000028  5488              STRB     r0,[r1,r2]
;;;548                    RS485_Count++;
00002a  481f              LDR      r0,|L14.168|
00002c  7800              LDRB     r0,[r0,#0]  ; RS485_Count
00002e  1c40              ADDS     r0,r0,#1
000030  491d              LDR      r1,|L14.168|
000032  7008              STRB     r0,[r1,#0]
;;;549                    if(RS485_Count>10)   RS485_Count = 0;
000034  4608              MOV      r0,r1
000036  7800              LDRB     r0,[r0,#0]  ; RS485_Count
000038  280a              CMP      r0,#0xa
00003a  dd01              BLE      |L14.64|
00003c  2000              MOVS     r0,#0
00003e  7008              STRB     r0,[r1,#0]
                  |L14.64|
;;;550                    if((RS485Dat[RS485_Count-1] == 0xF2)&&(RS485_Count<3))   //判断起始位0xF1;
000040  4819              LDR      r0,|L14.168|
000042  7800              LDRB     r0,[r0,#0]  ; RS485_Count
000044  1e40              SUBS     r0,r0,#1
000046  4919              LDR      r1,|L14.172|
000048  5c08              LDRB     r0,[r1,r0]
00004a  28f2              CMP      r0,#0xf2
00004c  d10d              BNE      |L14.106|
00004e  4816              LDR      r0,|L14.168|
000050  7800              LDRB     r0,[r0,#0]  ; RS485_Count
000052  2803              CMP      r0,#3
000054  da09              BGE      |L14.106|
;;;551                    {
;;;552                        RS485Dat[RS485_Count-1] = 0xF2;
000056  21f2              MOVS     r1,#0xf2
000058  4813              LDR      r0,|L14.168|
00005a  7800              LDRB     r0,[r0,#0]  ; RS485_Count
00005c  1e40              SUBS     r0,r0,#1
00005e  4a13              LDR      r2,|L14.172|
000060  5411              STRB     r1,[r2,r0]
;;;553                        RS485_Count = 1;
000062  2001              MOVS     r0,#1
000064  4910              LDR      r1,|L14.168|
000066  7008              STRB     r0,[r1,#0]
000068  e018              B        |L14.156|
                  |L14.106|
;;;554                    }
;;;555    				else
;;;556    				{
;;;557    					if(RS485_Count>=RS485Dat[1])
00006a  4810              LDR      r0,|L14.172|
00006c  7840              LDRB     r0,[r0,#1]  ; RS485Dat
00006e  490e              LDR      r1,|L14.168|
000070  7809              LDRB     r1,[r1,#0]  ; RS485_Count
000072  4288              CMP      r0,r1
000074  dc12              BGT      |L14.156|
;;;558    					{
;;;559    						CRC_Dat = CRC8_Table(RS485Dat,6);
000076  2106              MOVS     r1,#6
000078  480c              LDR      r0,|L14.172|
00007a  f7fffffe          BL       CRC8_Table
00007e  4604              MOV      r4,r0
;;;560    						if(CRC_Dat == RS485Dat[6])	RS485_Count|=0x80;	/*接收完成了 */
000080  480a              LDR      r0,|L14.172|
000082  7980              LDRB     r0,[r0,#6]  ; RS485Dat
000084  42a0              CMP      r0,r4
000086  d106              BNE      |L14.150|
000088  4807              LDR      r0,|L14.168|
00008a  7800              LDRB     r0,[r0,#0]  ; RS485_Count
00008c  f0400080          ORR      r0,r0,#0x80
000090  4905              LDR      r1,|L14.168|
000092  7008              STRB     r0,[r1,#0]
000094  e002              B        |L14.156|
                  |L14.150|
;;;561    						else	RS485_Count = 0;
000096  2000              MOVS     r0,#0
000098  4903              LDR      r1,|L14.168|
00009a  7008              STRB     r0,[r1,#0]
                  |L14.156|
00009c  1c68              ADDS     r0,r5,#1              ;541
00009e  b285              UXTH     r5,r0                 ;541
                  |L14.160|
0000a0  f5b56f80          CMP      r5,#0x400             ;541
0000a4  dbaf              BLT      |L14.6|
;;;562    					}
;;;563    //					if((RS485Dat[RS485_Count-2] == 0x03)&&(RS485Dat[RS485_Count-1] == 0x02))
;;;564    //					{
;;;565    //						RS485_Count|=0x80;   //接收完成
;;;566    //						break;
;;;567    //					}
;;;568    				}
;;;569                }            
;;;570             }
;;;571        }
;;;572    }
0000a6  bd38              POP      {r3-r5,pc}
;;;573    
                          ENDP

                  |L14.168|
                          DCD      RS485_Count
                  |L14.172|
                          DCD      RS485Dat

                          AREA ||i.RS485_ReciveNew||, CODE, READONLY, ALIGN=1

                  RS485_ReciveNew PROC
;;;532    //extern void MODBUS_ReciveNew(uint8_t _byte);
;;;533    void RS485_ReciveNew(uint8_t _byte)
000000  4770              BX       lr
;;;534    {
;;;535    //	MODBUS_ReciveNew(_byte);
;;;536    }
;;;537    void RS485_ReceiveDat(void)
                          ENDP


                          AREA ||i.RS485_SendBefor||, CODE, READONLY, ALIGN=2

                  RS485_SendBefor PROC
;;;473    */
;;;474    void RS485_SendBefor(void)
000000  2002              MOVS     r0,#2
;;;475    {
;;;476    	RS485_TX_EN();	/* 切换RS485收发芯片为发送模式 */
000002  4901              LDR      r1,|L16.8|
000004  6008              STR      r0,[r1,#0]
;;;477    }
000006  4770              BX       lr
;;;478    
                          ENDP

                  |L16.8|
                          DCD      0x40010c10

                          AREA ||i.RS485_SendBuf||, CODE, READONLY, ALIGN=2

                  RS485_SendBuf PROC
;;;501    */
;;;502    void RS485_SendBuf(uint8_t *_ucaBuf, uint16_t _usLen)
000000  b570              PUSH     {r4-r6,lr}
;;;503    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;504    	RS485_RX_EN();
000006  2002              MOVS     r0,#2
000008  4905              LDR      r1,|L17.32|
00000a  6008              STR      r0,[r1,#0]
;;;505    	comSendBuf(COM3, _ucaBuf, _usLen);
00000c  462a              MOV      r2,r5
00000e  4621              MOV      r1,r4
000010  f7fffffe          BL       comSendBuf
;;;506    	RS485_TX_EN();
000014  2002              MOVS     r0,#2
000016  4902              LDR      r1,|L17.32|
000018  1f09              SUBS     r1,r1,#4
00001a  6008              STR      r0,[r1,#0]
;;;507    }
00001c  bd70              POP      {r4-r6,pc}
;;;508    
                          ENDP

00001e  0000              DCW      0x0000
                  |L17.32|
                          DCD      0x40010c14

                          AREA ||i.RS485_SendDat||, CODE, READONLY, ALIGN=2

                  RS485_SendDat PROC
;;;574    
;;;575    void RS485_SendDat(uint8_t *_uBuff)
000000  b53e              PUSH     {r1-r5,lr}
;;;576    {
000002  4604              MOV      r4,r0
;;;577    	uint8_t Runningbuf[9]={0xF1,0x09,0x01,0x00,0x00,0x00,0x00,0x03,0x02};
000004  a20d              ADR      r2,|L18.60|
000006  ca07              LDM      r2,{r0-r2}
000008  e88d0007          STM      sp,{r0-r2}
;;;578    	Runningbuf[2] = _uBuff[0];	
00000c  7820              LDRB     r0,[r4,#0]
00000e  f88d0002          STRB     r0,[sp,#2]
;;;579    	Runningbuf[3] = _uBuff[1];	
000012  7860              LDRB     r0,[r4,#1]
000014  f88d0003          STRB     r0,[sp,#3]
;;;580    	Runningbuf[4] = _uBuff[2];	
000018  78a0              LDRB     r0,[r4,#2]
00001a  f88d0004          STRB     r0,[sp,#4]
;;;581    	Runningbuf[5] = _uBuff[3];	
00001e  78e0              LDRB     r0,[r4,#3]
000020  f88d0005          STRB     r0,[sp,#5]
;;;582    	Runningbuf[6] = CRC8_Table(Runningbuf,6);	//CRC校验位	
000024  2106              MOVS     r1,#6
000026  4668              MOV      r0,sp
000028  f7fffffe          BL       CRC8_Table
00002c  f88d0006          STRB     r0,[sp,#6]
;;;583    	RS485_SendBuf((uint8_t *)Runningbuf,Runningbuf[1]);
000030  f89d1001          LDRB     r1,[sp,#1]
000034  4668              MOV      r0,sp
000036  f7fffffe          BL       RS485_SendBuf
;;;584    }
00003a  bd3e              POP      {r1-r5,pc}
;;;585    
                          ENDP

                  |L18.60|
00003c  f1090100          DCB      241,"\t",1,0
000040  00                DCB      0
000041  00                DCB      0
000042  00                DCB      0
000043  030200            DCB      3,2,0
000046  00                DCB      0
000047  00                DCB      0

                          AREA ||i.RS485_SendOver||, CODE, READONLY, ALIGN=2

                  RS485_SendOver PROC
;;;487    */
;;;488    void RS485_SendOver(void)
000000  2002              MOVS     r0,#2
;;;489    {
;;;490    	RS485_RX_EN();	/* 切换RS485收发芯片为接收模式 */
000002  4901              LDR      r1,|L19.8|
000004  6008              STR      r0,[r1,#0]
;;;491    }
000006  4770              BX       lr
;;;492    
                          ENDP

                  |L19.8|
                          DCD      0x40010c14

                          AREA ||i.RS485_SendStr||, CODE, READONLY, ALIGN=1

                  RS485_SendStr PROC
;;;518    */
;;;519    void RS485_SendStr(char *_pBuf)
000000  b570              PUSH     {r4-r6,lr}
;;;520    {
000002  4604              MOV      r4,r0
;;;521    	RS485_SendBuf((uint8_t *)_pBuf, strlen(_pBuf));
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       strlen
00000a  b285              UXTH     r5,r0
00000c  4629              MOV      r1,r5
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       RS485_SendBuf
;;;522    }
000014  bd70              POP      {r4-r6,pc}
;;;523    
                          ENDP


                          AREA ||i.ReceivePowerBUSDat||, CODE, READONLY, ALIGN=2

                  ReceivePowerBUSDat PROC
;;;259    
;;;260    void ReceivePowerBUSDat(uint8_t _mode)
000000  b5f8              PUSH     {r3-r7,lr}
;;;261    {
000002  4605              MOV      r5,r0
;;;262        uint8_t read,CRC_Dat;
;;;263        uint8_t i;
;;;264        for(i=0;i<16;i++)
000004  2600              MOVS     r6,#0
000006  e056              B        |L21.182|
                  |L21.8|
;;;265        {
;;;266            if (comGetChar(COM2, &read))    //接收到串口数据
000008  4669              MOV      r1,sp
00000a  2001              MOVS     r0,#1
00000c  f7fffffe          BL       comGetChar
000010  2800              CMP      r0,#0
000012  d04e              BEQ      |L21.178|
;;;267            {
;;;268                if((PBus_Count&0x80)==0)//接收未完成；
000014  482a              LDR      r0,|L21.192|
000016  7800              LDRB     r0,[r0,#0]  ; PBus_Count
000018  f0000080          AND      r0,r0,#0x80
00001c  2800              CMP      r0,#0
00001e  d148              BNE      |L21.178|
;;;269                {
;;;270                    PBusDat[PBus_Count] = read;
000020  f89d0000          LDRB     r0,[sp,#0]
000024  4927              LDR      r1,|L21.196|
000026  4a26              LDR      r2,|L21.192|
000028  7812              LDRB     r2,[r2,#0]  ; PBus_Count
00002a  5488              STRB     r0,[r1,r2]
;;;271                    PBus_Count++;
00002c  4824              LDR      r0,|L21.192|
00002e  7800              LDRB     r0,[r0,#0]  ; PBus_Count
000030  1c40              ADDS     r0,r0,#1
000032  4923              LDR      r1,|L21.192|
000034  7008              STRB     r0,[r1,#0]
;;;272                    if(PBus_Count>16)   PBus_Count = 0;
000036  4608              MOV      r0,r1
000038  7800              LDRB     r0,[r0,#0]  ; PBus_Count
00003a  2810              CMP      r0,#0x10
00003c  dd01              BLE      |L21.66|
00003e  2000              MOVS     r0,#0
000040  7008              STRB     r0,[r1,#0]
                  |L21.66|
;;;273                    if(PBusDat[PBus_Count-1] == 0xF3)   //判断起始位0xF3;
000042  481f              LDR      r0,|L21.192|
000044  7800              LDRB     r0,[r0,#0]  ; PBus_Count
000046  1e40              SUBS     r0,r0,#1
000048  491e              LDR      r1,|L21.196|
00004a  5c08              LDRB     r0,[r1,r0]
00004c  28f3              CMP      r0,#0xf3
00004e  d109              BNE      |L21.100|
;;;274                    {
;;;275                        PBusDat[PBus_Count-1] = 0xF3;
000050  21f3              MOVS     r1,#0xf3
000052  481b              LDR      r0,|L21.192|
000054  7800              LDRB     r0,[r0,#0]  ; PBus_Count
000056  1e40              SUBS     r0,r0,#1
000058  4a1a              LDR      r2,|L21.196|
00005a  5411              STRB     r1,[r2,r0]
;;;276                        PBus_Count = 1;
00005c  2001              MOVS     r0,#1
00005e  4918              LDR      r1,|L21.192|
000060  7008              STRB     r0,[r1,#0]
000062  e026              B        |L21.178|
                  |L21.100|
;;;277                    }
;;;278                    else
;;;279                    {
;;;280                        if(_mode==0x00) //不带校验模式；
000064  b935              CBNZ     r5,|L21.116|
;;;281                        {
;;;282                            PBus_Count|=0x80;   //接收完成
000066  4816              LDR      r0,|L21.192|
000068  7800              LDRB     r0,[r0,#0]  ; PBus_Count
00006a  f0400080          ORR      r0,r0,#0x80
00006e  4914              LDR      r1,|L21.192|
000070  7008              STRB     r0,[r1,#0]
;;;283                            break;
000072  e022              B        |L21.186|
                  |L21.116|
;;;284                        }
;;;285                        else    //带核验模式
;;;286                        {
;;;287                            if(PBus_Count>=PBusDat[1])
000074  4813              LDR      r0,|L21.196|
000076  7840              LDRB     r0,[r0,#1]  ; PBusDat
000078  4911              LDR      r1,|L21.192|
00007a  7809              LDRB     r1,[r1,#0]  ; PBus_Count
00007c  4288              CMP      r0,r1
00007e  dc18              BGT      |L21.178|
;;;288                            {
;;;289                                CRC_Dat = CRC8_Table(PBusDat,PBus_Count-1);
000080  480f              LDR      r0,|L21.192|
000082  7800              LDRB     r0,[r0,#0]  ; PBus_Count
000084  1e40              SUBS     r0,r0,#1
000086  b2c1              UXTB     r1,r0
000088  480e              LDR      r0,|L21.196|
00008a  f7fffffe          BL       CRC8_Table
00008e  4604              MOV      r4,r0
;;;290                                if(CRC_Dat == PBusDat[PBus_Count-1])	PBus_Count|=0x80;	/*接收完成了 */
000090  480b              LDR      r0,|L21.192|
000092  7800              LDRB     r0,[r0,#0]  ; PBus_Count
000094  1e40              SUBS     r0,r0,#1
000096  490b              LDR      r1,|L21.196|
000098  5c08              LDRB     r0,[r1,r0]
00009a  42a0              CMP      r0,r4
00009c  d106              BNE      |L21.172|
00009e  4808              LDR      r0,|L21.192|
0000a0  7800              LDRB     r0,[r0,#0]  ; PBus_Count
0000a2  f0400080          ORR      r0,r0,#0x80
0000a6  4906              LDR      r1,|L21.192|
0000a8  7008              STRB     r0,[r1,#0]
0000aa  e002              B        |L21.178|
                  |L21.172|
;;;291                                else	PBus_Count = 0;
0000ac  2000              MOVS     r0,#0
0000ae  4904              LDR      r1,|L21.192|
0000b0  7008              STRB     r0,[r1,#0]
                  |L21.178|
0000b2  1c70              ADDS     r0,r6,#1              ;264
0000b4  b2c6              UXTB     r6,r0                 ;264
                  |L21.182|
0000b6  2e10              CMP      r6,#0x10              ;264
0000b8  dba6              BLT      |L21.8|
                  |L21.186|
0000ba  bf00              NOP                            ;283
;;;292                            }
;;;293                        }
;;;294                    }
;;;295                }            
;;;296            }
;;;297        }
;;;298    }
0000bc  bdf8              POP      {r3-r7,pc}
;;;299    void ReceiveSerialDat(void)
                          ENDP

0000be  0000              DCW      0x0000
                  |L21.192|
                          DCD      PBus_Count
                  |L21.196|
                          DCD      PBusDat

                          AREA ||i.ReceiveSerialDat||, CODE, READONLY, ALIGN=2

                  ReceiveSerialDat PROC
;;;298    }
;;;299    void ReceiveSerialDat(void)
000000  b538              PUSH     {r3-r5,lr}
;;;300    {
;;;301        uint8_t read,CRC_Dat;
;;;302    		if (comGetChar(COM3, &read))    //接收到串口数据
000002  4669              MOV      r1,sp
000004  2002              MOVS     r0,#2
000006  f7fffffe          BL       comGetChar
00000a  2800              CMP      r0,#0
00000c  d046              BEQ      |L22.156|
;;;303    		{
;;;304    			if((g_Serial_Count&0x80)==0)//接收未完成；
00000e  4824              LDR      r0,|L22.160|
000010  7800              LDRB     r0,[r0,#0]  ; g_Serial_Count
000012  f0000080          AND      r0,r0,#0x80
000016  2800              CMP      r0,#0
000018  d140              BNE      |L22.156|
;;;305    			{
;;;306    				g_SerialDat[g_Serial_Count] = read;
00001a  f89d0000          LDRB     r0,[sp,#0]
00001e  4921              LDR      r1,|L22.164|
000020  4a1f              LDR      r2,|L22.160|
000022  7812              LDRB     r2,[r2,#0]  ; g_Serial_Count
000024  5488              STRB     r0,[r1,r2]
;;;307    				g_Serial_Count++;
000026  481e              LDR      r0,|L22.160|
000028  7800              LDRB     r0,[r0,#0]  ; g_Serial_Count
00002a  1c40              ADDS     r0,r0,#1
00002c  491c              LDR      r1,|L22.160|
00002e  7008              STRB     r0,[r1,#0]
;;;308    				if(g_Serial_Count>32)   g_Serial_Count = 0;
000030  4608              MOV      r0,r1
000032  7800              LDRB     r0,[r0,#0]  ; g_Serial_Count
000034  2820              CMP      r0,#0x20
000036  dd01              BLE      |L22.60|
000038  2000              MOVS     r0,#0
00003a  7008              STRB     r0,[r1,#0]
                  |L22.60|
;;;309    				if(g_SerialDat[g_Serial_Count-1] == 0xF3)   //判断起始位0xF3;
00003c  4818              LDR      r0,|L22.160|
00003e  7800              LDRB     r0,[r0,#0]  ; g_Serial_Count
000040  1e40              SUBS     r0,r0,#1
000042  4918              LDR      r1,|L22.164|
000044  5c08              LDRB     r0,[r1,r0]
000046  28f3              CMP      r0,#0xf3
000048  d109              BNE      |L22.94|
;;;310    				{
;;;311    					g_SerialDat[g_Serial_Count-1] = 0xF3;
00004a  21f3              MOVS     r1,#0xf3
00004c  4814              LDR      r0,|L22.160|
00004e  7800              LDRB     r0,[r0,#0]  ; g_Serial_Count
000050  1e40              SUBS     r0,r0,#1
000052  4a14              LDR      r2,|L22.164|
000054  5411              STRB     r1,[r2,r0]
;;;312    					g_Serial_Count = 1;
000056  2001              MOVS     r0,#1
000058  4911              LDR      r1,|L22.160|
00005a  7008              STRB     r0,[r1,#0]
00005c  e01e              B        |L22.156|
                  |L22.94|
;;;313    				}
;;;314    				else
;;;315    				{
;;;316    					if(g_Serial_Count>=g_SerialDat[1])
00005e  4811              LDR      r0,|L22.164|
000060  7840              LDRB     r0,[r0,#1]  ; g_SerialDat
000062  490f              LDR      r1,|L22.160|
000064  7809              LDRB     r1,[r1,#0]  ; g_Serial_Count
000066  4288              CMP      r0,r1
000068  dc18              BGT      |L22.156|
;;;317    					{
;;;318    						CRC_Dat = CRC8_Table(g_SerialDat,g_Serial_Count-1);
00006a  480d              LDR      r0,|L22.160|
00006c  7800              LDRB     r0,[r0,#0]  ; g_Serial_Count
00006e  1e40              SUBS     r0,r0,#1
000070  b2c1              UXTB     r1,r0
000072  480c              LDR      r0,|L22.164|
000074  f7fffffe          BL       CRC8_Table
000078  4604              MOV      r4,r0
;;;319    						if(CRC_Dat == g_SerialDat[g_Serial_Count-1])	g_Serial_Count|=0x80;	/*接收完成了 */
00007a  4809              LDR      r0,|L22.160|
00007c  7800              LDRB     r0,[r0,#0]  ; g_Serial_Count
00007e  1e40              SUBS     r0,r0,#1
000080  4908              LDR      r1,|L22.164|
000082  5c08              LDRB     r0,[r1,r0]
000084  42a0              CMP      r0,r4
000086  d106              BNE      |L22.150|
000088  4805              LDR      r0,|L22.160|
00008a  7800              LDRB     r0,[r0,#0]  ; g_Serial_Count
00008c  f0400080          ORR      r0,r0,#0x80
000090  4903              LDR      r1,|L22.160|
000092  7008              STRB     r0,[r1,#0]
000094  e002              B        |L22.156|
                  |L22.150|
;;;320    						else	g_Serial_Count = 0;
000096  2000              MOVS     r0,#0
000098  4901              LDR      r1,|L22.160|
00009a  7008              STRB     r0,[r1,#0]
                  |L22.156|
;;;321    					}
;;;322    				}
;;;323    			}            
;;;324    		}
;;;325    }
00009c  bd38              POP      {r3-r5,pc}
;;;326    
                          ENDP

00009e  0000              DCW      0x0000
                  |L22.160|
                          DCD      g_Serial_Count
                  |L22.164|
                          DCD      g_SerialDat

                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;1215   #if UART1_FIFO_EN == 1
;;;1216   void USART1_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;1217   {
;;;1218   	#if SYSTEM_SUPPORT_OS == 1
;;;1219   		OS_CPU_SR  cpu_sr;
;;;1220   
;;;1221   		OS_ENTER_CRITICAL();                         
;;;1222   		OSIntEnter();
;;;1223   		OS_EXIT_CRITICAL();
;;;1224   	#endif
;;;1225   	
;;;1226   	UartIRQ(&g_tUart1);
000002  4802              LDR      r0,|L23.12|
000004  f7fffffe          BL       UartIRQ
;;;1227   	
;;;1228   	#if SYSTEM_SUPPORT_OS == 1
;;;1229   		OSIntExit();                           
;;;1230   	#endif	
;;;1231   }
000008  bd10              POP      {r4,pc}
;;;1232   #endif
                          ENDP

00000a  0000              DCW      0x0000
                  |L23.12|
                          DCD      g_tUart1

                          AREA ||i.USART3_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART3_IRQHandler PROC
;;;1253   #if UART3_FIFO_EN == 1
;;;1254   void USART3_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;1255   {
;;;1256   	#if SYSTEM_SUPPORT_OS == 1
;;;1257   		OS_CPU_SR  cpu_sr;
;;;1258   
;;;1259   		OS_ENTER_CRITICAL();                         
;;;1260   		OSIntEnter();
;;;1261   		OS_EXIT_CRITICAL();
;;;1262   	#endif
;;;1263   	
;;;1264   	UartIRQ(&g_tUart3);
000002  4802              LDR      r0,|L24.12|
000004  f7fffffe          BL       UartIRQ
;;;1265   
;;;1266   	#if SYSTEM_SUPPORT_OS == 1
;;;1267   		OSIntExit();                           
;;;1268   	#endif
;;;1269   }
000008  bd10              POP      {r4,pc}
;;;1270   #endif
                          ENDP

00000a  0000              DCW      0x0000
                  |L24.12|
                          DCD      g_tUart3

                          AREA ||i.UartGetChar||, CODE, READONLY, ALIGN=1

                  UartGetChar PROC
;;;1079   */
;;;1080   static uint8_t UartGetChar(UART_T *_pUart, uint8_t *_pByte)
000000  b570              PUSH     {r4-r6,lr}
;;;1081   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1082   	uint16_t usCount;
;;;1083   	
;;;1084   #if SYSTEM_SUPPORT_OS == 1
;;;1085   	OS_CPU_SR  cpu_sr = 0;
;;;1086   #endif
;;;1087   
;;;1088   	/* usRxWrite 变量在中断函数中被改写，主程序读取该变量时，必须进行临界区保护 */
;;;1089   	DISABLE_INT();
000006  2001              MOVS     r0,#1
000008  f7fffffe          BL       __set_PRIMASK
;;;1090   	usCount = _pUart->usRxCount;
00000c  8b66              LDRH     r6,[r4,#0x1a]
;;;1091   	ENABLE_INT();
00000e  2000              MOVS     r0,#0
000010  f7fffffe          BL       __set_PRIMASK
;;;1092   
;;;1093   	/* 如果读和写索引相同，则返回0 */
;;;1094   	//if (_pUart->usRxRead == usRxWrite)
;;;1095   	if (usCount == 0)	/* 已经没有数据 */
000014  b90e              CBNZ     r6,|L25.26|
;;;1096   	{
;;;1097   		return 0;
000016  2000              MOVS     r0,#0
                  |L25.24|
;;;1098   	}
;;;1099   	else
;;;1100   	{
;;;1101   		*_pByte = _pUart->pRxBuf[_pUart->usRxRead];		/* 从串口接收FIFO取1个数据 */
;;;1102   
;;;1103   		/* 改写FIFO读索引 */
;;;1104   		DISABLE_INT();
;;;1105   		if (++_pUart->usRxRead >= _pUart->usRxBufSize)
;;;1106   		{
;;;1107   			_pUart->usRxRead = 0;
;;;1108   		}
;;;1109   		_pUart->usRxCount--;
;;;1110   		ENABLE_INT();
;;;1111   		return 1;
;;;1112   	}
;;;1113   }
000018  bd70              POP      {r4-r6,pc}
                  |L25.26|
00001a  8b21              LDRH     r1,[r4,#0x18]         ;1101
00001c  68a0              LDR      r0,[r4,#8]            ;1101
00001e  5c40              LDRB     r0,[r0,r1]            ;1101
000020  7028              STRB     r0,[r5,#0]            ;1101
000022  2001              MOVS     r0,#1                 ;1104
000024  f7fffffe          BL       __set_PRIMASK
000028  8b20              LDRH     r0,[r4,#0x18]         ;1105
00002a  1c40              ADDS     r0,r0,#1              ;1105
00002c  b280              UXTH     r0,r0                 ;1105
00002e  8320              STRH     r0,[r4,#0x18]         ;1105
000030  89e1              LDRH     r1,[r4,#0xe]          ;1105
000032  4288              CMP      r0,r1                 ;1105
000034  db01              BLT      |L25.58|
000036  2000              MOVS     r0,#0                 ;1107
000038  8320              STRH     r0,[r4,#0x18]         ;1107
                  |L25.58|
00003a  8b60              LDRH     r0,[r4,#0x1a]         ;1109
00003c  1e40              SUBS     r0,r0,#1              ;1109
00003e  8360              STRH     r0,[r4,#0x1a]         ;1109
000040  2000              MOVS     r0,#0                 ;1110
000042  f7fffffe          BL       __set_PRIMASK
000046  2001              MOVS     r0,#1                 ;1111
000048  e7e6              B        |L25.24|
;;;1114   
                          ENDP


                          AREA ||i.UartIRQ||, CODE, READONLY, ALIGN=1

                  UartIRQ PROC
;;;1122   */
;;;1123   static void UartIRQ(UART_T *_pUart)
000000  b570              PUSH     {r4-r6,lr}
;;;1124   {
000002  4604              MOV      r4,r0
;;;1125   	/* 处理接收中断  */
;;;1126   	if (USART_GetITStatus(_pUart->uart, USART_IT_RXNE) != RESET)
000004  f2405125          MOV      r1,#0x525
000008  6820              LDR      r0,[r4,#0]
00000a  f7fffffe          BL       USART_GetITStatus
00000e  b1e0              CBZ      r0,|L26.74|
;;;1127   	{
;;;1128   		/* 从串口接收数据寄存器读取数据存放到接收FIFO */
;;;1129   		uint8_t ch;
;;;1130   
;;;1131   		ch = USART_ReceiveData(_pUart->uart);
000010  6820              LDR      r0,[r4,#0]
000012  f7fffffe          BL       USART_ReceiveData
000016  b2c5              UXTB     r5,r0
;;;1132   		_pUart->pRxBuf[_pUart->usRxWrite] = ch;
000018  8ae1              LDRH     r1,[r4,#0x16]
00001a  68a0              LDR      r0,[r4,#8]
00001c  5445              STRB     r5,[r0,r1]
;;;1133   		if (++_pUart->usRxWrite >= _pUart->usRxBufSize)
00001e  8ae0              LDRH     r0,[r4,#0x16]
000020  1c40              ADDS     r0,r0,#1
000022  b280              UXTH     r0,r0
000024  82e0              STRH     r0,[r4,#0x16]
000026  89e1              LDRH     r1,[r4,#0xe]
000028  4288              CMP      r0,r1
00002a  db01              BLT      |L26.48|
;;;1134   		{
;;;1135   			_pUart->usRxWrite = 0;
00002c  2000              MOVS     r0,#0
00002e  82e0              STRH     r0,[r4,#0x16]
                  |L26.48|
;;;1136   		}
;;;1137   		if (_pUart->usRxCount < _pUart->usRxBufSize)
000030  8b60              LDRH     r0,[r4,#0x1a]
000032  89e1              LDRH     r1,[r4,#0xe]
000034  4288              CMP      r0,r1
000036  da02              BGE      |L26.62|
;;;1138   		{
;;;1139   			_pUart->usRxCount++;
000038  8b60              LDRH     r0,[r4,#0x1a]
00003a  1c40              ADDS     r0,r0,#1
00003c  8360              STRH     r0,[r4,#0x1a]
                  |L26.62|
;;;1140   		}
;;;1141   
;;;1142   		/* 回调函数,通知应用程序收到新数据,一般是发送1个消息或者设置一个标记 */
;;;1143   		//if (_pUart->usRxWrite == _pUart->usRxRead)
;;;1144   		//if (_pUart->usRxCount == 1)
;;;1145   		{
;;;1146   			if (_pUart->ReciveNew)
00003e  6a60              LDR      r0,[r4,#0x24]
000040  b110              CBZ      r0,|L26.72|
;;;1147   			{
;;;1148   				_pUart->ReciveNew(ch);
000042  4628              MOV      r0,r5
000044  6a61              LDR      r1,[r4,#0x24]
000046  4788              BLX      r1
                  |L26.72|
;;;1149   			}
;;;1150   		}
;;;1151   	}
000048  bf00              NOP      
                  |L26.74|
;;;1152   
;;;1153   	/* 处理发送缓冲区空中断 */
;;;1154   	if (USART_GetITStatus(_pUart->uart, USART_IT_TXE) != RESET)
00004a  f2407127          MOV      r1,#0x727
00004e  6820              LDR      r0,[r4,#0]
000050  f7fffffe          BL       USART_GetITStatus
000054  b308              CBZ      r0,|L26.154|
;;;1155   	{
;;;1156   		//if (_pUart->usTxRead == _pUart->usTxWrite)
;;;1157   		if (_pUart->usTxCount == 0)
000056  8aa0              LDRH     r0,[r4,#0x14]
000058  b960              CBNZ     r0,|L26.116|
;;;1158   		{
;;;1159   			/* 发送缓冲区的数据已取完时， 禁止发送缓冲区空中断 （注意：此时最后1个数据还未真正发送完毕）*/
;;;1160   			USART_ITConfig(_pUart->uart, USART_IT_TXE, DISABLE);
00005a  2200              MOVS     r2,#0
00005c  f2407127          MOV      r1,#0x727
000060  6820              LDR      r0,[r4,#0]
000062  f7fffffe          BL       USART_ITConfig
;;;1161   
;;;1162   			/* 使能数据发送完毕中断 */
;;;1163   			USART_ITConfig(_pUart->uart, USART_IT_TC, ENABLE);
000066  2201              MOVS     r2,#1
000068  f2406126          MOV      r1,#0x626
00006c  6820              LDR      r0,[r4,#0]
00006e  f7fffffe          BL       USART_ITConfig
000072  e037              B        |L26.228|
                  |L26.116|
;;;1164   		}
;;;1165   		else
;;;1166   		{
;;;1167   			/* 从发送FIFO取1个字节写入串口发送数据寄存器 */
;;;1168   			USART_SendData(_pUart->uart, _pUart->pTxBuf[_pUart->usTxRead]);
000074  8a63              LDRH     r3,[r4,#0x12]
000076  6862              LDR      r2,[r4,#4]
000078  5cd1              LDRB     r1,[r2,r3]
00007a  6820              LDR      r0,[r4,#0]
00007c  f7fffffe          BL       USART_SendData
;;;1169   			if (++_pUart->usTxRead >= _pUart->usTxBufSize)
000080  8a60              LDRH     r0,[r4,#0x12]
000082  1c40              ADDS     r0,r0,#1
000084  b280              UXTH     r0,r0
000086  8260              STRH     r0,[r4,#0x12]
000088  89a1              LDRH     r1,[r4,#0xc]
00008a  4288              CMP      r0,r1
00008c  db01              BLT      |L26.146|
;;;1170   			{
;;;1171   				_pUart->usTxRead = 0;
00008e  2000              MOVS     r0,#0
000090  8260              STRH     r0,[r4,#0x12]
                  |L26.146|
;;;1172   			}
;;;1173   			_pUart->usTxCount--;
000092  8aa0              LDRH     r0,[r4,#0x14]
000094  1e40              SUBS     r0,r0,#1
000096  82a0              STRH     r0,[r4,#0x14]
000098  e024              B        |L26.228|
                  |L26.154|
;;;1174   		}
;;;1175   
;;;1176   	}
;;;1177   	/* 数据bit位全部发送完毕的中断 */
;;;1178   	else if (USART_GetITStatus(_pUart->uart, USART_IT_TC) != RESET)
00009a  f2406126          MOV      r1,#0x626
00009e  6820              LDR      r0,[r4,#0]
0000a0  f7fffffe          BL       USART_GetITStatus
0000a4  b1f0              CBZ      r0,|L26.228|
;;;1179   	{
;;;1180   		//if (_pUart->usTxRead == _pUart->usTxWrite)
;;;1181   		if (_pUart->usTxCount == 0)
0000a6  8aa0              LDRH     r0,[r4,#0x14]
0000a8  b950              CBNZ     r0,|L26.192|
;;;1182   		{
;;;1183   			/* 如果发送FIFO的数据全部发送完毕，禁止数据发送完毕中断 */
;;;1184   			USART_ITConfig(_pUart->uart, USART_IT_TC, DISABLE);
0000aa  2200              MOVS     r2,#0
0000ac  f2406126          MOV      r1,#0x626
0000b0  6820              LDR      r0,[r4,#0]
0000b2  f7fffffe          BL       USART_ITConfig
;;;1185   
;;;1186   			/* 回调函数, 一般用来处理RS485通信，将RS485芯片设置为接收模式，避免抢占总线 */
;;;1187   			if (_pUart->SendOver)
0000b6  6a20              LDR      r0,[r4,#0x20]
0000b8  b1a0              CBZ      r0,|L26.228|
;;;1188   			{
;;;1189   				_pUart->SendOver();
0000ba  6a20              LDR      r0,[r4,#0x20]
0000bc  4780              BLX      r0
0000be  e011              B        |L26.228|
                  |L26.192|
;;;1190   			}
;;;1191   		}
;;;1192   		else
;;;1193   		{
;;;1194   			/* 正常情况下，不会进入此分支 */
;;;1195   
;;;1196   			/* 如果发送FIFO的数据还未完毕，则从发送FIFO取1个数据写入发送数据寄存器 */
;;;1197   			USART_SendData(_pUart->uart, _pUart->pTxBuf[_pUart->usTxRead]);
0000c0  8a63              LDRH     r3,[r4,#0x12]
0000c2  6862              LDR      r2,[r4,#4]
0000c4  5cd1              LDRB     r1,[r2,r3]
0000c6  6820              LDR      r0,[r4,#0]
0000c8  f7fffffe          BL       USART_SendData
;;;1198   			if (++_pUart->usTxRead >= _pUart->usTxBufSize)
0000cc  8a60              LDRH     r0,[r4,#0x12]
0000ce  1c40              ADDS     r0,r0,#1
0000d0  b280              UXTH     r0,r0
0000d2  8260              STRH     r0,[r4,#0x12]
0000d4  89a1              LDRH     r1,[r4,#0xc]
0000d6  4288              CMP      r0,r1
0000d8  db01              BLT      |L26.222|
;;;1199   			{
;;;1200   				_pUart->usTxRead = 0;
0000da  2000              MOVS     r0,#0
0000dc  8260              STRH     r0,[r4,#0x12]
                  |L26.222|
;;;1201   			}
;;;1202   			_pUart->usTxCount--;
0000de  8aa0              LDRH     r0,[r4,#0x14]
0000e0  1e40              SUBS     r0,r0,#1
0000e2  82a0              STRH     r0,[r4,#0x14]
                  |L26.228|
;;;1203   		}
;;;1204   	}
;;;1205   }
0000e4  bd70              POP      {r4-r6,pc}
;;;1206   
                          ENDP


                          AREA ||i.UartSend||, CODE, READONLY, ALIGN=1

                  UartSend PROC
;;;1002   */
;;;1003   static void UartSend(UART_T *_pUart, uint8_t *_ucaBuf, uint16_t _usLen)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1004   {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;1005   	uint16_t i;
;;;1006   	
;;;1007   #if SYSTEM_SUPPORT_OS == 1
;;;1008   	OS_CPU_SR  cpu_sr = 0;
;;;1009   #endif
;;;1010   
;;;1011   
;;;1012   	for (i = 0; i < _usLen; i++)
00000a  2500              MOVS     r5,#0
00000c  e027              B        |L27.94|
                  |L27.14|
;;;1013   	{
;;;1014   		/* 如果发送缓冲区已经满了，则等待缓冲区空 */
;;;1015   	#if 0
;;;1016   		/*
;;;1017   			在调试GPRS例程时，下面的代码出现死机，while 死循环
;;;1018   			原因： 发送第1个字节时 _pUart->usTxWrite = 1；_pUart->usTxRead = 0;
;;;1019   			将导致while(1) 无法退出
;;;1020   		*/
;;;1021   		while (1)
;;;1022   		{
;;;1023   			uint16_t usRead;
;;;1024   
;;;1025   			DISABLE_INT();
;;;1026   			usRead = _pUart->usTxRead;
;;;1027   			ENABLE_INT();
;;;1028   
;;;1029   			if (++usRead >= _pUart->usTxBufSize)
;;;1030   			{
;;;1031   				usRead = 0;
;;;1032   			}
;;;1033   
;;;1034   			if (usRead != _pUart->usTxWrite)
;;;1035   			{
;;;1036   				break;
;;;1037   			}
;;;1038   		}
;;;1039   	#else
;;;1040   		/* 当 _pUart->usTxBufSize == 1 时, 下面的函数会死掉(待完善) */
;;;1041   		while (1)
00000e  e00c              B        |L27.42|
                  |L27.16|
;;;1042   		{
;;;1043   			uint16_t usCount;
;;;1044   
;;;1045   			DISABLE_INT();
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       __set_PRIMASK
;;;1046   			usCount = _pUart->usTxCount;
000016  f8b48014          LDRH     r8,[r4,#0x14]
;;;1047   			ENABLE_INT();
00001a  2000              MOVS     r0,#0
00001c  f7fffffe          BL       __set_PRIMASK
;;;1048   
;;;1049   			if (usCount < _pUart->usTxBufSize)
000020  89a0              LDRH     r0,[r4,#0xc]
000022  4540              CMP      r0,r8
000024  dd00              BLE      |L27.40|
;;;1050   			{
;;;1051   				break;
000026  e001              B        |L27.44|
                  |L27.40|
;;;1052   			}
;;;1053   		}
000028  bf00              NOP      
                  |L27.42|
00002a  e7f1              B        |L27.16|
                  |L27.44|
00002c  bf00              NOP                            ;1051
;;;1054   	#endif
;;;1055   
;;;1056   		/* 将新数据填入发送缓冲区 */
;;;1057   		_pUart->pTxBuf[_pUart->usTxWrite] = _ucaBuf[i];
00002e  5d70              LDRB     r0,[r6,r5]
000030  8a22              LDRH     r2,[r4,#0x10]
000032  6861              LDR      r1,[r4,#4]
000034  5488              STRB     r0,[r1,r2]
;;;1058   
;;;1059   		DISABLE_INT();
000036  2001              MOVS     r0,#1
000038  f7fffffe          BL       __set_PRIMASK
;;;1060   		if (++_pUart->usTxWrite >= _pUart->usTxBufSize)
00003c  8a20              LDRH     r0,[r4,#0x10]
00003e  1c40              ADDS     r0,r0,#1
000040  b280              UXTH     r0,r0
000042  8220              STRH     r0,[r4,#0x10]
000044  89a1              LDRH     r1,[r4,#0xc]
000046  4288              CMP      r0,r1
000048  db01              BLT      |L27.78|
;;;1061   		{
;;;1062   			_pUart->usTxWrite = 0;
00004a  2000              MOVS     r0,#0
00004c  8220              STRH     r0,[r4,#0x10]
                  |L27.78|
;;;1063   		}
;;;1064   		_pUart->usTxCount++;
00004e  8aa0              LDRH     r0,[r4,#0x14]
000050  1c40              ADDS     r0,r0,#1
000052  82a0              STRH     r0,[r4,#0x14]
;;;1065   		ENABLE_INT();
000054  2000              MOVS     r0,#0
000056  f7fffffe          BL       __set_PRIMASK
00005a  1c68              ADDS     r0,r5,#1              ;1012
00005c  b285              UXTH     r5,r0                 ;1012
                  |L27.94|
00005e  42bd              CMP      r5,r7                 ;1012
000060  dbd5              BLT      |L27.14|
;;;1066   	}
;;;1067   
;;;1068   	USART_ITConfig(_pUart->uart, USART_IT_TXE, ENABLE);
000062  2201              MOVS     r2,#1
000064  f2407127          MOV      r1,#0x727
000068  6820              LDR      r0,[r4,#0]
00006a  f7fffffe          BL       USART_ITConfig
;;;1069   }
00006e  e8bd81f0          POP      {r4-r8,pc}
;;;1070   
                          ENDP


                          AREA ||i.UartVarInit||, CODE, READONLY, ALIGN=2

                  UartVarInit PROC
;;;594    */
;;;595    static void UartVarInit(void)
000000  4816              LDR      r0,|L28.92|
;;;596    {
;;;597    #if UART1_FIFO_EN == 1
;;;598    	g_tUart1.uart = USART1;						/* STM32 串口设备 */
000002  4917              LDR      r1,|L28.96|
000004  6008              STR      r0,[r1,#0]  ; g_tUart1
;;;599    	g_tUart1.pTxBuf = g_TxBuf1;					/* 发送缓冲区指针 */
000006  4817              LDR      r0,|L28.100|
000008  6048              STR      r0,[r1,#4]  ; g_tUart1
;;;600    	g_tUart1.pRxBuf = g_RxBuf1;					/* 接收缓冲区指针 */
00000a  4817              LDR      r0,|L28.104|
00000c  6088              STR      r0,[r1,#8]  ; g_tUart1
;;;601    	g_tUart1.usTxBufSize = UART1_TX_BUF_SIZE;	/* 发送缓冲区大小 */
00000e  f44f6080          MOV      r0,#0x400
000012  8188              STRH     r0,[r1,#0xc]
;;;602    	g_tUart1.usRxBufSize = UART1_RX_BUF_SIZE;	/* 接收缓冲区大小 */
000014  81c8              STRH     r0,[r1,#0xe]
;;;603    	g_tUart1.usTxWrite = 0;						/* 发送FIFO写索引 */
000016  2000              MOVS     r0,#0
000018  8208              STRH     r0,[r1,#0x10]
;;;604    	g_tUart1.usTxRead = 0;						/* 发送FIFO读索引 */
00001a  8248              STRH     r0,[r1,#0x12]
;;;605    	g_tUart1.usRxWrite = 0;						/* 接收FIFO写索引 */
00001c  82c8              STRH     r0,[r1,#0x16]
;;;606    	g_tUart1.usRxRead = 0;						/* 接收FIFO读索引 */
00001e  8308              STRH     r0,[r1,#0x18]
;;;607    	g_tUart1.usRxCount = 0;						/* 接收到的新数据个数 */
000020  8348              STRH     r0,[r1,#0x1a]
;;;608    	g_tUart1.usTxCount = 0;						/* 待发送的数据个数 */
000022  8288              STRH     r0,[r1,#0x14]
;;;609    	g_tUart1.SendBefor = 0;						/* 发送数据前的回调函数 */
000024  61c8              STR      r0,[r1,#0x1c]  ; g_tUart1
;;;610    	g_tUart1.SendOver = 0;						/* 发送完毕后的回调函数 */
000026  6208              STR      r0,[r1,#0x20]  ; g_tUart1
;;;611    	g_tUart1.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
000028  6248              STR      r0,[r1,#0x24]  ; g_tUart1
;;;612    #endif
;;;613    
;;;614    #if UART2_FIFO_EN == 1
;;;615    	g_tUart2.uart = USART2;						/* STM32 串口设备 */
;;;616    	g_tUart2.pTxBuf = g_TxBuf2;					/* 发送缓冲区指针 */
;;;617    	g_tUart2.pRxBuf = g_RxBuf2;					/* 接收缓冲区指针 */
;;;618    	g_tUart2.usTxBufSize = UART2_TX_BUF_SIZE;	/* 发送缓冲区大小 */
;;;619    	g_tUart2.usRxBufSize = UART2_RX_BUF_SIZE;	/* 接收缓冲区大小 */
;;;620    	g_tUart2.usTxWrite = 0;						/* 发送FIFO写索引 */
;;;621    	g_tUart2.usTxRead = 0;						/* 发送FIFO读索引 */
;;;622    	g_tUart2.usRxWrite = 0;						/* 接收FIFO写索引 */
;;;623    	g_tUart2.usRxRead = 0;						/* 接收FIFO读索引 */
;;;624    	g_tUart2.usRxCount = 0;						/* 接收到的新数据个数 */
;;;625    	g_tUart2.usTxCount = 0;						/* 待发送的数据个数 */
;;;626    	g_tUart2.SendBefor = 0;						/* 发送数据前的回调函数 */
;;;627    	g_tUart2.SendOver = 0;						/* 发送完毕后的回调函数 */
;;;628    	g_tUart2.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
;;;629    #endif
;;;630    
;;;631    #if UART3_FIFO_EN == 1
;;;632    	g_tUart3.uart = USART3;						/* STM32 串口设备 */
00002a  4810              LDR      r0,|L28.108|
00002c  4910              LDR      r1,|L28.112|
00002e  6008              STR      r0,[r1,#0]  ; g_tUart3
;;;633    	g_tUart3.pTxBuf = g_TxBuf3;					/* 发送缓冲区指针 */
000030  4810              LDR      r0,|L28.116|
000032  6048              STR      r0,[r1,#4]  ; g_tUart3
;;;634    	g_tUart3.pRxBuf = g_RxBuf3;					/* 接收缓冲区指针 */
000034  4810              LDR      r0,|L28.120|
000036  6088              STR      r0,[r1,#8]  ; g_tUart3
;;;635    	g_tUart3.usTxBufSize = UART3_TX_BUF_SIZE;	/* 发送缓冲区大小 */
000038  f44f6080          MOV      r0,#0x400
00003c  8188              STRH     r0,[r1,#0xc]
;;;636    	g_tUart3.usRxBufSize = UART3_RX_BUF_SIZE;	/* 接收缓冲区大小 */
00003e  81c8              STRH     r0,[r1,#0xe]
;;;637    	g_tUart3.usTxWrite = 0;						/* 发送FIFO写索引 */
000040  2000              MOVS     r0,#0
000042  8208              STRH     r0,[r1,#0x10]
;;;638    	g_tUart3.usTxRead = 0;						/* 发送FIFO读索引 */
000044  8248              STRH     r0,[r1,#0x12]
;;;639    	g_tUart3.usRxWrite = 0;						/* 接收FIFO写索引 */
000046  82c8              STRH     r0,[r1,#0x16]
;;;640    	g_tUart3.usRxRead = 0;						/* 接收FIFO读索引 */
000048  8308              STRH     r0,[r1,#0x18]
;;;641    	g_tUart3.usRxCount = 0;						/* 接收到的新数据个数 */
00004a  8348              STRH     r0,[r1,#0x1a]
;;;642    	g_tUart3.usTxCount = 0;						/* 待发送的数据个数 */
00004c  8288              STRH     r0,[r1,#0x14]
;;;643    	g_tUart3.SendBefor = RS485_SendBefor;		/* 发送数据前的回调函数 */
00004e  480b              LDR      r0,|L28.124|
000050  61c8              STR      r0,[r1,#0x1c]  ; g_tUart3
;;;644    	g_tUart3.SendOver = RS485_SendOver;			/* 发送完毕后的回调函数 */
000052  480b              LDR      r0,|L28.128|
000054  6208              STR      r0,[r1,#0x20]  ; g_tUart3
;;;645    	g_tUart3.ReciveNew = RS485_ReciveNew;		/* 接收到新数据后的回调函数 */
000056  480b              LDR      r0,|L28.132|
000058  6248              STR      r0,[r1,#0x24]  ; g_tUart3
;;;646    #endif
;;;647    
;;;648    #if UART4_FIFO_EN == 1
;;;649    	g_tUart4.uart = UART4;						/* STM32 串口设备 */
;;;650    	g_tUart4.pTxBuf = g_TxBuf4;					/* 发送缓冲区指针 */
;;;651    	g_tUart4.pRxBuf = g_RxBuf4;					/* 接收缓冲区指针 */
;;;652    	g_tUart4.usTxBufSize = UART4_TX_BUF_SIZE;	/* 发送缓冲区大小 */
;;;653    	g_tUart4.usRxBufSize = UART4_RX_BUF_SIZE;	/* 接收缓冲区大小 */
;;;654    	g_tUart4.usTxWrite = 0;						/* 发送FIFO写索引 */
;;;655    	g_tUart4.usTxRead = 0;						/* 发送FIFO读索引 */
;;;656    	g_tUart4.usRxWrite = 0;						/* 接收FIFO写索引 */
;;;657    	g_tUart4.usRxRead = 0;						/* 接收FIFO读索引 */
;;;658    	g_tUart4.usRxCount = 0;						/* 接收到的新数据个数 */
;;;659    	g_tUart4.usTxCount = 0;						/* 待发送的数据个数 */
;;;660     	g_tUart4.SendBefor = 0;						/* 发送数据前的回调函数 */
;;;661     	g_tUart4.SendOver = 0;		    			/* 发送完毕后的回调函数 */
;;;662    	g_tUart4.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
;;;663    #endif
;;;664    
;;;665    #if UART5_FIFO_EN == 1
;;;666    	g_tUart5.uart = UART5;						/* STM32 串口设备 */
;;;667    	g_tUart5.pTxBuf = g_TxBuf5;					/* 发送缓冲区指针 */
;;;668    	g_tUart5.pRxBuf = g_RxBuf5;					/* 接收缓冲区指针 */
;;;669    	g_tUart5.usTxBufSize = UART5_TX_BUF_SIZE;	/* 发送缓冲区大小 */
;;;670    	g_tUart5.usRxBufSize = UART5_RX_BUF_SIZE;	/* 接收缓冲区大小 */
;;;671    	g_tUart5.usTxWrite = 0;						/* 发送FIFO写索引 */
;;;672    	g_tUart5.usTxRead = 0;						/* 发送FIFO读索引 */
;;;673    	g_tUart5.usRxWrite = 0;						/* 接收FIFO写索引 */
;;;674    	g_tUart5.usRxRead = 0;						/* 接收FIFO读索引 */
;;;675    	g_tUart5.usRxCount = 0;						/* 接收到的新数据个数 */
;;;676    	g_tUart5.usTxCount = 0;						/* 待发送的数据个数 */
;;;677    	g_tUart5.SendBefor = 0;						/* 发送数据前的回调函数 */
;;;678    	g_tUart5.SendOver = 0;						/* 发送完毕后的回调函数 */
;;;679    	g_tUart5.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
;;;680    #endif
;;;681    
;;;682    
;;;683    #if UART6_FIFO_EN == 1
;;;684    	g_tUart6.uart = USART6;						/* STM32 串口设备 */
;;;685    	g_tUart6.pTxBuf = g_TxBuf6;					/* 发送缓冲区指针 */
;;;686    	g_tUart6.pRxBuf = g_RxBuf6;					/* 接收缓冲区指针 */
;;;687    	g_tUart6.usTxBufSize = UART6_TX_BUF_SIZE;	/* 发送缓冲区大小 */
;;;688    	g_tUart6.usRxBufSize = UART6_RX_BUF_SIZE;	/* 接收缓冲区大小 */
;;;689    	g_tUart6.usTxWrite = 0;						/* 发送FIFO写索引 */
;;;690    	g_tUart6.usTxRead = 0;						/* 发送FIFO读索引 */
;;;691    	g_tUart6.usRxWrite = 0;						/* 接收FIFO写索引 */
;;;692    	g_tUart6.usRxRead = 0;						/* 接收FIFO读索引 */
;;;693    	g_tUart6.usRxCount = 0;						/* 接收到的新数据个数 */
;;;694    	g_tUart6.usTxCount = 0;						/* 待发送的数据个数 */
;;;695    	g_tUart6.SendBefor = 0;						/* 发送数据前的回调函数 */
;;;696    	g_tUart6.SendOver = 0;						/* 发送完毕后的回调函数 */
;;;697    	g_tUart6.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
;;;698    #endif
;;;699    }
00005a  4770              BX       lr
;;;700    
                          ENDP

                  |L28.92|
                          DCD      0x40013800
                  |L28.96|
                          DCD      g_tUart1
                  |L28.100|
                          DCD      g_TxBuf1
                  |L28.104|
                          DCD      g_RxBuf1
                  |L28.108|
                          DCD      0x40004800
                  |L28.112|
                          DCD      g_tUart3
                  |L28.116|
                          DCD      g_TxBuf3
                  |L28.120|
                          DCD      g_RxBuf3
                  |L28.124|
                          DCD      RS485_SendBefor
                  |L28.128|
                          DCD      RS485_SendOver
                  |L28.132|
                          DCD      RS485_ReciveNew

                          AREA ||i.__set_PRIMASK||, CODE, READONLY, ALIGN=1

                  __set_PRIMASK PROC
;;;986     */
;;;987    static __INLINE void __set_PRIMASK(uint32_t priMask)
000000  f3808810          MSR      PRIMASK,r0
;;;988    {
;;;989      register uint32_t __regPriMask         __ASM("primask");
;;;990      __regPriMask = (priMask);
;;;991    }
000004  4770              BX       lr
;;;992    
                          ENDP


                          AREA ||i._sys_exit||, CODE, READONLY, ALIGN=1

                  _sys_exit PROC
;;;1340   //定义_sys_exit()以避免使用半主机模式    
;;;1341   _sys_exit(int x) 
000000  4601              MOV      r1,r0
;;;1342   { 
;;;1343   	x = x; 
000002  bf00              NOP      
;;;1344   } 
000004  4770              BX       lr
;;;1345   //重定义fputc函数 
                          ENDP


                          AREA ||i.bsp_InitRS485ADD||, CODE, READONLY, ALIGN=2

                  bsp_InitRS485ADD PROC
;;;92     
;;;93     void bsp_InitRS485ADD(void)
000000  b508              PUSH     {r3,lr}
;;;94     {
;;;95     	GPIO_InitTypeDef GPIO_InitStructure;
;;;96     
;;;97     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD|RCC_APB2Periph_GPIOE, ENABLE);
000002  2101              MOVS     r1,#1
000004  2060              MOVS     r0,#0x60
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;98     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00000a  2003              MOVS     r0,#3
00000c  f88d0002          STRB     r0,[sp,#2]
;;;99     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;	/* 上拉输入模式 */
000010  2048              MOVS     r0,#0x48
000012  f88d0003          STRB     r0,[sp,#3]
;;;100    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8|GPIO_Pin_9|GPIO_Pin_10|GPIO_Pin_11;
000016  f44f6070          MOV      r0,#0xf00
00001a  f8ad0000          STRH     r0,[sp,#0]
;;;101    	GPIO_Init(GPIOD, &GPIO_InitStructure);
00001e  4669              MOV      r1,sp
000020  4805              LDR      r0,|L31.56|
000022  f7fffffe          BL       GPIO_Init
;;;102    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8|GPIO_Pin_9|GPIO_Pin_10|GPIO_Pin_11;
000026  f44f6070          MOV      r0,#0xf00
00002a  f8ad0000          STRH     r0,[sp,#0]
;;;103    	GPIO_Init(GPIOE, &GPIO_InitStructure);
00002e  4669              MOV      r1,sp
000030  4802              LDR      r0,|L31.60|
000032  f7fffffe          BL       GPIO_Init
;;;104    }
000036  bd08              POP      {r3,pc}
;;;105    
                          ENDP

                  |L31.56|
                          DCD      0x40011400
                  |L31.60|
                          DCD      0x40011800

                          AREA ||i.bsp_InitUart||, CODE, READONLY, ALIGN=1

                  bsp_InitUart PROC
;;;127    */
;;;128    void bsp_InitUart(void)
000000  b510              PUSH     {r4,lr}
;;;129    {
;;;130    	UartVarInit();		/* 必须先初始化全局变量,再配置硬件 */
000002  f7fffffe          BL       UartVarInit
;;;131    
;;;132    	InitHardUart();		/* 配置串口的硬件参数(波特率等) */
000006  f7fffffe          BL       InitHardUart
;;;133    
;;;134    	RS485_InitTXE();	/* 配置RS485芯片的发送使能硬件，配置为推挽输出 */
00000a  f7fffffe          BL       RS485_InitTXE
;;;135    	//bsp_InitRS485ADD();
;;;136    	ConfigUartNVIC();	/* 配置串口中断 */
00000e  f7fffffe          BL       ConfigUartNVIC
;;;137    }
000012  bd10              POP      {r4,pc}
;;;138    
                          ENDP


                          AREA ||i.bsp_Set485Baud||, CODE, READONLY, ALIGN=2

                  bsp_Set485Baud PROC
;;;449    */
;;;450    void bsp_Set485Baud(uint32_t _baud)
000000  b51f              PUSH     {r0-r4,lr}
;;;451    {
000002  4604              MOV      r4,r0
;;;452    	USART_InitTypeDef USART_InitStructure;
;;;453    
;;;454    	/* 第2步： 配置串口硬件参数 */
;;;455    	USART_InitStructure.USART_BaudRate = _baud;	/* 波特率 */
000004  9400              STR      r4,[sp,#0]
;;;456    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000006  2000              MOVS     r0,#0
000008  f8ad0004          STRH     r0,[sp,#4]
;;;457    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
00000c  f8ad0006          STRH     r0,[sp,#6]
;;;458    	USART_InitStructure.USART_Parity = USART_Parity_No ;
000010  f8ad0008          STRH     r0,[sp,#8]
;;;459    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000014  f8ad000c          STRH     r0,[sp,#0xc]
;;;460    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000018  200c              MOVS     r0,#0xc
00001a  f8ad000a          STRH     r0,[sp,#0xa]
;;;461    	//USART_Init(USART3, &USART_InitStructure);
;;;462    	USART_Init(UART4, &USART_InitStructure);
00001e  4669              MOV      r1,sp
000020  4801              LDR      r0,|L33.40|
000022  f7fffffe          BL       USART_Init
;;;463    }
000026  bd1f              POP      {r0-r4,pc}
;;;464    
                          ENDP

                  |L33.40|
                          DCD      0x40004c00

                          AREA ||i.bsp_SetUart1Baud||, CODE, READONLY, ALIGN=2

                  bsp_SetUart1Baud PROC
;;;380    */
;;;381    void bsp_SetUart1Baud(uint32_t _baud)
000000  b51f              PUSH     {r0-r4,lr}
;;;382    {
000002  4604              MOV      r4,r0
;;;383    	USART_InitTypeDef USART_InitStructure;
;;;384    
;;;385    	/* 第2步： 配置串口硬件参数 */
;;;386    	USART_InitStructure.USART_BaudRate = _baud;	/* 波特率 */
000004  9400              STR      r4,[sp,#0]
;;;387    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000006  2000              MOVS     r0,#0
000008  f8ad0004          STRH     r0,[sp,#4]
;;;388    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
00000c  f8ad0006          STRH     r0,[sp,#6]
;;;389    	USART_InitStructure.USART_Parity = USART_Parity_No ;
000010  f8ad0008          STRH     r0,[sp,#8]
;;;390    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000014  f8ad000c          STRH     r0,[sp,#0xc]
;;;391    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000018  200c              MOVS     r0,#0xc
00001a  f8ad000a          STRH     r0,[sp,#0xa]
;;;392    	USART_Init(USART2, &USART_InitStructure);
00001e  4669              MOV      r1,sp
000020  4801              LDR      r0,|L34.40|
000022  f7fffffe          BL       USART_Init
;;;393    }
000026  bd1f              POP      {r0-r4,pc}
;;;394    
                          ENDP

                  |L34.40|
                          DCD      0x40004400

                          AREA ||i.bsp_SetUart2Baud||, CODE, READONLY, ALIGN=2

                  bsp_SetUart2Baud PROC
;;;402    */
;;;403    void bsp_SetUart2Baud(uint32_t _baud)
000000  b51f              PUSH     {r0-r4,lr}
;;;404    {
000002  4604              MOV      r4,r0
;;;405    	USART_InitTypeDef USART_InitStructure;
;;;406    
;;;407    	/* 第2步： 配置串口硬件参数 */
;;;408    	USART_InitStructure.USART_BaudRate = _baud;	/* 波特率 */
000004  9400              STR      r4,[sp,#0]
;;;409    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000006  2000              MOVS     r0,#0
000008  f8ad0004          STRH     r0,[sp,#4]
;;;410    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
00000c  f8ad0006          STRH     r0,[sp,#6]
;;;411    	USART_InitStructure.USART_Parity = USART_Parity_No ;
000010  f8ad0008          STRH     r0,[sp,#8]
;;;412    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000014  f8ad000c          STRH     r0,[sp,#0xc]
;;;413    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000018  200c              MOVS     r0,#0xc
00001a  f8ad000a          STRH     r0,[sp,#0xa]
;;;414    	USART_Init(USART2, &USART_InitStructure);
00001e  4669              MOV      r1,sp
000020  4801              LDR      r0,|L35.40|
000022  f7fffffe          BL       USART_Init
;;;415    }
000026  bd1f              POP      {r0-r4,pc}
;;;416    
                          ENDP

                  |L35.40|
                          DCD      0x40004400

                          AREA ||i.comClearRxFifo||, CODE, READONLY, ALIGN=1

                  comClearRxFifo PROC
;;;357    */
;;;358    void comClearRxFifo(COM_PORT_E _ucPort)
000000  b500              PUSH     {lr}
;;;359    {
000002  4603              MOV      r3,r0
;;;360    	UART_T *pUart;
;;;361    
;;;362    	pUart = ComToUart(_ucPort);
000004  4618              MOV      r0,r3
000006  f7fffffe          BL       ComToUart
00000a  4602              MOV      r2,r0
;;;363    	if (pUart == 0)
00000c  b902              CBNZ     r2,|L36.16|
                  |L36.14|
;;;364    	{
;;;365    		return;
;;;366    	}
;;;367    
;;;368    	pUart->usRxWrite = 0;
;;;369    	pUart->usRxRead = 0;
;;;370    	pUart->usRxCount = 0;
;;;371    }
00000e  bd00              POP      {pc}
                  |L36.16|
000010  2000              MOVS     r0,#0                 ;368
000012  82d0              STRH     r0,[r2,#0x16]         ;368
000014  8310              STRH     r0,[r2,#0x18]         ;369
000016  8350              STRH     r0,[r2,#0x1a]         ;370
000018  bf00              NOP      
00001a  e7f8              B        |L36.14|
;;;372    
                          ENDP


                          AREA ||i.comClearTxFifo||, CODE, READONLY, ALIGN=1

                  comClearTxFifo PROC
;;;334    */
;;;335    void comClearTxFifo(COM_PORT_E _ucPort)
000000  b500              PUSH     {lr}
;;;336    {
000002  4603              MOV      r3,r0
;;;337    	UART_T *pUart;
;;;338    
;;;339    	pUart = ComToUart(_ucPort);
000004  4618              MOV      r0,r3
000006  f7fffffe          BL       ComToUart
00000a  4602              MOV      r2,r0
;;;340    	if (pUart == 0)
00000c  b902              CBNZ     r2,|L37.16|
                  |L37.14|
;;;341    	{
;;;342    		return;
;;;343    	}
;;;344    
;;;345    	pUart->usTxWrite = 0;
;;;346    	pUart->usTxRead = 0;
;;;347    	pUart->usTxCount = 0;
;;;348    }
00000e  bd00              POP      {pc}
                  |L37.16|
000010  2000              MOVS     r0,#0                 ;345
000012  8210              STRH     r0,[r2,#0x10]         ;345
000014  8250              STRH     r0,[r2,#0x12]         ;346
000016  8290              STRH     r0,[r2,#0x14]         ;347
000018  bf00              NOP      
00001a  e7f8              B        |L37.14|
;;;349    
                          ENDP


                          AREA ||i.comGetChar||, CODE, READONLY, ALIGN=1

                  comGetChar PROC
;;;246    */
;;;247    uint8_t comGetChar(COM_PORT_E _ucPort, uint8_t *_pByte)
000000  b570              PUSH     {r4-r6,lr}
;;;248    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;249    	UART_T *pUart;
;;;250    
;;;251    	pUart = ComToUart(_ucPort);
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       ComToUart
00000c  4604              MOV      r4,r0
;;;252    	if (pUart == 0)
00000e  b90c              CBNZ     r4,|L38.20|
;;;253    	{
;;;254    		return 0;
000010  2000              MOVS     r0,#0
                  |L38.18|
;;;255    	}
;;;256    
;;;257    	return UartGetChar(pUart, _pByte);
;;;258    }
000012  bd70              POP      {r4-r6,pc}
                  |L38.20|
000014  4631              MOV      r1,r6                 ;257
000016  4620              MOV      r0,r4                 ;257
000018  f7fffffe          BL       UartGetChar
00001c  e7f9              B        |L38.18|
;;;259    
                          ENDP


                          AREA ||i.comSendBuf||, CODE, READONLY, ALIGN=1

                  comSendBuf PROC
;;;205    */
;;;206    void comSendBuf(COM_PORT_E _ucPort, uint8_t *_ucaBuf, uint16_t _usLen)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;207    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;208    	UART_T *pUart;
;;;209    
;;;210    	pUart = ComToUart(_ucPort);
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       ComToUart
000010  4604              MOV      r4,r0
;;;211    	if (pUart == 0)
000012  b90c              CBNZ     r4,|L39.24|
                  |L39.20|
;;;212    	{
;;;213    		return;
;;;214    	}
;;;215    
;;;216    	if (pUart->SendBefor != 0)
;;;217    	{
;;;218    		pUart->SendBefor();		/* 如果是RS485通信，可以在这个函数中将RS485设置为发送模式 */
;;;219    	}
;;;220    
;;;221    	UartSend(pUart, _ucaBuf, _usLen);
;;;222    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L39.24|
000018  69e0              LDR      r0,[r4,#0x1c]         ;216
00001a  b108              CBZ      r0,|L39.32|
00001c  69e0              LDR      r0,[r4,#0x1c]         ;218
00001e  4780              BLX      r0                    ;218
                  |L39.32|
000020  463a              MOV      r2,r7                 ;221
000022  4631              MOV      r1,r6                 ;221
000024  4620              MOV      r0,r4                 ;221
000026  f7fffffe          BL       UartSend
00002a  bf00              NOP      
00002c  e7f2              B        |L39.20|
;;;223    
                          ENDP


                          AREA ||i.comSendChar||, CODE, READONLY, ALIGN=1

                  comSendChar PROC
;;;232    */
;;;233    void comSendChar(COM_PORT_E _ucPort, uint8_t _ucByte)
000000  b513              PUSH     {r0,r1,r4,lr}
;;;234    {
000002  4604              MOV      r4,r0
;;;235    	comSendBuf(_ucPort, &_ucByte, 1);
000004  2201              MOVS     r2,#1
000006  a901              ADD      r1,sp,#4
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       comSendBuf
;;;236    }
00000e  bd1c              POP      {r2-r4,pc}
;;;237    
                          ENDP


                          AREA ||i.fputc||, CODE, READONLY, ALIGN=2

                  fputc PROC
;;;1345   //重定义fputc函数 
;;;1346   int fputc(int ch, FILE *f)
000000  bf00              NOP      
                  |L41.2|
;;;1347   {      
;;;1348   	while((USART1->SR&0X40)==0);//循环发送,直到发送完毕   
000002  4a05              LDR      r2,|L41.24|
000004  8812              LDRH     r2,[r2,#0]
000006  f0020240          AND      r2,r2,#0x40
00000a  2a00              CMP      r2,#0
00000c  d0f9              BEQ      |L41.2|
;;;1349       USART1->DR = (u8) ch;      
00000e  b2c2              UXTB     r2,r0
000010  4b01              LDR      r3,|L41.24|
000012  1d1b              ADDS     r3,r3,#4
000014  801a              STRH     r2,[r3,#0]
;;;1350   	return ch;
;;;1351   }
000016  4770              BX       lr
;;;1352   #endif 
                          ENDP

                  |L41.24|
                          DCD      0x40013800

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  PBusDat
                          %        16
                  RS485Dat
                          %        10
                  g_SerialDat
                          %        34
                  g_tUart1
                          %        40
                  g_TxBuf1
                          %        1024
                  g_RxBuf1
                          %        1024
                  g_tUart3
                          %        40
                  g_TxBuf3
                          %        1024
                  g_RxBuf3
                          %        1024

                          AREA ||.data||, DATA, ALIGN=2

                  PBus_Count
000000  00                DCB      0x00
                  RS485_Count
000001  00                DCB      0x00
                  g_Serial_Count
000002  0000              DCB      0x00,0x00
                  __stdout
                          DCD      0x00000000
