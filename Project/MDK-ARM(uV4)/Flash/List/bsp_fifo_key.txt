; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_fifo_key.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_fifo_key.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User -I"C:\Users\xuan5\Desktop\JOSONG-XS03 V3.0\Project\MDK-ARM(uV4)\RTE" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=521 -D_RTE_ -DSTM32F10X_MD -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=.\flash\obj\bsp_fifo_key.crf ..\..\User\bsp\bsp_fifo_key.c]
                          THUMB

                          AREA ||i.IsKeyDown1||, CODE, READONLY, ALIGN=2

                  IsKeyDown1 PROC
;;;76     */
;;;77     static uint8_t IsKeyDown1(void) {if ((GPIO_PORT_K1->IDR & GPIO_PIN_K1) == 0) return 1;else return 0;}
000000  4804              LDR      r0,|L1.20|
000002  6880              LDR      r0,[r0,#8]
000004  f0000001          AND      r0,r0,#1
000008  b908              CBNZ     r0,|L1.14|
00000a  2001              MOVS     r0,#1
                  |L1.12|
00000c  4770              BX       lr
                  |L1.14|
00000e  2000              MOVS     r0,#0
000010  e7fc              B        |L1.12|
;;;78     static uint8_t IsKeyDown2(void) {if ((GPIO_PORT_K2->IDR & GPIO_PIN_K2) == 0) return 1;else return 0;}
                          ENDP

000012  0000              DCW      0x0000
                  |L1.20|
                          DCD      0x40011000

                          AREA ||i.IsKeyDown2||, CODE, READONLY, ALIGN=2

                  IsKeyDown2 PROC
;;;77     static uint8_t IsKeyDown1(void) {if ((GPIO_PORT_K1->IDR & GPIO_PIN_K1) == 0) return 1;else return 0;}
;;;78     static uint8_t IsKeyDown2(void) {if ((GPIO_PORT_K2->IDR & GPIO_PIN_K2) == 0) return 1;else return 0;}
000000  4804              LDR      r0,|L2.20|
000002  6880              LDR      r0,[r0,#8]
000004  f4004000          AND      r0,r0,#0x8000
000008  b908              CBNZ     r0,|L2.14|
00000a  2001              MOVS     r0,#1
                  |L2.12|
00000c  4770              BX       lr
                  |L2.14|
00000e  2000              MOVS     r0,#0
000010  e7fc              B        |L2.12|
;;;79     static uint8_t IsKeyDown3(void) {if ((GPIO_PORT_K3->IDR & GPIO_PIN_K3) == 0) return 1;else return 0;}
                          ENDP

000012  0000              DCW      0x0000
                  |L2.20|
                          DCD      0x40011000

                          AREA ||i.IsKeyDown3||, CODE, READONLY, ALIGN=2

                  IsKeyDown3 PROC
;;;78     static uint8_t IsKeyDown2(void) {if ((GPIO_PORT_K2->IDR & GPIO_PIN_K2) == 0) return 1;else return 0;}
;;;79     static uint8_t IsKeyDown3(void) {if ((GPIO_PORT_K3->IDR & GPIO_PIN_K3) == 0) return 1;else return 0;}
000000  4804              LDR      r0,|L3.20|
000002  6880              LDR      r0,[r0,#8]
000004  f4004080          AND      r0,r0,#0x4000
000008  b908              CBNZ     r0,|L3.14|
00000a  2001              MOVS     r0,#1
                  |L3.12|
00000c  4770              BX       lr
                  |L3.14|
00000e  2000              MOVS     r0,#0
000010  e7fc              B        |L3.12|
;;;80     static uint8_t IsKeyDown4(void) {if ((GPIO_PORT_K4->IDR & GPIO_PIN_K4) == 0) return 1;else return 0;}
                          ENDP

000012  0000              DCW      0x0000
                  |L3.20|
                          DCD      0x40011000

                          AREA ||i.IsKeyDown4||, CODE, READONLY, ALIGN=2

                  IsKeyDown4 PROC
;;;79     static uint8_t IsKeyDown3(void) {if ((GPIO_PORT_K3->IDR & GPIO_PIN_K3) == 0) return 1;else return 0;}
;;;80     static uint8_t IsKeyDown4(void) {if ((GPIO_PORT_K4->IDR & GPIO_PIN_K4) == 0) return 1;else return 0;}
000000  4804              LDR      r0,|L4.20|
000002  6880              LDR      r0,[r0,#8]
000004  f4005000          AND      r0,r0,#0x2000
000008  b908              CBNZ     r0,|L4.14|
00000a  2001              MOVS     r0,#1
                  |L4.12|
00000c  4770              BX       lr
                  |L4.14|
00000e  2000              MOVS     r0,#0
000010  e7fc              B        |L4.12|
;;;81     
                          ENDP

000012  0000              DCW      0x0000
                  |L4.20|
                          DCD      0x40011000

                          AREA ||i.bsp_ClearKey||, CODE, READONLY, ALIGN=2

                  bsp_ClearKey PROC
;;;208    */
;;;209    void bsp_ClearKey(void)
000000  4802              LDR      r0,|L5.12|
;;;210    {
;;;211    	s_tKey.Read = s_tKey.Write;
000002  7940              LDRB     r0,[r0,#5]  ; s_tKey
000004  4901              LDR      r1,|L5.12|
000006  7108              STRB     r0,[r1,#4]
;;;212    }
000008  4770              BX       lr
;;;213    
                          ENDP

00000a  0000              DCW      0x0000
                  |L5.12|
                          DCD      s_tKey

                          AREA ||i.bsp_DetectKey||, CODE, READONLY, ALIGN=2

                  bsp_DetectKey PROC
;;;289    */
;;;290    static void bsp_DetectKey(uint8_t i)
000000  b570              PUSH     {r4-r6,lr}
;;;291    {
000002  4605              MOV      r5,r0
;;;292    	KEY_T *pBtn;
;;;293    
;;;294    	/*
;;;295    		如果没有初始化按键函数，则报错
;;;296    		if (s_tBtn[i].IsKeyDownFunc == 0)
;;;297    		{
;;;298    			printf("Fault : DetectButton(), s_tBtn[i].IsKeyDownFunc undefine");
;;;299    		}
;;;300    	*/
;;;301    
;;;302    	pBtn = &s_tBtn[i];
000004  4830              LDR      r0,|L6.200|
000006  eb001405          ADD      r4,r0,r5,LSL #4
;;;303    	if (pBtn->IsKeyDownFunc())
00000a  6820              LDR      r0,[r4,#0]
00000c  4780              BLX      r0
00000e  2800              CMP      r0,#0
000010  d03e              BEQ      |L6.144|
;;;304    	{
;;;305    		if (pBtn->Count < KEY_FILTER_TIME)
000012  7920              LDRB     r0,[r4,#4]
000014  2805              CMP      r0,#5
000016  da02              BGE      |L6.30|
;;;306    		{
;;;307    			pBtn->Count = KEY_FILTER_TIME;
000018  2005              MOVS     r0,#5
00001a  7120              STRB     r0,[r4,#4]
00001c  e052              B        |L6.196|
                  |L6.30|
;;;308    		}
;;;309    		else if(pBtn->Count < 2 * KEY_FILTER_TIME)
00001e  7920              LDRB     r0,[r4,#4]
000020  280a              CMP      r0,#0xa
000022  da03              BGE      |L6.44|
;;;310    		{
;;;311    			pBtn->Count++;
000024  7920              LDRB     r0,[r4,#4]
000026  1c40              ADDS     r0,r0,#1
000028  7120              STRB     r0,[r4,#4]
00002a  e04b              B        |L6.196|
                  |L6.44|
;;;312    		}
;;;313    		else
;;;314    		{
;;;315    			if (pBtn->State == 0)
00002c  7aa0              LDRB     r0,[r4,#0xa]
00002e  b938              CBNZ     r0,|L6.64|
;;;316    			{
;;;317    				pBtn->State = 1;
000030  2001              MOVS     r0,#1
000032  72a0              STRB     r0,[r4,#0xa]
;;;318    
;;;319    				/* 发送按钮按下的消息 */
;;;320    				bsp_PutKey((uint8_t)(3 * i + 1));
000034  eb050145          ADD      r1,r5,r5,LSL #1
000038  1c49              ADDS     r1,r1,#1
00003a  b2c8              UXTB     r0,r1
00003c  f7fffffe          BL       bsp_PutKey
                  |L6.64|
;;;321    			}
;;;322    
;;;323    			if (pBtn->LongTime > 0)
000040  8920              LDRH     r0,[r4,#8]
000042  2800              CMP      r0,#0
000044  dd3e              BLE      |L6.196|
;;;324    			{
;;;325    				if (pBtn->LongCount < pBtn->LongTime)
000046  88e0              LDRH     r0,[r4,#6]
000048  8921              LDRH     r1,[r4,#8]
00004a  4288              CMP      r0,r1
00004c  da0d              BGE      |L6.106|
;;;326    				{
;;;327    					/* 发送按钮持续按下的消息 */
;;;328    					if (++pBtn->LongCount == pBtn->LongTime)
00004e  88e0              LDRH     r0,[r4,#6]
000050  1c40              ADDS     r0,r0,#1
000052  b280              UXTH     r0,r0
000054  80e0              STRH     r0,[r4,#6]
000056  8921              LDRH     r1,[r4,#8]
000058  4288              CMP      r0,r1
00005a  d133              BNE      |L6.196|
;;;329    					{
;;;330    						/* 键值放入按键FIFO */
;;;331    						bsp_PutKey((uint8_t)(3 * i + 3));
00005c  eb050145          ADD      r1,r5,r5,LSL #1
000060  1cc9              ADDS     r1,r1,#3
000062  b2c8              UXTB     r0,r1
000064  f7fffffe          BL       bsp_PutKey
000068  e02c              B        |L6.196|
                  |L6.106|
;;;332    					}
;;;333    				}
;;;334    				else
;;;335    				{
;;;336    					if (pBtn->RepeatSpeed > 0)
00006a  7ae0              LDRB     r0,[r4,#0xb]
00006c  2800              CMP      r0,#0
00006e  dd29              BLE      |L6.196|
;;;337    					{
;;;338    						if (++pBtn->RepeatCount >= pBtn->RepeatSpeed)
000070  7b20              LDRB     r0,[r4,#0xc]
000072  1c40              ADDS     r0,r0,#1
000074  b2c0              UXTB     r0,r0
000076  7320              STRB     r0,[r4,#0xc]
000078  7ae1              LDRB     r1,[r4,#0xb]
00007a  4288              CMP      r0,r1
00007c  db22              BLT      |L6.196|
;;;339    						{
;;;340    							pBtn->RepeatCount = 0;
00007e  2000              MOVS     r0,#0
000080  7320              STRB     r0,[r4,#0xc]
;;;341    							/* 常按键后，每隔10ms发送1个按键 */
;;;342    							bsp_PutKey((uint8_t)(3 * i + 1));
000082  eb050145          ADD      r1,r5,r5,LSL #1
000086  1c49              ADDS     r1,r1,#1
000088  b2c8              UXTB     r0,r1
00008a  f7fffffe          BL       bsp_PutKey
00008e  e019              B        |L6.196|
                  |L6.144|
;;;343    						}
;;;344    					}
;;;345    				}
;;;346    			}
;;;347    		}
;;;348    	}
;;;349    	else
;;;350    	{
;;;351    		if(pBtn->Count > KEY_FILTER_TIME)
000090  7920              LDRB     r0,[r4,#4]
000092  2805              CMP      r0,#5
000094  dd02              BLE      |L6.156|
;;;352    		{
;;;353    			pBtn->Count = KEY_FILTER_TIME;
000096  2005              MOVS     r0,#5
000098  7120              STRB     r0,[r4,#4]
00009a  e010              B        |L6.190|
                  |L6.156|
;;;354    		}
;;;355    		else if(pBtn->Count != 0)
00009c  7920              LDRB     r0,[r4,#4]
00009e  b118              CBZ      r0,|L6.168|
;;;356    		{
;;;357    			pBtn->Count--;
0000a0  7920              LDRB     r0,[r4,#4]
0000a2  1e40              SUBS     r0,r0,#1
0000a4  7120              STRB     r0,[r4,#4]
0000a6  e00a              B        |L6.190|
                  |L6.168|
;;;358    		}
;;;359    		else
;;;360    		{
;;;361    			if (pBtn->State == 1)
0000a8  7aa0              LDRB     r0,[r4,#0xa]
0000aa  2801              CMP      r0,#1
0000ac  d107              BNE      |L6.190|
;;;362    			{
;;;363    				pBtn->State = 0;
0000ae  2000              MOVS     r0,#0
0000b0  72a0              STRB     r0,[r4,#0xa]
;;;364    
;;;365    				/* 发送按钮弹起的消息 */
;;;366    				bsp_PutKey((uint8_t)(3 * i + 2));
0000b2  eb050145          ADD      r1,r5,r5,LSL #1
0000b6  1c89              ADDS     r1,r1,#2
0000b8  b2c8              UXTB     r0,r1
0000ba  f7fffffe          BL       bsp_PutKey
                  |L6.190|
;;;367    			}
;;;368    		}
;;;369    
;;;370    		pBtn->LongCount = 0;
0000be  2000              MOVS     r0,#0
0000c0  80e0              STRH     r0,[r4,#6]
;;;371    		pBtn->RepeatCount = 0;
0000c2  7320              STRB     r0,[r4,#0xc]
                  |L6.196|
;;;372    	}
;;;373    }
0000c4  bd70              POP      {r4-r6,pc}
;;;374    
                          ENDP

0000c6  0000              DCW      0x0000
                  |L6.200|
                          DCD      s_tBtn

                          AREA ||i.bsp_GetKey||, CODE, READONLY, ALIGN=2

                  bsp_GetKey PROC
;;;121    */
;;;122    uint8_t bsp_GetKey(void)
000000  480b              LDR      r0,|L7.48|
;;;123    {
;;;124    	uint8_t ret;
;;;125    
;;;126    	if (s_tKey.Read == s_tKey.Write)
000002  7900              LDRB     r0,[r0,#4]  ; s_tKey
000004  4a0a              LDR      r2,|L7.48|
000006  7952              LDRB     r2,[r2,#5]  ; s_tKey
000008  4290              CMP      r0,r2
00000a  d101              BNE      |L7.16|
;;;127    	{
;;;128    		return KEY_NONE;
00000c  2000              MOVS     r0,#0
                  |L7.14|
;;;129    	}
;;;130    	else
;;;131    	{
;;;132    		ret = s_tKey.Buf[s_tKey.Read];
;;;133    
;;;134    		if (++s_tKey.Read >= KEY_FIFO_SIZE)
;;;135    		{
;;;136    			s_tKey.Read = 0;
;;;137    		}
;;;138    		return ret;
;;;139    	}
;;;140    }
00000e  4770              BX       lr
                  |L7.16|
000010  4807              LDR      r0,|L7.48|
000012  7900              LDRB     r0,[r0,#4]            ;132  ; s_tKey
000014  4a06              LDR      r2,|L7.48|
000016  5c11              LDRB     r1,[r2,r0]            ;132
000018  4610              MOV      r0,r2                 ;134
00001a  7900              LDRB     r0,[r0,#4]            ;134  ; s_tKey
00001c  1c40              ADDS     r0,r0,#1              ;134
00001e  b2c0              UXTB     r0,r0                 ;134
000020  7110              STRB     r0,[r2,#4]            ;134
000022  2804              CMP      r0,#4                 ;134
000024  db01              BLT      |L7.42|
000026  2000              MOVS     r0,#0                 ;136
000028  7110              STRB     r0,[r2,#4]            ;136
                  |L7.42|
00002a  4608              MOV      r0,r1                 ;138
00002c  e7ef              B        |L7.14|
;;;141    
                          ENDP

00002e  0000              DCW      0x0000
                  |L7.48|
                          DCD      s_tKey

                          AREA ||i.bsp_GetKey2||, CODE, READONLY, ALIGN=2

                  bsp_GetKey2 PROC
;;;149    */
;;;150    uint8_t bsp_GetKey2(void)
000000  480b              LDR      r0,|L8.48|
;;;151    {
;;;152    	uint8_t ret;
;;;153    
;;;154    	if (s_tKey.Read2 == s_tKey.Write)
000002  7980              LDRB     r0,[r0,#6]  ; s_tKey
000004  4a0a              LDR      r2,|L8.48|
000006  7952              LDRB     r2,[r2,#5]  ; s_tKey
000008  4290              CMP      r0,r2
00000a  d101              BNE      |L8.16|
;;;155    	{
;;;156    		return KEY_NONE;
00000c  2000              MOVS     r0,#0
                  |L8.14|
;;;157    	}
;;;158    	else
;;;159    	{
;;;160    		ret = s_tKey.Buf[s_tKey.Read2];
;;;161    
;;;162    		if (++s_tKey.Read2 >= KEY_FIFO_SIZE)
;;;163    		{
;;;164    			s_tKey.Read2 = 0;
;;;165    		}
;;;166    		return ret;
;;;167    	}
;;;168    }
00000e  4770              BX       lr
                  |L8.16|
000010  4807              LDR      r0,|L8.48|
000012  7980              LDRB     r0,[r0,#6]            ;160  ; s_tKey
000014  4a06              LDR      r2,|L8.48|
000016  5c11              LDRB     r1,[r2,r0]            ;160
000018  4610              MOV      r0,r2                 ;162
00001a  7980              LDRB     r0,[r0,#6]            ;162  ; s_tKey
00001c  1c40              ADDS     r0,r0,#1              ;162
00001e  b2c0              UXTB     r0,r0                 ;162
000020  7190              STRB     r0,[r2,#6]            ;162
000022  2804              CMP      r0,#4                 ;162
000024  db01              BLT      |L8.42|
000026  2000              MOVS     r0,#0                 ;164
000028  7190              STRB     r0,[r2,#6]            ;164
                  |L8.42|
00002a  4608              MOV      r0,r1                 ;166
00002c  e7ef              B        |L8.14|
;;;169    
                          ENDP

00002e  0000              DCW      0x0000
                  |L8.48|
                          DCD      s_tKey

                          AREA ||i.bsp_GetKeyState||, CODE, READONLY, ALIGN=2

                  bsp_GetKeyState PROC
;;;177    */
;;;178    uint8_t bsp_GetKeyState(KEY_ID_E _ucKeyID)
000000  4601              MOV      r1,r0
;;;179    {
;;;180    	return s_tBtn[_ucKeyID].State;
000002  4802              LDR      r0,|L9.12|
000004  eb001001          ADD      r0,r0,r1,LSL #4
000008  7a80              LDRB     r0,[r0,#0xa]
;;;181    }
00000a  4770              BX       lr
;;;182    
                          ENDP

                  |L9.12|
                          DCD      s_tBtn

                          AREA ||i.bsp_InitKey||, CODE, READONLY, ALIGN=1

                  bsp_InitKey PROC
;;;89     */
;;;90     void bsp_InitKey(void)
000000  b510              PUSH     {r4,lr}
;;;91     {
;;;92     	bsp_InitKeyVar();		/* 初始化按键变量 */
000002  f7fffffe          BL       bsp_InitKeyVar
;;;93     	bsp_InitKeyHard();		/* 初始化按键硬件 */
000006  f7fffffe          BL       bsp_InitKeyHard
;;;94     }
00000a  bd10              POP      {r4,pc}
;;;95     
                          ENDP


                          AREA ||i.bsp_InitKeyHard||, CODE, READONLY, ALIGN=2

                  bsp_InitKeyHard PROC
;;;221    */
;;;222    static void bsp_InitKeyHard(void)
000000  b508              PUSH     {r3,lr}
;;;223    {
;;;224    	GPIO_InitTypeDef GPIO_InitStructure;
;;;225    
;;;226    	/* 第1步：打开GPIO时钟 */
;;;227    	RCC_APB2PeriphClockCmd(RCC_ALL_KEY, ENABLE);
000002  2101              MOVS     r1,#1
000004  2010              MOVS     r0,#0x10
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;228    
;;;229    	/* 第2步：配置所有的按键GPIO为浮动输入模式(实际上CPU复位后就是输入状态) */
;;;230    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00000a  2003              MOVS     r0,#3
00000c  f88d0002          STRB     r0,[sp,#2]
;;;231    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;	/* 输入浮空模式 */
000010  2004              MOVS     r0,#4
000012  f88d0003          STRB     r0,[sp,#3]
;;;232    	
;;;233    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_K1;
000016  2001              MOVS     r0,#1
000018  f8ad0000          STRH     r0,[sp,#0]
;;;234    	GPIO_Init(GPIO_PORT_K1, &GPIO_InitStructure);
00001c  4669              MOV      r1,sp
00001e  480e              LDR      r0,|L11.88|
000020  f7fffffe          BL       GPIO_Init
;;;235    
;;;236    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_K2;
000024  f44f4000          MOV      r0,#0x8000
000028  f8ad0000          STRH     r0,[sp,#0]
;;;237    	GPIO_Init(GPIO_PORT_K2, &GPIO_InitStructure);
00002c  4669              MOV      r1,sp
00002e  480a              LDR      r0,|L11.88|
000030  f7fffffe          BL       GPIO_Init
;;;238    
;;;239    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_K3;
000034  f44f4080          MOV      r0,#0x4000
000038  f8ad0000          STRH     r0,[sp,#0]
;;;240    	GPIO_Init(GPIO_PORT_K3, &GPIO_InitStructure);
00003c  4669              MOV      r1,sp
00003e  4806              LDR      r0,|L11.88|
000040  f7fffffe          BL       GPIO_Init
;;;241    
;;;242    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_K4;
000044  f44f5000          MOV      r0,#0x2000
000048  f8ad0000          STRH     r0,[sp,#0]
;;;243    	GPIO_Init(GPIO_PORT_K4, &GPIO_InitStructure);
00004c  4669              MOV      r1,sp
00004e  4802              LDR      r0,|L11.88|
000050  f7fffffe          BL       GPIO_Init
;;;244    }
000054  bd08              POP      {r3,pc}
;;;245    
                          ENDP

000056  0000              DCW      0x0000
                  |L11.88|
                          DCD      0x40011000

                          AREA ||i.bsp_InitKeyVar||, CODE, READONLY, ALIGN=2

                  bsp_InitKeyVar PROC
;;;253    */
;;;254    static void bsp_InitKeyVar(void)
000000  2100              MOVS     r1,#0
;;;255    {
;;;256    	uint8_t i;
;;;257    
;;;258    	/* 对按键FIFO读写指针清零 */
;;;259    	s_tKey.Read = 0;
000002  4a15              LDR      r2,|L12.88|
000004  7111              STRB     r1,[r2,#4]
;;;260    	s_tKey.Write = 0;
000006  7151              STRB     r1,[r2,#5]
;;;261    	s_tKey.Read2 = 0;
000008  7191              STRB     r1,[r2,#6]
;;;262    
;;;263    	/* 给每个按键结构体成员变量赋一组缺省值 */
;;;264    	for (i = 0; i < KEY_COUNT; i++)
00000a  2000              MOVS     r0,#0
00000c  e018              B        |L12.64|
                  |L12.14|
;;;265    	{
;;;266    		s_tBtn[i].LongTime = KEY_LONG_TIME;			/* 长按时间 0 表示不检测长按键事件 */
00000e  2132              MOVS     r1,#0x32
000010  4a12              LDR      r2,|L12.92|
000012  eb021200          ADD      r2,r2,r0,LSL #4
000016  8111              STRH     r1,[r2,#8]
;;;267    		s_tBtn[i].Count = KEY_FILTER_TIME / 2;		/* 计数器设置为滤波时间的一半 */
000018  2102              MOVS     r1,#2
00001a  4a10              LDR      r2,|L12.92|
00001c  eb021200          ADD      r2,r2,r0,LSL #4
000020  7111              STRB     r1,[r2,#4]
;;;268    		s_tBtn[i].State = 0;							/* 按键缺省状态，0为未按下 */
000022  2100              MOVS     r1,#0
000024  4a0d              LDR      r2,|L12.92|
000026  eb021200          ADD      r2,r2,r0,LSL #4
00002a  7291              STRB     r1,[r2,#0xa]
;;;269    		s_tBtn[i].RepeatSpeed = 0;						/* 按键连发的速度，0表示不支持连发 */
00002c  4a0b              LDR      r2,|L12.92|
00002e  eb021200          ADD      r2,r2,r0,LSL #4
000032  72d1              STRB     r1,[r2,#0xb]
;;;270    		s_tBtn[i].RepeatCount = 0;						/* 连发计数器 */
000034  4a09              LDR      r2,|L12.92|
000036  eb021200          ADD      r2,r2,r0,LSL #4
00003a  7311              STRB     r1,[r2,#0xc]
00003c  1c41              ADDS     r1,r0,#1              ;264
00003e  b2c8              UXTB     r0,r1                 ;264
                  |L12.64|
000040  2804              CMP      r0,#4                 ;264
000042  dbe4              BLT      |L12.14|
;;;271    	}
;;;272    
;;;273    
;;;274    	/* 判断按键按下的函数 */
;;;275    	s_tBtn[0].IsKeyDownFunc = IsKeyDown1;
000044  4906              LDR      r1,|L12.96|
000046  4a05              LDR      r2,|L12.92|
000048  6011              STR      r1,[r2,#0]  ; s_tBtn
;;;276    	s_tBtn[1].IsKeyDownFunc = IsKeyDown2;
00004a  4906              LDR      r1,|L12.100|
00004c  6111              STR      r1,[r2,#0x10]  ; s_tBtn
;;;277    	s_tBtn[2].IsKeyDownFunc = IsKeyDown3;
00004e  4906              LDR      r1,|L12.104|
000050  6211              STR      r1,[r2,#0x20]  ; s_tBtn
;;;278    	s_tBtn[3].IsKeyDownFunc = IsKeyDown4;
000052  4906              LDR      r1,|L12.108|
000054  6311              STR      r1,[r2,#0x30]  ; s_tBtn
;;;279    
;;;280    }
000056  4770              BX       lr
;;;281    
                          ENDP

                  |L12.88|
                          DCD      s_tKey
                  |L12.92|
                          DCD      s_tBtn
                  |L12.96|
                          DCD      IsKeyDown1
                  |L12.100|
                          DCD      IsKeyDown2
                  |L12.104|
                          DCD      IsKeyDown3
                  |L12.108|
                          DCD      IsKeyDown4

                          AREA ||i.bsp_KeyScan||, CODE, READONLY, ALIGN=1

                  bsp_KeyScan PROC
;;;382    */
;;;383    void bsp_KeyScan(void)
000000  b510              PUSH     {r4,lr}
;;;384    {
;;;385    	uint8_t i;
;;;386    
;;;387    	for (i = 0; i < KEY_COUNT; i++)
000002  2400              MOVS     r4,#0
000004  e004              B        |L13.16|
                  |L13.6|
;;;388    	{
;;;389    		bsp_DetectKey(i);
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       bsp_DetectKey
00000c  1c60              ADDS     r0,r4,#1              ;387
00000e  b2c4              UXTB     r4,r0                 ;387
                  |L13.16|
000010  2c04              CMP      r4,#4                 ;387
000012  dbf8              BLT      |L13.6|
;;;390    	}
;;;391    }
000014  bd10              POP      {r4,pc}
;;;392    
                          ENDP


                          AREA ||i.bsp_PutKey||, CODE, READONLY, ALIGN=2

                  bsp_PutKey PROC
;;;103    */
;;;104    void bsp_PutKey(uint8_t _KeyCode)
000000  4906              LDR      r1,|L14.28|
;;;105    {
;;;106    	s_tKey.Buf[s_tKey.Write] = _KeyCode;
000002  7949              LDRB     r1,[r1,#5]  ; s_tKey
000004  4a05              LDR      r2,|L14.28|
000006  5450              STRB     r0,[r2,r1]
;;;107    
;;;108    	if (++s_tKey.Write  >= KEY_FIFO_SIZE)
000008  4611              MOV      r1,r2
00000a  7949              LDRB     r1,[r1,#5]  ; s_tKey
00000c  1c49              ADDS     r1,r1,#1
00000e  b2c9              UXTB     r1,r1
000010  7151              STRB     r1,[r2,#5]
000012  2904              CMP      r1,#4
000014  db01              BLT      |L14.26|
;;;109    	{
;;;110    		s_tKey.Write = 0;
000016  2100              MOVS     r1,#0
000018  7151              STRB     r1,[r2,#5]
                  |L14.26|
;;;111    	}
;;;112    }
00001a  4770              BX       lr
;;;113    
                          ENDP

                  |L14.28|
                          DCD      s_tKey

                          AREA ||i.bsp_SetKeyParam||, CODE, READONLY, ALIGN=2

                  bsp_SetKeyParam PROC
;;;192    */
;;;193    void bsp_SetKeyParam(uint8_t _ucKeyID, uint16_t _LongTime, uint8_t  _RepeatSpeed)
000000  b510              PUSH     {r4,lr}
;;;194    {
;;;195    	s_tBtn[_ucKeyID].LongTime = _LongTime;			/* 长按时间 0 表示不检测长按键事件 */
000002  4b07              LDR      r3,|L15.32|
000004  eb031300          ADD      r3,r3,r0,LSL #4
000008  8119              STRH     r1,[r3,#8]
;;;196    	s_tBtn[_ucKeyID].RepeatSpeed = _RepeatSpeed;	/* 按键连发的速度，0表示不支持连发 */
00000a  4b05              LDR      r3,|L15.32|
00000c  eb031300          ADD      r3,r3,r0,LSL #4
000010  72da              STRB     r2,[r3,#0xb]
;;;197    	s_tBtn[_ucKeyID].RepeatCount = 0;				/* 连发计数器 */
000012  2300              MOVS     r3,#0
000014  4c02              LDR      r4,|L15.32|
000016  eb041400          ADD      r4,r4,r0,LSL #4
00001a  7323              STRB     r3,[r4,#0xc]
;;;198    }
00001c  bd10              POP      {r4,pc}
;;;199    
                          ENDP

00001e  0000              DCW      0x0000
                  |L15.32|
                          DCD      s_tBtn

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  s_tBtn
                          %        64

                          AREA ||.data||, DATA, ALIGN=0

                  s_tKey
                          DCDU     0x00000000
000004  000000            DCB      0x00,0x00,0x00
