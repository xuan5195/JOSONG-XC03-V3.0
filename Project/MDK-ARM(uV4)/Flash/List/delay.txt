; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\delay.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\delay.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User -I"C:\Users\xuan5\Desktop\JOSONG-XS03 V3.0\Project\MDK-ARM(uV4)\RTE" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=521 -D_RTE_ -DSTM32F10X_MD -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=.\flash\obj\delay.crf ..\..\User\delay.c]
                          THUMB

                          AREA ||i.delay_init||, CODE, READONLY, ALIGN=2

                  delay_init PROC
;;;23     //SYSCLK:系统时钟
;;;24     void delay_init()	 
000000  b510              PUSH     {r4,lr}
;;;25     {
;;;26     
;;;27     #ifdef OS_CRITICAL_METHOD 	//如果OS_CRITICAL_METHOD定义了,说明使用ucosII了.
;;;28     	u32 reload;
;;;29     #endif
;;;30     	SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK_Div8);	//选择外部时钟  HCLK/8
000002  f06f0004          MVN      r0,#4
000006  f7fffffe          BL       SysTick_CLKSourceConfig
;;;31     	fac_us=SystemCoreClock/8000000;	//为系统时钟的1/8  
00000a  480a              LDR      r0,|L1.52|
00000c  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000e  490a              LDR      r1,|L1.56|
000010  fbb0f0f1          UDIV     r0,r0,r1
000014  4909              LDR      r1,|L1.60|
000016  7008              STRB     r0,[r1,#0]
;;;32     	 
;;;33     #ifdef OS_CRITICAL_METHOD 	//如果OS_CRITICAL_METHOD定义了,说明使用ucosII了.
;;;34     	reload=SystemCoreClock/8000000;		//每秒钟的计数次数 单位为K	   
;;;35     	reload*=1000000/OS_TICKS_PER_SEC;//根据OS_TICKS_PER_SEC设定溢出时间
;;;36     							//reload为24位寄存器,最大值:16777216,在72M下,约合1.86s左右	
;;;37     	fac_ms=1000/OS_TICKS_PER_SEC;//代表ucos可以延时的最少单位	   
;;;38     	SysTick->CTRL|=SysTick_CTRL_TICKINT_Msk;   	//开启SYSTICK中断
;;;39     	SysTick->LOAD=reload; 	//每1/OS_TICKS_PER_SEC秒中断一次	
;;;40     	SysTick->CTRL|=SysTick_CTRL_ENABLE_Msk;   	//开启SYSTICK    
;;;41     #else
;;;42     	fac_ms=(u16)fac_us*1000;//非ucos下,代表每个ms需要的systick时钟数   
000018  4608              MOV      r0,r1
00001a  7800              LDRB     r0,[r0,#0]  ; fac_us
00001c  eb000140          ADD      r1,r0,r0,LSL #1
000020  ebc110c0          RSB      r0,r1,r0,LSL #7
000024  f64f71ff          MOV      r1,#0xffff
000028  ea0100c0          AND      r0,r1,r0,LSL #3
00002c  4904              LDR      r1,|L1.64|
00002e  8008              STRH     r0,[r1,#0]
;;;43     #endif
;;;44     }								    
000030  bd10              POP      {r4,pc}
;;;45     
                          ENDP

000032  0000              DCW      0x0000
                  |L1.52|
                          DCD      SystemCoreClock
                  |L1.56|
                          DCD      0x007a1200
                  |L1.60|
                          DCD      fac_us
                  |L1.64|
                          DCD      fac_ms

                          AREA ||i.delay_ms||, CODE, READONLY, ALIGN=2

                  delay_ms PROC
;;;105    //对72M条件下,nms<=1864 
;;;106    void delay_ms(u16 nms)
000000  4601              MOV      r1,r0
;;;107    {	 		  	  
;;;108    	u32 temp;		   
;;;109    	SysTick->LOAD=(u32)nms*fac_ms;//时间加载(SysTick->LOAD为24bit)
000002  4a11              LDR      r2,|L2.72|
000004  8812              LDRH     r2,[r2,#0]  ; fac_ms
000006  434a              MULS     r2,r1,r2
000008  f04f23e0          MOV      r3,#0xe000e000
00000c  615a              STR      r2,[r3,#0x14]
;;;110    	SysTick->VAL =0x00;           //清空计数器
00000e  2200              MOVS     r2,#0
000010  619a              STR      r2,[r3,#0x18]
;;;111    	SysTick->CTRL|=SysTick_CTRL_ENABLE_Msk ;          //开始倒数  
000012  461a              MOV      r2,r3
000014  6912              LDR      r2,[r2,#0x10]
000016  f0420201          ORR      r2,r2,#1
00001a  611a              STR      r2,[r3,#0x10]
;;;112    	do
00001c  bf00              NOP      
                  |L2.30|
;;;113    	{
;;;114    		temp=SysTick->CTRL;
00001e  f04f22e0          MOV      r2,#0xe000e000
000022  6910              LDR      r0,[r2,#0x10]
;;;115    	}
;;;116    	while(temp&0x01&&!(temp&(1<<16)));//等待时间到达   
000024  f0000201          AND      r2,r0,#1
000028  b11a              CBZ      r2,|L2.50|
00002a  f4003280          AND      r2,r0,#0x10000
00002e  2a00              CMP      r2,#0
000030  d0f5              BEQ      |L2.30|
                  |L2.50|
;;;117    	SysTick->CTRL&=~SysTick_CTRL_ENABLE_Msk;       //关闭计数器
000032  f04f22e0          MOV      r2,#0xe000e000
000036  6912              LDR      r2,[r2,#0x10]
000038  f0220201          BIC      r2,r2,#1
00003c  f04f23e0          MOV      r3,#0xe000e000
000040  611a              STR      r2,[r3,#0x10]
;;;118    	SysTick->VAL =0X00;       //清空计数器	  	    
000042  2200              MOVS     r2,#0
000044  619a              STR      r2,[r3,#0x18]
;;;119    } 
000046  4770              BX       lr
;;;120    #endif
                          ENDP

                  |L2.72|
                          DCD      fac_ms

                          AREA ||i.delay_us||, CODE, READONLY, ALIGN=2

                  delay_us PROC
;;;85     //nus为要延时的us数.		    								   
;;;86     void delay_us(u32 nus)
000000  4601              MOV      r1,r0
;;;87     {		
;;;88     	u32 temp;	    	 
;;;89     	SysTick->LOAD=nus*fac_us; //时间加载	  		 
000002  4a11              LDR      r2,|L3.72|
000004  7812              LDRB     r2,[r2,#0]  ; fac_us
000006  434a              MULS     r2,r1,r2
000008  f04f23e0          MOV      r3,#0xe000e000
00000c  615a              STR      r2,[r3,#0x14]
;;;90     	SysTick->VAL=0x00;        //清空计数器
00000e  2200              MOVS     r2,#0
000010  619a              STR      r2,[r3,#0x18]
;;;91     	SysTick->CTRL|=SysTick_CTRL_ENABLE_Msk ;          //开始倒数	 
000012  461a              MOV      r2,r3
000014  6912              LDR      r2,[r2,#0x10]
000016  f0420201          ORR      r2,r2,#1
00001a  611a              STR      r2,[r3,#0x10]
;;;92     	do
00001c  bf00              NOP      
                  |L3.30|
;;;93     	{
;;;94     		temp=SysTick->CTRL;
00001e  f04f22e0          MOV      r2,#0xe000e000
000022  6910              LDR      r0,[r2,#0x10]
;;;95     	}
;;;96     	while(temp&0x01&&!(temp&(1<<16)));//等待时间到达   
000024  f0000201          AND      r2,r0,#1
000028  b11a              CBZ      r2,|L3.50|
00002a  f4003280          AND      r2,r0,#0x10000
00002e  2a00              CMP      r2,#0
000030  d0f5              BEQ      |L3.30|
                  |L3.50|
;;;97     	SysTick->CTRL&=~SysTick_CTRL_ENABLE_Msk;       //关闭计数器
000032  f04f22e0          MOV      r2,#0xe000e000
000036  6912              LDR      r2,[r2,#0x10]
000038  f0220201          BIC      r2,r2,#1
00003c  f04f23e0          MOV      r3,#0xe000e000
000040  611a              STR      r2,[r3,#0x10]
;;;98     	SysTick->VAL =0X00;       //清空计数器	 
000042  2200              MOVS     r2,#0
000044  619a              STR      r2,[r3,#0x18]
;;;99     }
000046  4770              BX       lr
;;;100    //延时nms
                          ENDP

                  |L3.72|
                          DCD      fac_us

                          AREA ||.data||, DATA, ALIGN=1

                  fac_us
000000  0000              DCB      0x00,0x00
                  fac_ms
000002  0000              DCW      0x0000
