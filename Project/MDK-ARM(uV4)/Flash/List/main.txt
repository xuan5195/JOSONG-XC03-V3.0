; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\main.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\main.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User -I"C:\Users\xuan5\Desktop\JOSONG-XS03 V3.0\Project\MDK-ARM(uV4)\RTE" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=521 -D_RTE_ -DSTM32F10X_MD -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=.\flash\obj\main.crf ..\..\User\main.c]
                          THUMB

                          AREA ||i.CPU_IDLE||, CODE, READONLY, ALIGN=2

                  CPU_IDLE PROC
;;;55     }
;;;56     void CPU_IDLE(void)
000000  b510              PUSH     {r4,lr}
;;;57     {
;;;58     	static uint8_t g_FlagDWG=0;
;;;59     	if(++g_FlagDWG%2==0)	HardWDG_ON();
000002  490b              LDR      r1,|L1.48|
000004  7809              LDRB     r1,[r1,#0]  ; g_FlagDWG
000006  1c49              ADDS     r1,r1,#1
000008  b2c9              UXTB     r1,r1
00000a  4a09              LDR      r2,|L1.48|
00000c  7011              STRB     r1,[r2,#0]
00000e  4608              MOV      r0,r1
000010  eb0171d0          ADD      r1,r1,r0,LSR #31
000014  1049              ASRS     r1,r1,#1
000016  eba00141          SUB      r1,r0,r1,LSL #1
00001a  b921              CBNZ     r1,|L1.38|
00001c  2110              MOVS     r1,#0x10
00001e  4805              LDR      r0,|L1.52|
000020  f7fffffe          BL       GPIO_SetBits
000024  e003              B        |L1.46|
                  |L1.38|
;;;60     	else 					HardWDG_OFF();
000026  2110              MOVS     r1,#0x10
000028  4802              LDR      r0,|L1.52|
00002a  f7fffffe          BL       GPIO_ResetBits
                  |L1.46|
;;;61     }
00002e  bd10              POP      {r4,pc}
;;;62     
                          ENDP

                  |L1.48|
                          DCD      g_FlagDWG
                  |L1.52|
                          DCD      0x40010800

                          AREA ||i.Delay||, CODE, READONLY, ALIGN=1

                  Delay PROC
;;;277    
;;;278    void Delay(__IO uint16_t nCount)
000000  b501              PUSH     {r0,lr}
;;;279    {
;;;280    	while (nCount != 0)
000002  e004              B        |L2.14|
                  |L2.4|
;;;281    	{
;;;282    		nCount--;
000004  f8bd0000          LDRH     r0,[sp,#0]
000008  1e40              SUBS     r0,r0,#1
00000a  b280              UXTH     r0,r0
00000c  9000              STR      r0,[sp,#0]
                  |L2.14|
00000e  f8bd0000          LDRH     r0,[sp,#0]            ;280
000012  2800              CMP      r0,#0                 ;280
000014  d1f6              BNE      |L2.4|
;;;283    	}
;;;284    }
000016  bd08              POP      {r3,pc}
;;;285    
                          ENDP


                          AREA ||i.InitBoard||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  InitBoard PROC
;;;235    */
;;;236    static void InitBoard(void)
000000  b510              PUSH     {r4,lr}
;;;237    {	
;;;238    	RCC_Configuration();
000002  f7fffffe          BL       RCC_Configuration
;;;239    	/* 初始化systick定时器，并启动定时中断 */
;;;240    	bsp_InitTimer(); 
000006  f7fffffe          BL       bsp_InitTimer
;;;241    	delay_init();
00000a  f7fffffe          BL       delay_init
;;;242    	delay_ms(500);
00000e  f44f70fa          MOV      r0,#0x1f4
000012  f7fffffe          BL       delay_ms
;;;243    	Init_GPIO();				//输出初始化
000016  f7fffffe          BL       Init_GPIO
;;;244    	bsp_InitKey();
00001a  f7fffffe          BL       bsp_InitKey
;;;245    	bsp_InitUart(); 	    	//初始化串口+RS485
00001e  f7fffffe          BL       bsp_InitUart
;;;246    	printf("\r\nStarting Up...\r\nJOSONG-XS03 V3.0...\r\n");
000022  a014              ADR      r0,|L3.116|
000024  f7fffffe          BL       __2printf
;;;247    	printf("VersionNo: %02X...\r\n",VERSION);
000028  2101              MOVS     r1,#1
00002a  a01c              ADR      r0,|L3.156|
00002c  f7fffffe          BL       __2printf
;;;248    	printf("SystemCoreClock: %d...\r\n",SystemCoreClock);
000030  4820              LDR      r0,|L3.180|
000032  6801              LDR      r1,[r0,#0]  ; SystemCoreClock
000034  a020              ADR      r0,|L3.184|
000036  f7fffffe          BL       __2printf
;;;249    	delay_ms(500);
00003a  f44f70fa          MOV      r0,#0x1f4
00003e  f7fffffe          BL       delay_ms
;;;250    	BspTm1639_Config();	        //TM1639初始化
000042  f7fffffe          BL       BspTm1639_Config
;;;251    	BspDht11_Config();			//温湿度传感器初始化
000046  f7fffffe          BL       BspDht11_Config
;;;252    	bsp_HC595_Config();			//HC595初始化 用于继电器输出
00004a  f7fffffe          BL       bsp_HC595_Config
;;;253    	BspInput_CD4067_Config();	//CD4067初始化 用于信号采集
00004e  f7fffffe          BL       BspInput_CD4067_Config
;;;254    	BspInput_CD4051_Config();	//CD4051*3
000052  f7fffffe          BL       BspInput_CD4051_Config
;;;255    	Bsp_CS5463_Config();
000056  f7fffffe          BL       Bsp_CS5463_Config
;;;256    	CS546x_Init(0);
00005a  2000              MOVS     r0,#0
00005c  f7fffffe          BL       CS546x_Init
;;;257    	TIM3_Int_Init(99,720-1);  	//以100khz的频率计数，0.01ms中断，计数到100 *0.01ms 为1ms 
000060  f24021cf          MOV      r1,#0x2cf
000064  2063              MOVS     r0,#0x63
000066  f7fffffe          BL       TIM3_Int_Init
;;;258    //	TIM2_Cap_Init(0xFFFF,72-1);	//以1Mhz的频率计数 
;;;259     	Adc_Init();		  		    //ADC初始化
00006a  f7fffffe          BL       Adc_Init
;;;260    	bsp_InitCQVar();
00006e  f7fffffe          BL       bsp_InitCQVar
;;;261    }
000072  bd10              POP      {r4,pc}
;;;262    
                          ENDP

                  |L3.116|
000074  0d0a5374          DCB      "\r\nStarting Up...\r\nJOSONG-XS03 V3.0...\r\n",0
000078  61727469
00007c  6e672055
000080  702e2e2e
000084  0d0a4a4f
000088  534f4e47
00008c  2d585330
000090  33205633
000094  2e302e2e
000098  2e0d0a00
                  |L3.156|
00009c  56657273          DCB      "VersionNo: %02X...\r\n",0
0000a0  696f6e4e
0000a4  6f3a2025
0000a8  3032582e
0000ac  2e2e0d0a
0000b0  00      
0000b1  00                DCB      0
0000b2  00                DCB      0
0000b3  00                DCB      0
                  |L3.180|
                          DCD      SystemCoreClock
                  |L3.184|
0000b8  53797374          DCB      "SystemCoreClock: %d...\r\n",0
0000bc  656d436f
0000c0  7265436c
0000c4  6f636b3a
0000c8  2025642e
0000cc  2e2e0d0a
0000d0  00      
0000d1  00                DCB      0
0000d2  00                DCB      0
0000d3  00                DCB      0

                          AREA ||i.Init_GPIO||, CODE, READONLY, ALIGN=2

                  Init_GPIO PROC
;;;116    
;;;117    void Init_GPIO(void)
000000  b508              PUSH     {r3,lr}
;;;118    {
;;;119    	GPIO_InitTypeDef GPIO_InitStructure;
;;;120    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); 
000002  2101              MOVS     r1,#1
000004  2004              MOVS     r0,#4
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;121    
;;;122    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;
00000a  2010              MOVS     r0,#0x10
00000c  f8ad0000          STRH     r0,[sp,#0]
;;;123    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
000010  f88d0003          STRB     r0,[sp,#3]
;;;124    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000014  2003              MOVS     r0,#3
000016  f88d0002          STRB     r0,[sp,#2]
;;;125    	GPIO_Init(GPIOA, &GPIO_InitStructure);
00001a  4669              MOV      r1,sp
00001c  4801              LDR      r0,|L4.36|
00001e  f7fffffe          BL       GPIO_Init
;;;126    }
000022  bd08              POP      {r3,pc}
;;;127    
                          ENDP

                  |L4.36|
                          DCD      0x40010800

                          AREA ||i.NVIC_Configuration||, CODE, READONLY, ALIGN=1

                  NVIC_Configuration PROC
;;;43     
;;;44     void NVIC_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;45     {
;;;46         NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);	//设置NVIC中断分组2:2位抢占优先级，2位响应优先级
000002  f44f60a0          MOV      r0,#0x500
000006  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;47     }
00000a  bd10              POP      {r4,pc}
;;;48     
                          ENDP


                          AREA ||i.PutInMemoryBuf||, CODE, READONLY, ALIGN=2

                  PutInMemoryBuf PROC
;;;80     
;;;81     void PutInMemoryBuf(u8 *Buf)	//末尾加入第一个缓存
000000  b51f              PUSH     {r0-r4,lr}
;;;82     {
000002  4604              MOV      r4,r0
;;;83         uint8_t BufDat[16]={0};
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
000008  9001              STR      r0,[sp,#4]
00000a  9002              STR      r0,[sp,#8]
00000c  9003              STR      r0,[sp,#0xc]
;;;84     	//日志存储
;;;85         BufDat[ 0] = (uint8_t)(g_RunningTime>>24); //时钟
00000e  4833              LDR      r0,|L6.220|
000010  6800              LDR      r0,[r0,#0]  ; g_RunningTime
000012  0e00              LSRS     r0,r0,#24
000014  f88d0000          STRB     r0,[sp,#0]
;;;86         BufDat[ 1] = (uint8_t)(g_RunningTime>>16); //时钟
000018  4830              LDR      r0,|L6.220|
00001a  6800              LDR      r0,[r0,#0]  ; g_RunningTime
00001c  0c00              LSRS     r0,r0,#16
00001e  f88d0001          STRB     r0,[sp,#1]
;;;87         BufDat[ 2] = (uint8_t)(g_RunningTime>>8);  //时钟
000022  482e              LDR      r0,|L6.220|
000024  8800              LDRH     r0,[r0,#0]  ; g_RunningTime
000026  0a00              LSRS     r0,r0,#8
000028  f88d0002          STRB     r0,[sp,#2]
;;;88         BufDat[ 3] = (uint8_t)(g_RunningTime);     //时钟
00002c  482b              LDR      r0,|L6.220|
00002e  7800              LDRB     r0,[r0,#0]  ; g_RunningTime
000030  f88d0003          STRB     r0,[sp,#3]
;;;89         BufDat[ 4] = Buf[1];     	//卡号0；
000034  7860              LDRB     r0,[r4,#1]
000036  f88d0004          STRB     r0,[sp,#4]
;;;90         BufDat[ 5] = Buf[2];     	//卡号1；
00003a  78a0              LDRB     r0,[r4,#2]
00003c  f88d0005          STRB     r0,[sp,#5]
;;;91         BufDat[ 6] = Buf[3];     	//卡号2；
000040  78e0              LDRB     r0,[r4,#3]
000042  f88d0006          STRB     r0,[sp,#6]
;;;92         BufDat[ 7] = Buf[4];     	//卡号3；
000046  7920              LDRB     r0,[r4,#4]
000048  f88d0007          STRB     r0,[sp,#7]
;;;93         BufDat[ 8] = Buf[8];		//校验	
00004c  7a20              LDRB     r0,[r4,#8]
00004e  f88d0008          STRB     r0,[sp,#8]
;;;94         BufDat[ 9] = Buf[ 5];     	//金额1高位
000052  7960              LDRB     r0,[r4,#5]
000054  f88d0009          STRB     r0,[sp,#9]
;;;95         BufDat[10] = Buf[ 6];     	//金额2
000058  79a0              LDRB     r0,[r4,#6]
00005a  f88d000a          STRB     r0,[sp,#0xa]
;;;96         BufDat[11] = Buf[ 7];     	//金额3
00005e  79e0              LDRB     r0,[r4,#7]
000060  f88d000b          STRB     r0,[sp,#0xb]
;;;97         BufDat[12] = Buf[ 9]&0x7F;	//DecSum高位
000064  7a60              LDRB     r0,[r4,#9]
000066  f000007f          AND      r0,r0,#0x7f
00006a  f88d000c          STRB     r0,[sp,#0xc]
;;;98         BufDat[13] = Buf[10];     	//DecSum低位
00006e  7aa0              LDRB     r0,[r4,#0xa]
000070  f88d000d          STRB     r0,[sp,#0xd]
;;;99     	
;;;100    	if((Buf[ 9]&0x80)==0x80)    BufDat[14] = 0x03;	 //连续消息标记; 
000074  7a60              LDRB     r0,[r4,#9]
000076  f0000080          AND      r0,r0,#0x80
00007a  2880              CMP      r0,#0x80
00007c  d103              BNE      |L6.134|
00007e  2003              MOVS     r0,#3
000080  f88d000e          STRB     r0,[sp,#0xe]
000084  e009              B        |L6.154|
                  |L6.134|
;;;101    	else
;;;102        {
;;;103            if( Buf[0] == 0xAA )	BufDat[14] = 0x01;  //插卡；
000086  7820              LDRB     r0,[r4,#0]
000088  28aa              CMP      r0,#0xaa
00008a  d103              BNE      |L6.148|
00008c  2001              MOVS     r0,#1
00008e  f88d000e          STRB     r0,[sp,#0xe]
000092  e002              B        |L6.154|
                  |L6.148|
;;;104            else					BufDat[14] = 0x02;  //取卡； 
000094  2002              MOVS     r0,#2
000096  f88d000e          STRB     r0,[sp,#0xe]
                  |L6.154|
;;;105    	}
;;;106        BufDat[15] = CRC8_Table(BufDat,15); 	//CRC
00009a  210f              MOVS     r1,#0xf
00009c  4668              MOV      r0,sp
00009e  f7fffffe          BL       CRC8_Table
0000a2  f88d000f          STRB     r0,[sp,#0xf]
;;;107    	
;;;108    
;;;109    	memcpy(s_gCQ.Buf[s_gCQ.Write],Buf,10);
0000a6  480e              LDR      r0,|L6.224|
0000a8  f89000a1          LDRB     r0,[r0,#0xa1]  ; s_gCQ
0000ac  490c              LDR      r1,|L6.224|
0000ae  eb011000          ADD      r0,r1,r0,LSL #4
0000b2  6821              LDR      r1,[r4,#0]
0000b4  6001              STR      r1,[r0,#0]
0000b6  6861              LDR      r1,[r4,#4]
0000b8  6041              STR      r1,[r0,#4]
0000ba  8921              LDRH     r1,[r4,#8]
0000bc  8101              STRH     r1,[r0,#8]
;;;110    
;;;111    	if (++s_gCQ.Write  >= CQ_FIFO_SIZE)
0000be  4808              LDR      r0,|L6.224|
0000c0  f89000a1          LDRB     r0,[r0,#0xa1]  ; s_gCQ
0000c4  1c40              ADDS     r0,r0,#1
0000c6  b2c0              UXTB     r0,r0
0000c8  4905              LDR      r1,|L6.224|
0000ca  f88100a1          STRB     r0,[r1,#0xa1]
0000ce  280a              CMP      r0,#0xa
0000d0  db02              BLT      |L6.216|
;;;112    	{
;;;113    		s_gCQ.Write = 0;
0000d2  2000              MOVS     r0,#0
0000d4  f88100a1          STRB     r0,[r1,#0xa1]
                  |L6.216|
;;;114    	}
;;;115    }
0000d8  bd1f              POP      {r0-r4,pc}
;;;116    
                          ENDP

0000da  0000              DCW      0x0000
                  |L6.220|
                          DCD      g_RunningTime
                  |L6.224|
                          DCD      s_gCQ

                          AREA ||i.PutOutMemoryBuf||, CODE, READONLY, ALIGN=2

                  PutOutMemoryBuf PROC
;;;63     
;;;64     uint8_t PutOutMemoryBuf(uint8_t *_Date)	//清第一个缓存
000000  b510              PUSH     {r4,lr}
;;;65     {
000002  4604              MOV      r4,r0
;;;66     	if (s_gCQ.Read == s_gCQ.Write)
000004  4811              LDR      r0,|L7.76|
000006  f89000a0          LDRB     r0,[r0,#0xa0]  ; s_gCQ
00000a  4910              LDR      r1,|L7.76|
00000c  f89110a1          LDRB     r1,[r1,#0xa1]  ; s_gCQ
000010  4288              CMP      r0,r1
000012  d101              BNE      |L7.24|
;;;67     	{
;;;68     		return CQ_NONE;
000014  2000              MOVS     r0,#0
                  |L7.22|
;;;69     	}
;;;70     	else
;;;71     	{
;;;72     		memcpy(_Date,s_gCQ.Buf[s_gCQ.Read],16);
;;;73     		if (++s_gCQ.Read >= CQ_FIFO_SIZE)
;;;74     		{
;;;75     			s_gCQ.Read = 0;
;;;76     		}
;;;77     		return CQ_OK;
;;;78     	}
;;;79     }
000016  bd10              POP      {r4,pc}
                  |L7.24|
000018  480c              LDR      r0,|L7.76|
00001a  f89000a0          LDRB     r0,[r0,#0xa0]         ;72  ; s_gCQ
00001e  4a0b              LDR      r2,|L7.76|
000020  eb021100          ADD      r1,r2,r0,LSL #4       ;72
000024  2210              MOVS     r2,#0x10              ;72
000026  4620              MOV      r0,r4                 ;72
000028  f7fffffe          BL       __aeabi_memcpy
00002c  4807              LDR      r0,|L7.76|
00002e  f89000a0          LDRB     r0,[r0,#0xa0]         ;73  ; s_gCQ
000032  1c40              ADDS     r0,r0,#1              ;73
000034  b2c0              UXTB     r0,r0                 ;73
000036  4905              LDR      r1,|L7.76|
000038  f88100a0          STRB     r0,[r1,#0xa0]         ;73
00003c  280a              CMP      r0,#0xa               ;73
00003e  db02              BLT      |L7.70|
000040  2000              MOVS     r0,#0                 ;75
000042  f88100a0          STRB     r0,[r1,#0xa0]         ;75
                  |L7.70|
000046  2001              MOVS     r0,#1                 ;77
000048  e7e5              B        |L7.22|
;;;80     
                          ENDP

00004a  0000              DCW      0x0000
                  |L7.76|
                          DCD      s_gCQ

                          AREA ||i.RCC_Configuration||, CODE, READONLY, ALIGN=1

                  RCC_Configuration PROC
;;;48     
;;;49     void RCC_Configuration(void)
000000  4770              BX       lr
;;;50     {
;;;51     //    RCC_DeInit();
;;;52     //    RCC_HSEConfig(RCC_HSE_OFF);
;;;53     //    RCC_HSICmd(ENABLE);
;;;54     //    RCC_HSEConfig(RCC_HSE_ON);
;;;55     }
;;;56     void CPU_IDLE(void)
                          ENDP


                          AREA ||i.SoftReset||, CODE, READONLY, ALIGN=2

                  SoftReset PROC
;;;127    
;;;128    void SoftReset(void)
000000  2001              MOVS     r0,#1
000002  f3808813          MSR      FAULTMASK,r0
000006  bf00              NOP      
;;;129    {
;;;130    	__set_FAULTMASK(1);		// 关闭所有中端
;;;131    	NVIC_SystemReset();		// 复位
000008  bf00              NOP      
00000a  4807              LDR      r0,|L9.40|
00000c  6800              LDR      r0,[r0,#0]
00000e  f40060e0          AND      r0,r0,#0x700
000012  4906              LDR      r1,|L9.44|
000014  4308              ORRS     r0,r0,r1
000016  1d00              ADDS     r0,r0,#4
000018  4903              LDR      r1,|L9.40|
00001a  6008              STR      r0,[r1,#0]
00001c  f3bf8f4f          DSB      
000020  bf00              NOP      
000022  bf00              NOP      
                  |L9.36|
000024  e7fe              B        |L9.36|
;;;132    }
;;;133    
                          ENDP

000026  0000              DCW      0x0000
                  |L9.40|
                          DCD      0xe000ed0c
                  |L9.44|
                          DCD      0x05fa0000

                          AREA ||i.TIM3_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM3_IRQHandler PROC
;;;265    //定时器3中断服务程序
;;;266    void TIM3_IRQHandler(void)   //TIM3中断
000000  b510              PUSH     {r4,lr}
;;;267    {
;;;268    	if (TIM_GetITStatus(TIM3, TIM_IT_Update) != RESET)  //TIM3更新中断 20ms中断
000002  2101              MOVS     r1,#1
000004  4810              LDR      r0,|L10.72|
000006  f7fffffe          BL       TIM_GetITStatus
00000a  b1d8              CBZ      r0,|L10.68|
;;;269    	{
;;;270    		if(Time_count>200)	Time_count=0;
00000c  480f              LDR      r0,|L10.76|
00000e  7800              LDRB     r0,[r0,#0]  ; Time_count
000010  28c8              CMP      r0,#0xc8
000012  dd02              BLE      |L10.26|
000014  2000              MOVS     r0,#0
000016  490d              LDR      r1,|L10.76|
000018  7008              STRB     r0,[r1,#0]
                  |L10.26|
;;;271    		Time_count++;
00001a  480c              LDR      r0,|L10.76|
00001c  7800              LDRB     r0,[r0,#0]  ; Time_count
00001e  1c40              ADDS     r0,r0,#1
000020  490a              LDR      r1,|L10.76|
000022  7008              STRB     r0,[r1,#0]
;;;272    		SysTick_ISR();	//这个函数在bsp_timer.c中 
000024  f7fffffe          BL       SysTick_ISR
;;;273    		if((Time_count%10)==0)			bsp_KeyScan();	//每10ms扫描按键一次
000028  4808              LDR      r0,|L10.76|
00002a  7800              LDRB     r0,[r0,#0]  ; Time_count
00002c  210a              MOVS     r1,#0xa
00002e  fb90f2f1          SDIV     r2,r0,r1
000032  fb010012          MLS      r0,r1,r2,r0
000036  b908              CBNZ     r0,|L10.60|
000038  f7fffffe          BL       bsp_KeyScan
                  |L10.60|
;;;274    		TIM_ClearITPendingBit(TIM3, TIM_IT_Update  );  	//清除TIMx更新中断标志 					
00003c  2101              MOVS     r1,#1
00003e  4802              LDR      r0,|L10.72|
000040  f7fffffe          BL       TIM_ClearITPendingBit
                  |L10.68|
;;;275    	}
;;;276    }
000044  bd10              POP      {r4,pc}
;;;277    
                          ENDP

000046  0000              DCW      0x0000
                  |L10.72|
                          DCD      0x40000400
                  |L10.76|
                          DCD      Time_count

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  main PROC
;;;141    */
;;;142    int main(void)
000000  b08a              SUB      sp,sp,#0x28
;;;143    {
;;;144    	uint8_t DHT_Dat[5]={0},Buff[4]={0xFF,0x00,0xFF,0x00};
000002  2000              MOVS     r0,#0
000004  9008              STR      r0,[sp,#0x20]
000006  9009              STR      r0,[sp,#0x24]
000008  a056              ADR      r0,|L11.356|
00000a  6800              LDR      r0,[r0,#0]
00000c  9007              STR      r0,[sp,#0x1c]
;;;145    	uint8_t Time_250ms=0;
00000e  2500              MOVS     r5,#0
;;;146    	uint8_t KeyDat=0;
000010  2400              MOVS     r4,#0
;;;147    	SystemInit();
000012  f7fffffe          BL       SystemInit
;;;148    	
;;;149    	InitBoard();		//硬件初始化
000016  f7fffffe          BL       InitBoard
;;;150    //	Delay(0xFFFF); 		//上电简单延时一下  
;;;151    	BspTm1639_Show(0x01,0x00);	//上电初始化显示
00001a  2100              MOVS     r1,#0
00001c  2001              MOVS     r0,#1
00001e  f7fffffe          BL       BspTm1639_Show
;;;152    	CAN_Mode_Init(CAN_SJW_1tq,CAN_BS1_4tq,CAN_BS2_3tq,75,CAN_Mode_Normal);	//CAN初始化正常模式,波特率60Kbps  //则波特率为:36M/((1+2+1)*150)= 60Kbps CAN_Normal_Init(1,2,1,150,1);   
000022  2000              MOVS     r0,#0
000024  234b              MOVS     r3,#0x4b
000026  2202              MOVS     r2,#2
000028  2103              MOVS     r1,#3
00002a  9000              STR      r0,[sp,#0]
00002c  f7fffffe          BL       CAN_Mode_Init
;;;153    	printf("CAN_Mode_Init,CAN_Baud: 60Kbps...\r\n");
000030  a04d              ADR      r0,|L11.360|
000032  f7fffffe          BL       __2printf
;;;154    	
;;;155        printf("-------------------------------------------------------------------\r\n");
000036  4855              LDR      r0,|L11.396|
000038  f7fffffe          BL       __2printf
;;;156    	bsp_StartTimer(1, 200);			//定时器1周期 200毫秒
00003c  21c8              MOVS     r1,#0xc8
00003e  2001              MOVS     r0,#1
000040  f7fffffe          BL       bsp_StartTimer
;;;157    	KMOFF_Show(ALARMALL);
000044  f64070ff          MOV      r0,#0xfff
000048  f7fffffe          BL       KMOFF_Show
;;;158    	HC595_E1_ON();HC595_E2_ON();	
00004c  2104              MOVS     r1,#4
00004e  4850              LDR      r0,|L11.400|
000050  f7fffffe          BL       GPIO_ResetBits
000054  2108              MOVS     r1,#8
000056  484e              LDR      r0,|L11.400|
000058  f7fffffe          BL       GPIO_ResetBits
;;;159    	while (1)
00005c  e081              B        |L11.354|
                  |L11.94|
;;;160    	{
;;;161    		CPU_IDLE();
00005e  f7fffffe          BL       CPU_IDLE
;;;162    		if ( bsp_CheckTimer(1) )	//软定时器
000062  2001              MOVS     r0,#1
000064  f7fffffe          BL       bsp_CheckTimer
000068  2800              CMP      r0,#0
00006a  d07a              BEQ      |L11.354|
;;;163    		{
;;;164    			bsp_StartTimer(1, 200);	//启动下个定时周期
00006c  21c8              MOVS     r1,#0xc8
00006e  2001              MOVS     r0,#1
000070  f7fffffe          BL       bsp_StartTimer
;;;165    			if(Time_250ms<9)	Time_250ms++;
000074  2d09              CMP      r5,#9
000076  da02              BGE      |L11.126|
000078  1c68              ADDS     r0,r5,#1
00007a  b2c5              UXTB     r5,r0
00007c  e000              B        |L11.128|
                  |L11.126|
;;;166    			else	
;;;167    			{	
;;;168    				Time_250ms=0;
00007e  2500              MOVS     r5,#0
                  |L11.128|
;;;169    			}
;;;170    			KeyDat = bsp_GetKey();
000080  f7fffffe          BL       bsp_GetKey
000084  4604              MOV      r4,r0
;;;171    			if(KeyDat!=KEY_NONE)	//按键检测及数据处理
000086  2c00              CMP      r4,#0
000088  d047              BEQ      |L11.282|
;;;172    			{
;;;173    				switch (KeyDat)
00008a  2c0c              CMP      r4,#0xc
00008c  d243              BCS      |L11.278|
00008e  e8dff004          TBB      [pc,r4]
000092  0607              DCB      0x06,0x07
000094  0e421218          DCB      0x0e,0x42,0x12,0x18
000098  421c2342          DCB      0x42,0x1c,0x23,0x42
00009c  2a36              DCB      0x2a,0x36
;;;174    				{
;;;175    					case KEY_NONE:	//无按键按下
;;;176    						break;
00009e  e03b              B        |L11.280|
;;;177    					case KEY_1_DOWN:	//
;;;178    						if(DHT11_Read_Data((uint8_t *)DHT_Dat)==0){;}
0000a0  a808              ADD      r0,sp,#0x20
0000a2  f7fffffe          BL       DHT11_Read_Data
;;;179    						printf("  KEY_1_DOWN!\r\n");
0000a6  a03b              ADR      r0,|L11.404|
0000a8  f7fffffe          BL       __2printf
;;;180    						break;
0000ac  e034              B        |L11.280|
;;;181    					case KEY_1_UP:		//
;;;182    						printf("  KEY_1_UP!\r\n");
0000ae  a03d              ADR      r0,|L11.420|
0000b0  f7fffffe          BL       __2printf
;;;183    						break;
0000b4  e030              B        |L11.280|
;;;184    					case KEY_2_DOWN:	//
;;;185    						printf("  KEY_2_DOWN!\r\n");
0000b6  a03f              ADR      r0,|L11.436|
0000b8  f7fffffe          BL       __2printf
;;;186    						Get_InputValue();
0000bc  f7fffffe          BL       Get_InputValue
;;;187    						break;
0000c0  e02a              B        |L11.280|
;;;188    					case KEY_2_UP:		//
;;;189    						printf("  KEY_2_UP!\r\n");
0000c2  a040              ADR      r0,|L11.452|
0000c4  f7fffffe          BL       __2printf
;;;190    						break;
0000c8  e026              B        |L11.280|
;;;191    					case KEY_3_DOWN:	//
;;;192    						KMON_Show(BKM1RUN);
0000ca  2008              MOVS     r0,#8
0000cc  f7fffffe          BL       KMON_Show
;;;193    						printf("  KEY_3_DOWN!\r\n");
0000d0  a040              ADR      r0,|L11.468|
0000d2  f7fffffe          BL       __2printf
;;;194    						break;
0000d6  e01f              B        |L11.280|
;;;195    					case KEY_3_UP:		//
;;;196    						KMOFF_Show(BKM1RUN);
0000d8  2008              MOVS     r0,#8
0000da  f7fffffe          BL       KMOFF_Show
;;;197    						printf("  KEY_3_UP!\r\n");
0000de  a041              ADR      r0,|L11.484|
0000e0  f7fffffe          BL       __2printf
;;;198    						break;
0000e4  e018              B        |L11.280|
;;;199    					case KEY_4_DOWN:	//
;;;200    						printf("  KEY_4_DOWN!\r\n");
0000e6  a043              ADR      r0,|L11.500|
0000e8  f7fffffe          BL       __2printf
;;;201    						Buff[0]=0xFF;Buff[1]=0xFF;
0000ec  20ff              MOVS     r0,#0xff
0000ee  f88d001c          STRB     r0,[sp,#0x1c]
0000f2  f88d001d          STRB     r0,[sp,#0x1d]
;;;202    						RS485_SendDat((uint8_t *)Buff);
0000f6  a807              ADD      r0,sp,#0x1c
0000f8  f7fffffe          BL       RS485_SendDat
;;;203    						break;
0000fc  e00c              B        |L11.280|
;;;204    					case KEY_4_UP:		//
;;;205    						printf("  KEY_4_UP!\r\n");
0000fe  a041              ADR      r0,|L11.516|
000100  f7fffffe          BL       __2printf
;;;206    						Buff[0]=0x00;Buff[1]=0x00;
000104  2000              MOVS     r0,#0
000106  f88d001c          STRB     r0,[sp,#0x1c]
00010a  f88d001d          STRB     r0,[sp,#0x1d]
;;;207    						RS485_SendDat((uint8_t *)Buff);
00010e  a807              ADD      r0,sp,#0x1c
000110  f7fffffe          BL       RS485_SendDat
;;;208    						break;
000114  e000              B        |L11.280|
                  |L11.278|
;;;209    					default:
;;;210    						break;
000116  bf00              NOP      
                  |L11.280|
000118  bf00              NOP                            ;176
                  |L11.282|
;;;211    				}
;;;212    			}
;;;213    
;;;214    
;;;215    			RS485_ReceiveDat();
00011a  f7fffffe          BL       RS485_ReceiveDat
;;;216    			if( ( 0x80 & RS485_Count ) == 0x80 )	//接收到数据
00011e  483d              LDR      r0,|L11.532|
000120  7800              LDRB     r0,[r0,#0]  ; RS485_Count
000122  f0000080          AND      r0,r0,#0x80
000126  2880              CMP      r0,#0x80
000128  d11b              BNE      |L11.354|
;;;217    			{
;;;218    				RS485_Count = 0;
00012a  2000              MOVS     r0,#0
00012c  4939              LDR      r1,|L11.532|
00012e  7008              STRB     r0,[r1,#0]
;;;219    				printf("RS485:%02X%02X %02X%02X%02X %02X %02X %02X%02X.\r\n",
000130  4839              LDR      r0,|L11.536|
000132  7a00              LDRB     r0,[r0,#8]  ; RS485Dat
000134  4938              LDR      r1,|L11.536|
000136  79c9              LDRB     r1,[r1,#7]  ; RS485Dat
000138  4a37              LDR      r2,|L11.536|
00013a  7992              LDRB     r2,[r2,#6]  ; RS485Dat
00013c  4b36              LDR      r3,|L11.536|
00013e  795b              LDRB     r3,[r3,#5]  ; RS485Dat
000140  e9cd3202          STRD     r3,r2,[sp,#8]
000144  e9cd1004          STRD     r1,r0,[sp,#0x10]
000148  4833              LDR      r0,|L11.536|
00014a  7900              LDRB     r0,[r0,#4]  ; RS485Dat
00014c  4932              LDR      r1,|L11.536|
00014e  78c9              LDRB     r1,[r1,#3]  ; RS485Dat
000150  e9cd1000          STRD     r1,r0,[sp,#0]
000154  4830              LDR      r0,|L11.536|
000156  7883              LDRB     r3,[r0,#2]  ; RS485Dat
000158  7842              LDRB     r2,[r0,#1]  ; RS485Dat
00015a  7801              LDRB     r1,[r0,#0]  ; RS485Dat
00015c  a02f              ADR      r0,|L11.540|
00015e  f7fffffe          BL       __2printf
                  |L11.354|
000162  e77c              B        |L11.94|
;;;220    				RS485Dat[0],RS485Dat[1],RS485Dat[2],RS485Dat[3],RS485Dat[4],RS485Dat[5],RS485Dat[6],RS485Dat[7],RS485Dat[8]); 
;;;221    			}
;;;222    
;;;223    		}
;;;224    
;;;225    	}
;;;226    }
;;;227    
                          ENDP

                  |L11.356|
000164  ff00              DCB      255,0
000166  ff00              DCB      255,0
                  |L11.360|
000168  43414e5f          DCB      "CAN_Mode_Init,CAN_Baud: 60Kbps...\r\n",0
00016c  4d6f6465
000170  5f496e69
000174  742c4341
000178  4e5f4261
00017c  75643a20
000180  36304b62
000184  70732e2e
000188  2e0d0a00
                  |L11.396|
                          DCD      ||.conststring||
                  |L11.400|
                          DCD      0x40010800
                  |L11.404|
000194  20204b45          DCB      "  KEY_1_DOWN!\r\n",0
000198  595f315f
00019c  444f574e
0001a0  210d0a00
                  |L11.420|
0001a4  20204b45          DCB      "  KEY_1_UP!\r\n",0
0001a8  595f315f
0001ac  5550210d
0001b0  0a00    
0001b2  00                DCB      0
0001b3  00                DCB      0
                  |L11.436|
0001b4  20204b45          DCB      "  KEY_2_DOWN!\r\n",0
0001b8  595f325f
0001bc  444f574e
0001c0  210d0a00
                  |L11.452|
0001c4  20204b45          DCB      "  KEY_2_UP!\r\n",0
0001c8  595f325f
0001cc  5550210d
0001d0  0a00    
0001d2  00                DCB      0
0001d3  00                DCB      0
                  |L11.468|
0001d4  20204b45          DCB      "  KEY_3_DOWN!\r\n",0
0001d8  595f335f
0001dc  444f574e
0001e0  210d0a00
                  |L11.484|
0001e4  20204b45          DCB      "  KEY_3_UP!\r\n",0
0001e8  595f335f
0001ec  5550210d
0001f0  0a00    
0001f2  00                DCB      0
0001f3  00                DCB      0
                  |L11.500|
0001f4  20204b45          DCB      "  KEY_4_DOWN!\r\n",0
0001f8  595f345f
0001fc  444f574e
000200  210d0a00
                  |L11.516|
000204  20204b45          DCB      "  KEY_4_UP!\r\n",0
000208  595f345f
00020c  5550210d
000210  0a00    
000212  00                DCB      0
000213  00                DCB      0
                  |L11.532|
                          DCD      RS485_Count
                  |L11.536|
                          DCD      RS485Dat
                  |L11.540|
00021c  52533438          DCB      "RS485:%02X%02X %02X%02X%02X %02X %02X %02X%02X.\r\n",0
000220  353a2530
000224  32582530
000228  32582025
00022c  30325825
000230  30325825
000234  30325820
000238  25303258
00023c  20253032
000240  58202530
000244  32582530
000248  32582e0d
00024c  0a00    
00024e  00                DCB      0
00024f  00                DCB      0

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  2d2d2d2d          DCB      "-------------------------------------------------------"
000004  2d2d2d2d
000008  2d2d2d2d
00000c  2d2d2d2d
000010  2d2d2d2d
000014  2d2d2d2d
000018  2d2d2d2d
00001c  2d2d2d2d
000020  2d2d2d2d
000024  2d2d2d2d
000028  2d2d2d2d
00002c  2d2d2d2d
000030  2d2d2d2d
000034  2d2d2d  
000037  2d2d2d2d          DCB      "------------\r\n",0
00003b  2d2d2d2d
00003f  2d2d2d2d
000043  0d0a00  

                          AREA ||.data||, DATA, ALIGN=2

                  g_RxMessage
000000  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
                  g_RxMessFlag
000008  00                DCB      0x00
                  OutFlag
000009  00                DCB      0x00
                  InPutCount
00000a  0000              DCB      0x00,0x00
                  g_RunningTime
                          DCD      0x00000000
                  Time_count
000010  00                DCB      0x00
                  g_FlagDWG
000011  00                DCB      0x00

                  __ARM_use_no_argv EQU 0
