; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\main.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\main.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User -I"C:\Users\xuan5\Desktop\JOSONG-XS03 V3.0\Project\MDK-ARM(uV4)\RTE" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=521 -D_RTE_ -DSTM32F10X_MD -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=.\flash\obj\main.crf ..\..\User\main.c]
                          THUMB

                          AREA ||i.CPU_IDLE||, CODE, READONLY, ALIGN=2

                  CPU_IDLE PROC
;;;36     }
;;;37     void CPU_IDLE(void)
000000  b510              PUSH     {r4,lr}
;;;38     {
;;;39     	static uint8_t g_FlagDWG=0;
;;;40     	if(++g_FlagDWG%2==0)	HardWDG_ON();
000002  490b              LDR      r1,|L1.48|
000004  7809              LDRB     r1,[r1,#0]  ; g_FlagDWG
000006  1c49              ADDS     r1,r1,#1
000008  b2c9              UXTB     r1,r1
00000a  4a09              LDR      r2,|L1.48|
00000c  7011              STRB     r1,[r2,#0]
00000e  4608              MOV      r0,r1
000010  eb0171d0          ADD      r1,r1,r0,LSR #31
000014  1049              ASRS     r1,r1,#1
000016  eba00141          SUB      r1,r0,r1,LSL #1
00001a  b921              CBNZ     r1,|L1.38|
00001c  2110              MOVS     r1,#0x10
00001e  4805              LDR      r0,|L1.52|
000020  f7fffffe          BL       GPIO_SetBits
000024  e003              B        |L1.46|
                  |L1.38|
;;;41     	else 					HardWDG_OFF();
000026  2110              MOVS     r1,#0x10
000028  4802              LDR      r0,|L1.52|
00002a  f7fffffe          BL       GPIO_ResetBits
                  |L1.46|
;;;42     }
00002e  bd10              POP      {r4,pc}
;;;43     
                          ENDP

                  |L1.48|
                          DCD      g_FlagDWG
                  |L1.52|
                          DCD      0x40010800

                          AREA ||i.Delay||, CODE, READONLY, ALIGN=1

                  Delay PROC
;;;361    
;;;362    void Delay(__IO uint16_t nCount)
000000  b501              PUSH     {r0,lr}
;;;363    {
;;;364    	while (nCount != 0)
000002  e004              B        |L2.14|
                  |L2.4|
;;;365    	{
;;;366    		nCount--;
000004  f8bd0000          LDRH     r0,[sp,#0]
000008  1e40              SUBS     r0,r0,#1
00000a  b280              UXTH     r0,r0
00000c  9000              STR      r0,[sp,#0]
                  |L2.14|
00000e  f8bd0000          LDRH     r0,[sp,#0]            ;364
000012  2800              CMP      r0,#0                 ;364
000014  d1f6              BNE      |L2.4|
;;;367    	}
;;;368    }
000016  bd08              POP      {r3,pc}
;;;369    
                          ENDP


                          AREA ||i.InitBoard||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  InitBoard PROC
;;;300    */
;;;301    static void InitBoard(void)
000000  b510              PUSH     {r4,lr}
;;;302    {	
;;;303    	RCC_Configuration();
000002  f7fffffe          BL       RCC_Configuration
;;;304    	/* 初始化systick定时器，并启动定时中断 */
;;;305    	bsp_InitTimer(); 
000006  f7fffffe          BL       bsp_InitTimer
;;;306    	delay_init();
00000a  f7fffffe          BL       delay_init
;;;307    	delay_ms(500);
00000e  f44f70fa          MOV      r0,#0x1f4
000012  f7fffffe          BL       delay_ms
;;;308    	Init_GPIO();				//输出初始化
000016  f7fffffe          BL       Init_GPIO
;;;309    	bsp_InitKey();
00001a  f7fffffe          BL       bsp_InitKey
;;;310    	bsp_InitUart(); 	    	//初始化串口+RS485
00001e  f7fffffe          BL       bsp_InitUart
;;;311    	printf("\r\nStarting Up...\r\nJOSONG-XS03 V3.0...\r\n");
000022  a014              ADR      r0,|L3.116|
000024  f7fffffe          BL       __2printf
;;;312    	printf("VersionNo: %02X...\r\n",VERSION);
000028  2101              MOVS     r1,#1
00002a  a01c              ADR      r0,|L3.156|
00002c  f7fffffe          BL       __2printf
;;;313    	printf("SystemCoreClock: %d...\r\n",SystemCoreClock);
000030  4820              LDR      r0,|L3.180|
000032  6801              LDR      r1,[r0,#0]  ; SystemCoreClock
000034  a020              ADR      r0,|L3.184|
000036  f7fffffe          BL       __2printf
;;;314    	delay_ms(500);
00003a  f44f70fa          MOV      r0,#0x1f4
00003e  f7fffffe          BL       delay_ms
;;;315    	BspTm1639_Config();	        //TM1639初始化
000042  f7fffffe          BL       BspTm1639_Config
;;;316    	BspDht11_Config();			//温湿度传感器初始化
000046  f7fffffe          BL       BspDht11_Config
;;;317    	bsp_HC595_Config();			//HC595初始化 用于继电器输出
00004a  f7fffffe          BL       bsp_HC595_Config
;;;318    	BspInput_CD4067_Config();	//CD4067初始化 用于信号采集
00004e  f7fffffe          BL       BspInput_CD4067_Config
;;;319    	BspInput_CD4051_Config();	//CD4051*3
000052  f7fffffe          BL       BspInput_CD4051_Config
;;;320    	Bsp_CS5463_Config();
000056  f7fffffe          BL       Bsp_CS5463_Config
;;;321    	CS546x_Init(0);
00005a  2000              MOVS     r0,#0
00005c  f7fffffe          BL       CS546x_Init
;;;322    	TIM3_Int_Init(99,720-1);  	//以100khz的频率计数，0.01ms中断，计数到100 *0.01ms 为1ms 
000060  f24021cf          MOV      r1,#0x2cf
000064  2063              MOVS     r0,#0x63
000066  f7fffffe          BL       TIM3_Int_Init
;;;323    //	TIM2_Cap_Init(0xFFFF,72-1);	//以1Mhz的频率计数 
;;;324     	Adc_Init();		  		    //ADC初始化
00006a  f7fffffe          BL       Adc_Init
;;;325    	bsp_InitCQVar();
00006e  f7fffffe          BL       bsp_InitCQVar
;;;326    }
000072  bd10              POP      {r4,pc}
;;;327    
                          ENDP

                  |L3.116|
000074  0d0a5374          DCB      "\r\nStarting Up...\r\nJOSONG-XS03 V3.0...\r\n",0
000078  61727469
00007c  6e672055
000080  702e2e2e
000084  0d0a4a4f
000088  534f4e47
00008c  2d585330
000090  33205633
000094  2e302e2e
000098  2e0d0a00
                  |L3.156|
00009c  56657273          DCB      "VersionNo: %02X...\r\n",0
0000a0  696f6e4e
0000a4  6f3a2025
0000a8  3032582e
0000ac  2e2e0d0a
0000b0  00      
0000b1  00                DCB      0
0000b2  00                DCB      0
0000b3  00                DCB      0
                  |L3.180|
                          DCD      SystemCoreClock
                  |L3.184|
0000b8  53797374          DCB      "SystemCoreClock: %d...\r\n",0
0000bc  656d436f
0000c0  7265436c
0000c4  6f636b3a
0000c8  2025642e
0000cc  2e2e0d0a
0000d0  00      
0000d1  00                DCB      0
0000d2  00                DCB      0
0000d3  00                DCB      0

                          AREA ||i.Init_GPIO||, CODE, READONLY, ALIGN=2

                  Init_GPIO PROC
;;;89     
;;;90     void Init_GPIO(void)
000000  b508              PUSH     {r3,lr}
;;;91     {
;;;92     	GPIO_InitTypeDef GPIO_InitStructure;
;;;93     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); 
000002  2101              MOVS     r1,#1
000004  2004              MOVS     r0,#4
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;94     
;;;95     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;
00000a  2010              MOVS     r0,#0x10
00000c  f8ad0000          STRH     r0,[sp,#0]
;;;96     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
000010  f88d0003          STRB     r0,[sp,#3]
;;;97     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000014  2003              MOVS     r0,#3
000016  f88d0002          STRB     r0,[sp,#2]
;;;98     	GPIO_Init(GPIOA, &GPIO_InitStructure);
00001a  4669              MOV      r1,sp
00001c  4801              LDR      r0,|L4.36|
00001e  f7fffffe          BL       GPIO_Init
;;;99     }
000022  bd08              POP      {r3,pc}
;;;100    
                          ENDP

                  |L4.36|
                          DCD      0x40010800

                          AREA ||i.NVIC_Configuration||, CODE, READONLY, ALIGN=1

                  NVIC_Configuration PROC
;;;24     
;;;25     void NVIC_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;26     {
;;;27         NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);	//设置NVIC中断分组2:2位抢占优先级，2位响应优先级
000002  f44f60a0          MOV      r0,#0x500
000006  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;28     }
00000a  bd10              POP      {r4,pc}
;;;29     
                          ENDP


                          AREA ||i.PutInMemoryBuf||, CODE, READONLY, ALIGN=2

                  PutInMemoryBuf PROC
;;;61     
;;;62     void PutInMemoryBuf(u8 *Buf)	//末尾加入第一个缓存
000000  b51f              PUSH     {r0-r4,lr}
;;;63     {
000002  4604              MOV      r4,r0
;;;64         uint8_t BufDat[16]={0};
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
000008  9001              STR      r0,[sp,#4]
00000a  9002              STR      r0,[sp,#8]
00000c  9003              STR      r0,[sp,#0xc]
;;;65     	//日志存储
;;;66         BufDat[ 0] = (uint8_t)(g_RunningTime>>24); //时钟
00000e  482a              LDR      r0,|L6.184|
000010  6800              LDR      r0,[r0,#0]  ; g_RunningTime
000012  0e00              LSRS     r0,r0,#24
000014  f88d0000          STRB     r0,[sp,#0]
;;;67         BufDat[ 1] = (uint8_t)(g_RunningTime>>16); //时钟
000018  4827              LDR      r0,|L6.184|
00001a  6800              LDR      r0,[r0,#0]  ; g_RunningTime
00001c  0c00              LSRS     r0,r0,#16
00001e  f88d0001          STRB     r0,[sp,#1]
;;;68         BufDat[ 2] = (uint8_t)(g_RunningTime>>8);  //时钟
000022  4825              LDR      r0,|L6.184|
000024  8800              LDRH     r0,[r0,#0]  ; g_RunningTime
000026  0a00              LSRS     r0,r0,#8
000028  f88d0002          STRB     r0,[sp,#2]
;;;69         BufDat[ 3] = (uint8_t)(g_RunningTime);     //时钟
00002c  4822              LDR      r0,|L6.184|
00002e  7800              LDRB     r0,[r0,#0]  ; g_RunningTime
000030  f88d0003          STRB     r0,[sp,#3]
;;;70         BufDat[ 4] = Buf[1];     	
000034  7860              LDRB     r0,[r4,#1]
000036  f88d0004          STRB     r0,[sp,#4]
;;;71         BufDat[ 5] = Buf[2];     	
00003a  78a0              LDRB     r0,[r4,#2]
00003c  f88d0005          STRB     r0,[sp,#5]
;;;72         BufDat[ 6] = Buf[3];     	
000040  78e0              LDRB     r0,[r4,#3]
000042  f88d0006          STRB     r0,[sp,#6]
;;;73         BufDat[ 7] = Buf[4];     	
000046  7920              LDRB     r0,[r4,#4]
000048  f88d0007          STRB     r0,[sp,#7]
;;;74         BufDat[ 8] = Buf[8];		
00004c  7a20              LDRB     r0,[r4,#8]
00004e  f88d0008          STRB     r0,[sp,#8]
;;;75         BufDat[ 9] = Buf[5];     
000052  7960              LDRB     r0,[r4,#5]
000054  f88d0009          STRB     r0,[sp,#9]
;;;76         BufDat[10] = Buf[6];     
000058  79a0              LDRB     r0,[r4,#6]
00005a  f88d000a          STRB     r0,[sp,#0xa]
;;;77         BufDat[11] = Buf[7];  
00005e  79e0              LDRB     r0,[r4,#7]
000060  f88d000b          STRB     r0,[sp,#0xb]
;;;78         BufDat[12] = Buf[9];
000064  7a60              LDRB     r0,[r4,#9]
000066  f88d000c          STRB     r0,[sp,#0xc]
;;;79         BufDat[13] = Buf[10];
00006a  7aa0              LDRB     r0,[r4,#0xa]
00006c  f88d000d          STRB     r0,[sp,#0xd]
;;;80     	BufDat[14] = 0x02;
000070  2002              MOVS     r0,#2
000072  f88d000e          STRB     r0,[sp,#0xe]
;;;81         BufDat[15] = CRC8_Table(BufDat,15); 	//CRC
000076  210f              MOVS     r1,#0xf
000078  4668              MOV      r0,sp
00007a  f7fffffe          BL       CRC8_Table
00007e  f88d000f          STRB     r0,[sp,#0xf]
;;;82     
;;;83     	memcpy(s_gCQ.Buf[s_gCQ.Write],Buf,10);
000082  480e              LDR      r0,|L6.188|
000084  f89000a1          LDRB     r0,[r0,#0xa1]  ; s_gCQ
000088  490c              LDR      r1,|L6.188|
00008a  eb011000          ADD      r0,r1,r0,LSL #4
00008e  6821              LDR      r1,[r4,#0]
000090  6001              STR      r1,[r0,#0]
000092  6861              LDR      r1,[r4,#4]
000094  6041              STR      r1,[r0,#4]
000096  8921              LDRH     r1,[r4,#8]
000098  8101              STRH     r1,[r0,#8]
;;;84     	if (++s_gCQ.Write  >= CQ_FIFO_SIZE)
00009a  4808              LDR      r0,|L6.188|
00009c  f89000a1          LDRB     r0,[r0,#0xa1]  ; s_gCQ
0000a0  1c40              ADDS     r0,r0,#1
0000a2  b2c0              UXTB     r0,r0
0000a4  4905              LDR      r1,|L6.188|
0000a6  f88100a1          STRB     r0,[r1,#0xa1]
0000aa  280a              CMP      r0,#0xa
0000ac  db02              BLT      |L6.180|
;;;85     	{
;;;86     		s_gCQ.Write = 0;
0000ae  2000              MOVS     r0,#0
0000b0  f88100a1          STRB     r0,[r1,#0xa1]
                  |L6.180|
;;;87     	}
;;;88     }
0000b4  bd1f              POP      {r0-r4,pc}
;;;89     
                          ENDP

0000b6  0000              DCW      0x0000
                  |L6.184|
                          DCD      g_RunningTime
                  |L6.188|
                          DCD      s_gCQ

                          AREA ||i.PutOutMemoryBuf||, CODE, READONLY, ALIGN=2

                  PutOutMemoryBuf PROC
;;;44     
;;;45     uint8_t PutOutMemoryBuf(uint8_t *_Date)	//清第一个缓存
000000  b510              PUSH     {r4,lr}
;;;46     {
000002  4604              MOV      r4,r0
;;;47     	if (s_gCQ.Read == s_gCQ.Write)
000004  4811              LDR      r0,|L7.76|
000006  f89000a0          LDRB     r0,[r0,#0xa0]  ; s_gCQ
00000a  4910              LDR      r1,|L7.76|
00000c  f89110a1          LDRB     r1,[r1,#0xa1]  ; s_gCQ
000010  4288              CMP      r0,r1
000012  d101              BNE      |L7.24|
;;;48     	{
;;;49     		return CQ_NONE;
000014  2000              MOVS     r0,#0
                  |L7.22|
;;;50     	}
;;;51     	else
;;;52     	{
;;;53     		memcpy(_Date,s_gCQ.Buf[s_gCQ.Read],16);
;;;54     		if (++s_gCQ.Read >= CQ_FIFO_SIZE)
;;;55     		{
;;;56     			s_gCQ.Read = 0;
;;;57     		}
;;;58     		return CQ_OK;
;;;59     	}
;;;60     }
000016  bd10              POP      {r4,pc}
                  |L7.24|
000018  480c              LDR      r0,|L7.76|
00001a  f89000a0          LDRB     r0,[r0,#0xa0]         ;53  ; s_gCQ
00001e  4a0b              LDR      r2,|L7.76|
000020  eb021100          ADD      r1,r2,r0,LSL #4       ;53
000024  2210              MOVS     r2,#0x10              ;53
000026  4620              MOV      r0,r4                 ;53
000028  f7fffffe          BL       __aeabi_memcpy
00002c  4807              LDR      r0,|L7.76|
00002e  f89000a0          LDRB     r0,[r0,#0xa0]         ;54  ; s_gCQ
000032  1c40              ADDS     r0,r0,#1              ;54
000034  b2c0              UXTB     r0,r0                 ;54
000036  4905              LDR      r1,|L7.76|
000038  f88100a0          STRB     r0,[r1,#0xa0]         ;54
00003c  280a              CMP      r0,#0xa               ;54
00003e  db02              BLT      |L7.70|
000040  2000              MOVS     r0,#0                 ;56
000042  f88100a0          STRB     r0,[r1,#0xa0]         ;56
                  |L7.70|
000046  2001              MOVS     r0,#1                 ;58
000048  e7e5              B        |L7.22|
;;;61     
                          ENDP

00004a  0000              DCW      0x0000
                  |L7.76|
                          DCD      s_gCQ

                          AREA ||i.RCC_Configuration||, CODE, READONLY, ALIGN=1

                  RCC_Configuration PROC
;;;29     
;;;30     void RCC_Configuration(void)
000000  4770              BX       lr
;;;31     {
;;;32     //    RCC_DeInit();
;;;33     //    RCC_HSEConfig(RCC_HSE_OFF);
;;;34     //    RCC_HSICmd(ENABLE);
;;;35     //    RCC_HSEConfig(RCC_HSE_ON);
;;;36     }
;;;37     void CPU_IDLE(void)
                          ENDP


                          AREA ||i.SoftReset||, CODE, READONLY, ALIGN=2

                  SoftReset PROC
;;;100    
;;;101    void SoftReset(void)
000000  2001              MOVS     r0,#1
000002  f3808813          MSR      FAULTMASK,r0
000006  bf00              NOP      
;;;102    {
;;;103    	__set_FAULTMASK(1);		// 关闭所有中端
;;;104    	NVIC_SystemReset();		// 复位
000008  bf00              NOP      
00000a  4807              LDR      r0,|L9.40|
00000c  6800              LDR      r0,[r0,#0]
00000e  f40060e0          AND      r0,r0,#0x700
000012  4906              LDR      r1,|L9.44|
000014  4308              ORRS     r0,r0,r1
000016  1d00              ADDS     r0,r0,#4
000018  4903              LDR      r1,|L9.40|
00001a  6008              STR      r0,[r1,#0]
00001c  f3bf8f4f          DSB      
000020  bf00              NOP      
000022  bf00              NOP      
                  |L9.36|
000024  e7fe              B        |L9.36|
;;;105    }
;;;106    
                          ENDP

000026  0000              DCW      0x0000
                  |L9.40|
                          DCD      0xe000ed0c
                  |L9.44|
                          DCD      0x05fa0000

                          AREA ||i.TIM3_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM3_IRQHandler PROC
;;;331    //定时器3中断服务程序
;;;332    void TIM3_IRQHandler(void)   //TIM3中断
000000  b510              PUSH     {r4,lr}
;;;333    {
;;;334    	if (TIM_GetITStatus(TIM3, TIM_IT_Update) != RESET)  //TIM3更新中断 1ms中断
000002  2101              MOVS     r1,#1
000004  482a              LDR      r0,|L10.176|
000006  f7fffffe          BL       TIM_GetITStatus
00000a  2800              CMP      r0,#0
00000c  d04f              BEQ      |L10.174|
;;;335    	{
;;;336    		if(Time_count>3000) //3秒周期产生
00000e  4829              LDR      r0,|L10.180|
000010  8800              LDRH     r0,[r0,#0]  ; Time_count
000012  f64031b8          MOV      r1,#0xbb8
000016  4288              CMP      r0,r1
000018  dd0f              BLE      |L10.58|
;;;337            {
;;;338                Time_count = 0;
00001a  2000              MOVS     r0,#0
00001c  4925              LDR      r1,|L10.180|
00001e  8008              STRH     r0,[r1,#0]
;;;339                g_ShowUpDateFlag = (++g_ShowUpDateFlag)%6;  //0-1-2-3-4-5-0
000020  4825              LDR      r0,|L10.184|
000022  7800              LDRB     r0,[r0,#0]  ; g_ShowUpDateFlag
000024  1c40              ADDS     r0,r0,#1
000026  b2c0              UXTB     r0,r0
000028  4923              LDR      r1,|L10.184|
00002a  7008              STRB     r0,[r1,#0]
00002c  2106              MOVS     r1,#6
00002e  fb90f2f1          SDIV     r2,r0,r1
000032  fb010012          MLS      r0,r1,r2,r0
000036  4920              LDR      r1,|L10.184|
000038  7008              STRB     r0,[r1,#0]
                  |L10.58|
;;;340            }
;;;341    		Time_count++;
00003a  481e              LDR      r0,|L10.180|
00003c  8800              LDRH     r0,[r0,#0]  ; Time_count
00003e  1c40              ADDS     r0,r0,#1
000040  491c              LDR      r1,|L10.180|
000042  8008              STRH     r0,[r1,#0]
;;;342            if(StartTimerFlag==0xAA)    
000044  481d              LDR      r0,|L10.188|
000046  7800              LDRB     r0,[r0,#0]  ; StartTimerFlag
000048  28aa              CMP      r0,#0xaa
00004a  d118              BNE      |L10.126|
;;;343            {
;;;344                KMTime_count++;
00004c  481c              LDR      r0,|L10.192|
00004e  8800              LDRH     r0,[r0,#0]  ; KMTime_count
000050  1c40              ADDS     r0,r0,#1
000052  491b              LDR      r1,|L10.192|
000054  8008              STRH     r0,[r1,#0]
;;;345                if(KMTime_count>1000) //1秒周期定时
000056  4608              MOV      r0,r1
000058  8800              LDRH     r0,[r0,#0]  ; KMTime_count
00005a  f5b07f7a          CMP      r0,#0x3e8
00005e  dd16              BLE      |L10.142|
;;;346                {
;;;347                    KMTime_count = 0;
000060  2000              MOVS     r0,#0
000062  8008              STRH     r0,[r1,#0]
;;;348                    KMTime_Sec++;
000064  4817              LDR      r0,|L10.196|
000066  7800              LDRB     r0,[r0,#0]  ; KMTime_Sec
000068  1c40              ADDS     r0,r0,#1
00006a  4916              LDR      r1,|L10.196|
00006c  7008              STRB     r0,[r1,#0]
;;;349                    if(KMTime_Sec>6)    StartTimerFlag = 0xBB;  //定时时间到
00006e  4608              MOV      r0,r1
000070  7800              LDRB     r0,[r0,#0]  ; KMTime_Sec
000072  2806              CMP      r0,#6
000074  dd0b              BLE      |L10.142|
000076  20bb              MOVS     r0,#0xbb
000078  4910              LDR      r1,|L10.188|
00007a  7008              STRB     r0,[r1,#0]
00007c  e007              B        |L10.142|
                  |L10.126|
;;;350                }
;;;351            }
;;;352            else if(StartTimerFlag==0x00)
00007e  480f              LDR      r0,|L10.188|
000080  7800              LDRB     r0,[r0,#0]  ; StartTimerFlag
000082  b920              CBNZ     r0,|L10.142|
;;;353            {
;;;354                KMTime_count = 0;   KMTime_Sec = 0;
000084  2000              MOVS     r0,#0
000086  490e              LDR      r1,|L10.192|
000088  8008              STRH     r0,[r1,#0]
00008a  490e              LDR      r1,|L10.196|
00008c  7008              STRB     r0,[r1,#0]
                  |L10.142|
;;;355            }
;;;356    		SysTick_ISR();	//这个函数在bsp_timer.c中 
00008e  f7fffffe          BL       SysTick_ISR
;;;357    		if((Time_count%10)==0)			bsp_KeyScan();	//每10ms扫描按键一次
000092  4808              LDR      r0,|L10.180|
000094  8800              LDRH     r0,[r0,#0]  ; Time_count
000096  210a              MOVS     r1,#0xa
000098  fb90f2f1          SDIV     r2,r0,r1
00009c  fb010012          MLS      r0,r1,r2,r0
0000a0  b908              CBNZ     r0,|L10.166|
0000a2  f7fffffe          BL       bsp_KeyScan
                  |L10.166|
;;;358    		TIM_ClearITPendingBit(TIM3, TIM_IT_Update  );  	//清除TIMx更新中断标志 					
0000a6  2101              MOVS     r1,#1
0000a8  4801              LDR      r0,|L10.176|
0000aa  f7fffffe          BL       TIM_ClearITPendingBit
                  |L10.174|
;;;359    	}
;;;360    }
0000ae  bd10              POP      {r4,pc}
;;;361    
                          ENDP

                  |L10.176|
                          DCD      0x40000400
                  |L10.180|
                          DCD      Time_count
                  |L10.184|
                          DCD      g_ShowUpDateFlag
                  |L10.188|
                          DCD      StartTimerFlag
                  |L10.192|
                          DCD      KMTime_count
                  |L10.196|
                          DCD      KMTime_Sec

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  main PROC
;;;114    */
;;;115    int main(void)
000000  b51f              PUSH     {r0-r4,lr}
;;;116    {
;;;117    	uint8_t DHT_Dat[5]={0},RS485Dat_Key[2]={0};
000002  2000              MOVS     r0,#0
000004  9002              STR      r0,[sp,#8]
000006  9003              STR      r0,[sp,#0xc]
000008  9001              STR      r0,[sp,#4]
;;;118    	uint8_t Time_250ms=0;
00000a  2600              MOVS     r6,#0
;;;119    	uint8_t KeyDat=0;
00000c  2500              MOVS     r5,#0
;;;120        uint8_t RunMode = 0;    //0手动模式(默认)，1主一备二，2主二备一;
00000e  2400              MOVS     r4,#0
;;;121        uint8_t OldRunMode=0;
000010  2700              MOVS     r7,#0
;;;122        uint8_t RunStape = 0;   //0低速，1高速;
000012  4680              MOV      r8,r0
;;;123    	SystemInit();
000014  f7fffffe          BL       SystemInit
;;;124    	
;;;125    	InitBoard();		//硬件初始化
000018  f7fffffe          BL       InitBoard
;;;126    	BspTm1639_Show(0xA0,0x00);	//上电初始化显示
00001c  2100              MOVS     r1,#0
00001e  20a0              MOVS     r0,#0xa0
000020  f7fffffe          BL       BspTm1639_Show
;;;127    	CAN_Mode_Init(CAN_SJW_1tq,CAN_BS1_4tq,CAN_BS2_3tq,75,CAN_Mode_Normal);	//CAN初始化正常模式,波特率60Kbps  //则波特率为:36M/((1+2+1)*150)= 60Kbps CAN_Normal_Init(1,2,1,150,1);   
000024  2000              MOVS     r0,#0
000026  234b              MOVS     r3,#0x4b
000028  2202              MOVS     r2,#2
00002a  2103              MOVS     r1,#3
00002c  9000              STR      r0,[sp,#0]
00002e  f7fffffe          BL       CAN_Mode_Init
;;;128    	printf("CAN_Mode_Init,CAN_Baud: 60Kbps...\r\n");
000032  a0d9              ADR      r0,|L11.920|
000034  f7fffffe          BL       __2printf
;;;129    	
;;;130        printf("-------------------------------------------------------------------\r\n");
000038  48e0              LDR      r0,|L11.956|
00003a  f7fffffe          BL       __2printf
;;;131    	bsp_StartTimer(1, 200);			//定时器1周期 200毫秒
00003e  21c8              MOVS     r1,#0xc8
000040  2001              MOVS     r0,#1
000042  f7fffffe          BL       bsp_StartTimer
;;;132    	KMOFF_Show(ALARMALL);
000046  f64070ff          MOV      r0,#0xfff
00004a  f7fffffe          BL       KMOFF_Show
;;;133    	HC595_E1_ON();HC595_E2_ON();
00004e  2104              MOVS     r1,#4
000050  48db              LDR      r0,|L11.960|
000052  f7fffffe          BL       GPIO_ResetBits
000056  2108              MOVS     r1,#8
000058  48d9              LDR      r0,|L11.960|
00005a  f7fffffe          BL       GPIO_ResetBits
;;;134        RS485Dat_LED1_ON();	//远程通信指示灯
00005e  f7fffffe          BL       RS485Dat_LED1_ON
;;;135        RS485Dat_LED2_ON(); //主板通信指示灯	
000062  f7fffffe          BL       RS485Dat_LED2_ON
;;;136        RS485Dat_LED12_ON();//A泵停止指示灯
000066  f7fffffe          BL       RS485Dat_LED12_ON
;;;137        RS485Dat_LED13_ON();//A泵停止指示灯
00006a  f7fffffe          BL       RS485Dat_LED13_ON
;;;138        RS485Dat_LED14_ON();//A泵停止指示灯
00006e  f7fffffe          BL       RS485Dat_LED14_ON
;;;139        RS485Dat_LED18_ON();//B泵停止指示灯
000072  f7fffffe          BL       RS485Dat_LED18_ON
;;;140        RS485Dat_LED19_ON();//B泵停止指示灯
000076  f7fffffe          BL       RS485Dat_LED19_ON
;;;141        RS485Dat_LED20_ON();//B泵停止指示灯
00007a  f7fffffe          BL       RS485Dat_LED20_ON
;;;142        RS485Dat_LED16_ON();//手动模式指示灯
00007e  f7fffffe          BL       RS485Dat_LED16_ON
;;;143        while (1)
000082  e188              B        |L11.918|
                  |L11.132|
;;;144    	{
;;;145    		CPU_IDLE();
000084  f7fffffe          BL       CPU_IDLE
;;;146    		if ( bsp_CheckTimer(1) )	//软定时器
000088  2001              MOVS     r0,#1
00008a  f7fffffe          BL       bsp_CheckTimer
00008e  2800              CMP      r0,#0
000090  d077              BEQ      |L11.386|
;;;147    		{
;;;148    			bsp_StartTimer(1, 200);	//启动下个定时周期
000092  21c8              MOVS     r1,#0xc8
000094  2001              MOVS     r0,#1
000096  f7fffffe          BL       bsp_StartTimer
;;;149    			if(Time_250ms<20)	Time_250ms++;
00009a  2e14              CMP      r6,#0x14
00009c  da02              BGE      |L11.164|
00009e  1c70              ADDS     r0,r6,#1
0000a0  b2c6              UXTB     r6,r0
0000a2  e00d              B        |L11.192|
                  |L11.164|
;;;150    			else	
;;;151    			{	
;;;152    				Time_250ms=0;
0000a4  2600              MOVS     r6,#0
;;;153                    if(DHT11_Read_Data((uint8_t *)DHT_Dat)==0)
0000a6  a802              ADD      r0,sp,#8
0000a8  f7fffffe          BL       DHT11_Read_Data
0000ac  b930              CBNZ     r0,|L11.188|
;;;154                    {   g_ShowDat[2] = DHT_Dat[2]; g_ShowDat[3] = DHT_Dat[0];   }
0000ae  f89d000a          LDRB     r0,[sp,#0xa]
0000b2  49c4              LDR      r1,|L11.964|
0000b4  8088              STRH     r0,[r1,#4]
0000b6  f89d0008          LDRB     r0,[sp,#8]
0000ba  80c8              STRH     r0,[r1,#6]
                  |L11.188|
;;;155                    Get_InputValue();
0000bc  f7fffffe          BL       Get_InputValue
                  |L11.192|
;;;156    			}
;;;157                BspTm1639_Show(g_ShowUpDateFlag,g_ShowDat[g_ShowUpDateFlag]);
0000c0  48c0              LDR      r0,|L11.964|
0000c2  4ac1              LDR      r2,|L11.968|
0000c4  7812              LDRB     r2,[r2,#0]  ; g_ShowUpDateFlag
0000c6  f8301012          LDRH     r1,[r0,r2,LSL #1]
0000ca  48bf              LDR      r0,|L11.968|
0000cc  7800              LDRB     r0,[r0,#0]  ; g_ShowUpDateFlag
0000ce  f7fffffe          BL       BspTm1639_Show
;;;158                ReadInputDat();     //读取A/B泵全部状态，存放在结构体中
0000d2  f7fffffe          BL       ReadInputDat
;;;159                DisplaySendDat();   //RS485数据发送
0000d6  f7fffffe          BL       DisplaySendDat
;;;160    			KeyDat = bsp_GetKey();
0000da  f7fffffe          BL       bsp_GetKey
0000de  4605              MOV      r5,r0
;;;161    			if(KeyDat!=KEY_NONE)	//按键检测及数据处理
0000e0  2d00              CMP      r5,#0
0000e2  d030              BEQ      |L11.326|
;;;162    			{
;;;163    				switch (KeyDat)
0000e4  2d0c              CMP      r5,#0xc
0000e6  d22c              BCS      |L11.322|
0000e8  e8dff005          TBB      [pc,r5]
0000ec  06070b2b          DCB      0x06,0x07,0x0b,0x2b
0000f0  0f132b17          DCB      0x0f,0x13,0x2b,0x17
0000f4  1b2b1f25          DCB      0x1b,0x2b,0x1f,0x25
;;;164    				{
;;;165    					case KEY_NONE:	//无按键按下
;;;166    						break;
0000f8  e024              B        |L11.324|
;;;167    					case KEY_1_DOWN:	//						
;;;168    						printf("  KEY_1_DOWN!\r\n");
0000fa  a0b4              ADR      r0,|L11.972|
0000fc  f7fffffe          BL       __2printf
;;;169    						break;
000100  e020              B        |L11.324|
;;;170    					case KEY_1_UP:		//
;;;171    						printf("  KEY_1_UP!\r\n");
000102  a0b6              ADR      r0,|L11.988|
000104  f7fffffe          BL       __2printf
;;;172    						break;
000108  e01c              B        |L11.324|
;;;173    					case KEY_2_DOWN:	//
;;;174    						printf("  KEY_2_DOWN!\r\n");						
00010a  a0b8              ADR      r0,|L11.1004|
00010c  f7fffffe          BL       __2printf
;;;175    						break;
000110  e018              B        |L11.324|
;;;176    					case KEY_2_UP:		//
;;;177    						printf("  KEY_2_UP!\r\n");
000112  a0ba              ADR      r0,|L11.1020|
000114  f7fffffe          BL       __2printf
;;;178    						break;
000118  e014              B        |L11.324|
;;;179    					case KEY_3_DOWN:	//
;;;180    						printf("  KEY_3_DOWN!\r\n");
00011a  a0bc              ADR      r0,|L11.1036|
00011c  f7fffffe          BL       __2printf
;;;181    						break;
000120  e010              B        |L11.324|
;;;182    					case KEY_3_UP:		//
;;;183    						printf("  KEY_3_UP!\r\n");
000122  a0be              ADR      r0,|L11.1052|
000124  f7fffffe          BL       __2printf
;;;184    						break;
000128  e00c              B        |L11.324|
;;;185    					case KEY_4_DOWN:	//
;;;186                            RS485Dat_LED2_ON();
00012a  f7fffffe          BL       RS485Dat_LED2_ON
;;;187    						printf("  KEY_4_DOWN!\r\n");						
00012e  a0bf              ADR      r0,|L11.1068|
000130  f7fffffe          BL       __2printf
;;;188    						break;
000134  e006              B        |L11.324|
;;;189    					case KEY_4_UP:		//
;;;190                            RS485Dat_LED2_OFF();
000136  f7fffffe          BL       RS485Dat_LED2_OFF
;;;191    						printf("  KEY_4_UP!\r\n");
00013a  a0c0              ADR      r0,|L11.1084|
00013c  f7fffffe          BL       __2printf
;;;192    						break;
000140  e000              B        |L11.324|
                  |L11.322|
;;;193    					default:
;;;194    						break;
000142  bf00              NOP      
                  |L11.324|
000144  bf00              NOP                            ;166
                  |L11.326|
;;;195    				}
;;;196    			}
;;;197    
;;;198    			RS485_ReceiveDat();
000146  f7fffffe          BL       RS485_ReceiveDat
;;;199    			if( ( 0x80 & RS485_Count ) == 0x80 )	//接收到数据
00014a  48c0              LDR      r0,|L11.1100|
00014c  7800              LDRB     r0,[r0,#0]  ; RS485_Count
00014e  f0000080          AND      r0,r0,#0x80
000152  2880              CMP      r0,#0x80
000154  d144              BNE      |L11.480|
;;;200    			{
;;;201    				RS485_Count = 0;
000156  2000              MOVS     r0,#0
000158  49bc              LDR      r1,|L11.1100|
00015a  7008              STRB     r0,[r1,#0]
;;;202                    RS485Dat_Key[0] = RS485Dat[4];  RS485Dat_Key[1] = RS485Dat[5];  //获取按键值
00015c  48bc              LDR      r0,|L11.1104|
00015e  7900              LDRB     r0,[r0,#4]  ; RS485Dat
000160  f88d0004          STRB     r0,[sp,#4]
000164  48ba              LDR      r0,|L11.1104|
000166  7940              LDRB     r0,[r0,#5]  ; RS485Dat
000168  f88d0005          STRB     r0,[sp,#5]
;;;203                    if((RS485Dat_Key[0]!=0x00)||(RS485Dat_Key[1]!=0x00))
00016c  f89d0004          LDRB     r0,[sp,#4]
000170  b910              CBNZ     r0,|L11.376|
000172  f89d0005          LDRB     r0,[sp,#5]
000176  b140              CBZ      r0,|L11.394|
                  |L11.376|
;;;204                    printf("RS485_ReceiveDat(),%02X,%02X.\r\n",RS485Dat_Key[0],RS485Dat_Key[1]);
000178  f89d2005          LDRB     r2,[sp,#5]
00017c  f89d1004          LDRB     r1,[sp,#4]
000180  e000              B        |L11.388|
                  |L11.386|
000182  e0f8              B        |L11.886|
                  |L11.388|
000184  a0b3              ADR      r0,|L11.1108|
000186  f7fffffe          BL       __2printf
                  |L11.394|
;;;205                    if((RS485Dat_Key[1]&0x01)==0x01){;}       //系统复位
00018a  f89d0005          LDRB     r0,[sp,#5]
00018e  f0000001          AND      r0,r0,#1
000192  bb28              CBNZ     r0,|L11.480|
;;;206                    else if((RS485Dat_Key[1]&0x08)==0x08){RunMode=1;RS485Dat_Key[0]=0;RS485Dat_Key[1]=0;}  //主一备二
000194  f89d0005          LDRB     r0,[sp,#5]
000198  f0000008          AND      r0,r0,#8
00019c  2808              CMP      r0,#8
00019e  d106              BNE      |L11.430|
0001a0  2401              MOVS     r4,#1
0001a2  2000              MOVS     r0,#0
0001a4  f88d0004          STRB     r0,[sp,#4]
0001a8  f88d0005          STRB     r0,[sp,#5]
0001ac  e018              B        |L11.480|
                  |L11.430|
;;;207                    else if((RS485Dat_Key[1]&0x10)==0x10){RunMode=0;RS485Dat_Key[0]=0;RS485Dat_Key[1]=0;}  //手动模式
0001ae  f89d0005          LDRB     r0,[sp,#5]
0001b2  f0000010          AND      r0,r0,#0x10
0001b6  2810              CMP      r0,#0x10
0001b8  d106              BNE      |L11.456|
0001ba  2400              MOVS     r4,#0
0001bc  2000              MOVS     r0,#0
0001be  f88d0004          STRB     r0,[sp,#4]
0001c2  f88d0005          STRB     r0,[sp,#5]
0001c6  e00b              B        |L11.480|
                  |L11.456|
;;;208                    else if((RS485Dat_Key[1]&0x20)==0x20){RunMode=2;RS485Dat_Key[0]=0;RS485Dat_Key[1]=0;}  //主二备一
0001c8  f89d0005          LDRB     r0,[sp,#5]
0001cc  f0000020          AND      r0,r0,#0x20
0001d0  2820              CMP      r0,#0x20
0001d2  d105              BNE      |L11.480|
0001d4  2402              MOVS     r4,#2
0001d6  2000              MOVS     r0,#0
0001d8  f88d0004          STRB     r0,[sp,#4]
0001dc  f88d0005          STRB     r0,[sp,#5]
                  |L11.480|
;;;209    			}
;;;210                if(RunMode==0)      //手动模式,直接操作继电器输出
0001e0  2c00              CMP      r4,#0
0001e2  d176              BNE      |L11.722|
;;;211                {
;;;212                    RS485Dat_LED15_OFF();RS485Dat_LED16_ON();RS485Dat_LED17_OFF();
0001e4  f7fffffe          BL       RS485Dat_LED15_OFF
0001e8  f7fffffe          BL       RS485Dat_LED16_ON
0001ec  f7fffffe          BL       RS485Dat_LED17_OFF
;;;213                    if((RS485Dat_Key[1]&0x02)==0x02)//A泵停止        
0001f0  f89d0005          LDRB     r0,[sp,#5]
0001f4  f0000002          AND      r0,r0,#2
0001f8  2802              CMP      r0,#2
0001fa  d10c              BNE      |L11.534|
;;;214                    {   
;;;215                        gAp.Statue=Stop;
0001fc  2000              MOVS     r0,#0
0001fe  499d              LDR      r1,|L11.1140|
000200  7008              STRB     r0,[r1,#0]
;;;216                        KMOFF_Show(AKM1RUN);KMOFF_Show(AKM2RUN);KMOFF_Show(AKM3RUN);
000202  2001              MOVS     r0,#1
000204  f7fffffe          BL       KMOFF_Show
000208  2002              MOVS     r0,#2
00020a  f7fffffe          BL       KMOFF_Show
00020e  2004              MOVS     r0,#4
000210  f7fffffe          BL       KMOFF_Show
000214  e06e              B        |L11.756|
                  |L11.534|
;;;217                    }  
;;;218                    else if((RS485Dat_Key[0]&0x01)==0x01)   //A泵低速
000216  f89d0004          LDRB     r0,[sp,#4]
00021a  f0000001          AND      r0,r0,#1
00021e  b158              CBZ      r0,|L11.568|
;;;219                    {   
;;;220                        gAp.Statue=Slow;     
000220  2001              MOVS     r0,#1
000222  4994              LDR      r1,|L11.1140|
000224  7008              STRB     r0,[r1,#0]
;;;221                        KMON_Show(AKM1RUN); KMON_Show(AKM2RUN); KMOFF_Show(AKM3RUN);
000226  f7fffffe          BL       KMON_Show
00022a  2002              MOVS     r0,#2
00022c  f7fffffe          BL       KMON_Show
000230  2004              MOVS     r0,#4
000232  f7fffffe          BL       KMOFF_Show
000236  e05d              B        |L11.756|
                  |L11.568|
;;;222                    }  
;;;223                    else if((RS485Dat_Key[1]&0x04)==0x04)   //A泵高速
000238  f89d0005          LDRB     r0,[sp,#5]
00023c  f0000004          AND      r0,r0,#4
000240  2804              CMP      r0,#4
000242  d10c              BNE      |L11.606|
;;;224                    {   
;;;225                        gAp.Statue=HighSpeed;
000244  2002              MOVS     r0,#2
000246  498b              LDR      r1,|L11.1140|
000248  7008              STRB     r0,[r1,#0]
;;;226                        KMON_Show(AKM1RUN); KMOFF_Show(AKM2RUN);KMON_Show(AKM3RUN); 
00024a  2001              MOVS     r0,#1
00024c  f7fffffe          BL       KMON_Show
000250  2002              MOVS     r0,#2
000252  f7fffffe          BL       KMOFF_Show
000256  2004              MOVS     r0,#4
000258  f7fffffe          BL       KMON_Show
00025c  e04a              B        |L11.756|
                  |L11.606|
;;;227                    }  
;;;228                    else if((RS485Dat_Key[1]&0x40)==0x40)   //B泵停止
00025e  f89d0005          LDRB     r0,[sp,#5]
000262  f0000040          AND      r0,r0,#0x40
000266  2840              CMP      r0,#0x40
000268  d10c              BNE      |L11.644|
;;;229                    {   
;;;230                        gBp.Statue=Stop;     
00026a  2000              MOVS     r0,#0
00026c  4982              LDR      r1,|L11.1144|
00026e  7008              STRB     r0,[r1,#0]
;;;231                        KMOFF_Show(BKM1RUN);KMOFF_Show(BKM2RUN);KMOFF_Show(BKM3RUN);
000270  2008              MOVS     r0,#8
000272  f7fffffe          BL       KMOFF_Show
000276  2010              MOVS     r0,#0x10
000278  f7fffffe          BL       KMOFF_Show
00027c  2020              MOVS     r0,#0x20
00027e  f7fffffe          BL       KMOFF_Show
000282  e037              B        |L11.756|
                  |L11.644|
;;;232                    }  
;;;233                    else if((RS485Dat_Key[0]&0x02)==0x02)   //B泵低速
000284  f89d0004          LDRB     r0,[sp,#4]
000288  f0000002          AND      r0,r0,#2
00028c  2802              CMP      r0,#2
00028e  d10c              BNE      |L11.682|
;;;234                    {   
;;;235                        gBp.Statue=Slow;     
000290  2001              MOVS     r0,#1
000292  4979              LDR      r1,|L11.1144|
000294  7008              STRB     r0,[r1,#0]
;;;236                        KMON_Show(BKM1RUN); KMON_Show(BKM2RUN); KMOFF_Show(BKM3RUN);
000296  2008              MOVS     r0,#8
000298  f7fffffe          BL       KMON_Show
00029c  2010              MOVS     r0,#0x10
00029e  f7fffffe          BL       KMON_Show
0002a2  2020              MOVS     r0,#0x20
0002a4  f7fffffe          BL       KMOFF_Show
0002a8  e024              B        |L11.756|
                  |L11.682|
;;;237                    }  
;;;238                    else if((RS485Dat_Key[1]&0x80)==0x80)   //B泵高速 
0002aa  f89d0005          LDRB     r0,[sp,#5]
0002ae  f0000080          AND      r0,r0,#0x80
0002b2  2880              CMP      r0,#0x80
0002b4  d11e              BNE      |L11.756|
;;;239                    {   
;;;240                        gBp.Statue=HighSpeed;
0002b6  2002              MOVS     r0,#2
0002b8  496f              LDR      r1,|L11.1144|
0002ba  7008              STRB     r0,[r1,#0]
;;;241                        KMON_Show(BKM1RUN); KMOFF_Show(BKM2RUN);KMON_Show(BKM3RUN); 
0002bc  2008              MOVS     r0,#8
0002be  f7fffffe          BL       KMON_Show
0002c2  2010              MOVS     r0,#0x10
0002c4  f7fffffe          BL       KMOFF_Show
0002c8  2020              MOVS     r0,#0x20
0002ca  f7fffffe          BL       KMON_Show
0002ce  e011              B        |L11.756|
0002d0  e7ff              B        |L11.722|
                  |L11.722|
;;;242                    }                 
;;;243                }
;;;244                else if(RunMode==1)  //主一备二
0002d2  2c01              CMP      r4,#1
0002d4  d106              BNE      |L11.740|
;;;245                {
;;;246                    RS485Dat_LED15_ON();RS485Dat_LED16_OFF();RS485Dat_LED17_OFF();
0002d6  f7fffffe          BL       RS485Dat_LED15_ON
0002da  f7fffffe          BL       RS485Dat_LED16_OFF
0002de  f7fffffe          BL       RS485Dat_LED17_OFF
0002e2  e007              B        |L11.756|
                  |L11.740|
;;;247                }
;;;248                else if(RunMode==2)  //主二备一
0002e4  2c02              CMP      r4,#2
0002e6  d105              BNE      |L11.756|
;;;249                {
;;;250                    RS485Dat_LED15_OFF();RS485Dat_LED16_OFF();RS485Dat_LED17_ON();
0002e8  f7fffffe          BL       RS485Dat_LED15_OFF
0002ec  f7fffffe          BL       RS485Dat_LED16_OFF
0002f0  f7fffffe          BL       RS485Dat_LED17_ON
                  |L11.756|
;;;251                }
;;;252                if(RunMode!=OldRunMode) //运行模式切换，把运行模式全部转为停止
0002f4  42bc              CMP      r4,r7
0002f6  d01b              BEQ      |L11.816|
;;;253                {
;;;254                    OldRunMode = RunMode;StartTimerFlag = 0x00;
0002f8  4627              MOV      r7,r4
0002fa  2000              MOVS     r0,#0
0002fc  495f              LDR      r1,|L11.1148|
0002fe  7008              STRB     r0,[r1,#0]
;;;255                    gAp.Statue = Stop;
000300  495c              LDR      r1,|L11.1140|
000302  7008              STRB     r0,[r1,#0]
;;;256                    KMOFF_Show(AKM1RUN);KMOFF_Show(AKM2RUN);KMOFF_Show(AKM3RUN);
000304  2001              MOVS     r0,#1
000306  f7fffffe          BL       KMOFF_Show
00030a  2002              MOVS     r0,#2
00030c  f7fffffe          BL       KMOFF_Show
000310  2004              MOVS     r0,#4
000312  f7fffffe          BL       KMOFF_Show
;;;257                    gBp.Statue = Stop;     
000316  2000              MOVS     r0,#0
000318  4957              LDR      r1,|L11.1144|
00031a  7008              STRB     r0,[r1,#0]
;;;258                    KMOFF_Show(BKM1RUN);KMOFF_Show(BKM2RUN);KMOFF_Show(BKM3RUN);
00031c  2008              MOVS     r0,#8
00031e  f7fffffe          BL       KMOFF_Show
000322  2010              MOVS     r0,#0x10
000324  f7fffffe          BL       KMOFF_Show
000328  2020              MOVS     r0,#0x20
00032a  f7fffffe          BL       KMOFF_Show
00032e  e030              B        |L11.914|
                  |L11.816|
;;;259                }
;;;260                else if(RunMode!=0)  //自动模式
000330  b30c              CBZ      r4,|L11.886|
;;;261                {
;;;262                    if((Read_Optocoupler(8)==0)||(Read_Optocoupler(9)==0)) //远控1/远控2检测
000332  2008              MOVS     r0,#8
000334  f7fffffe          BL       Read_Optocoupler
000338  b118              CBZ      r0,|L11.834|
00033a  2009              MOVS     r0,#9
00033c  f7fffffe          BL       Read_Optocoupler
000340  b9d0              CBNZ     r0,|L11.888|
                  |L11.834|
;;;263                    {
;;;264                        if(StartTimerFlag==0x00)
000342  484e              LDR      r0,|L11.1148|
000344  7800              LDRB     r0,[r0,#0]  ; StartTimerFlag
000346  b948              CBNZ     r0,|L11.860|
;;;265                        {
;;;266                            RunStape = 1;
000348  f04f0801          MOV      r8,#1
;;;267                            StartTimerFlag=0xAA;        //标记进入启动，开启定时功能
00034c  20aa              MOVS     r0,#0xaa
00034e  494b              LDR      r1,|L11.1148|
000350  7008              STRB     r0,[r1,#0]
;;;268                            KMAutoRUN(RunMode,RunStape);//自动启动控制
000352  4641              MOV      r1,r8
000354  4620              MOV      r0,r4
000356  f7fffffe          BL       KMAutoRUN
00035a  e01a              B        |L11.914|
                  |L11.860|
;;;269                        }
;;;270                        else if(StartTimerFlag==0xBB)   //进入第二阶段，定时时间到，该定时在定时器中实现
00035c  4847              LDR      r0,|L11.1148|
00035e  7800              LDRB     r0,[r0,#0]  ; StartTimerFlag
000360  28bb              CMP      r0,#0xbb
000362  d116              BNE      |L11.914|
;;;271                        {
;;;272                            RunStape = 2;
000364  f04f0802          MOV      r8,#2
;;;273                            StartTimerFlag=0xCC;        //标记进入高速运行
000368  20cc              MOVS     r0,#0xcc
00036a  4944              LDR      r1,|L11.1148|
00036c  7008              STRB     r0,[r1,#0]
;;;274                            KMAutoRUN(RunMode,RunStape);//自动启动控制                        
00036e  4641              MOV      r1,r8
000370  4620              MOV      r0,r4
000372  f7fffffe          BL       KMAutoRUN
                  |L11.886|
000376  e00c              B        |L11.914|
                  |L11.888|
;;;275                        }
;;;276                    }
;;;277                    else
;;;278                    {
;;;279                        if(StartTimerFlag==0xCC)
000378  4840              LDR      r0,|L11.1148|
00037a  7800              LDRB     r0,[r0,#0]  ; StartTimerFlag
00037c  28cc              CMP      r0,#0xcc
00037e  d108              BNE      |L11.914|
;;;280                        {
;;;281                            RunStape = 0;
000380  f04f0800          MOV      r8,#0
;;;282                            StartTimerFlag = 0x00;
000384  2000              MOVS     r0,#0
000386  493d              LDR      r1,|L11.1148|
000388  7008              STRB     r0,[r1,#0]
;;;283                            KMAutoRUN(RunMode,RunStape);//自动启动控制
00038a  4641              MOV      r1,r8
00038c  4620              MOV      r0,r4
00038e  f7fffffe          BL       KMAutoRUN
                  |L11.914|
;;;284                        }
;;;285                    }
;;;286                }
;;;287            }
;;;288            KMOutUpdat();   //统一更新继电器输出
000392  f7fffffe          BL       KMOutUpdat
                  |L11.918|
000396  e675              B        |L11.132|
;;;289    
;;;290    	}
;;;291    }
;;;292    
                          ENDP

                  |L11.920|
000398  43414e5f          DCB      "CAN_Mode_Init,CAN_Baud: 60Kbps...\r\n",0
00039c  4d6f6465
0003a0  5f496e69
0003a4  742c4341
0003a8  4e5f4261
0003ac  75643a20
0003b0  36304b62
0003b4  70732e2e
0003b8  2e0d0a00
                  |L11.956|
                          DCD      ||.conststring||
                  |L11.960|
                          DCD      0x40010800
                  |L11.964|
                          DCD      g_ShowDat
                  |L11.968|
                          DCD      g_ShowUpDateFlag
                  |L11.972|
0003cc  20204b45          DCB      "  KEY_1_DOWN!\r\n",0
0003d0  595f315f
0003d4  444f574e
0003d8  210d0a00
                  |L11.988|
0003dc  20204b45          DCB      "  KEY_1_UP!\r\n",0
0003e0  595f315f
0003e4  5550210d
0003e8  0a00    
0003ea  00                DCB      0
0003eb  00                DCB      0
                  |L11.1004|
0003ec  20204b45          DCB      "  KEY_2_DOWN!\r\n",0
0003f0  595f325f
0003f4  444f574e
0003f8  210d0a00
                  |L11.1020|
0003fc  20204b45          DCB      "  KEY_2_UP!\r\n",0
000400  595f325f
000404  5550210d
000408  0a00    
00040a  00                DCB      0
00040b  00                DCB      0
                  |L11.1036|
00040c  20204b45          DCB      "  KEY_3_DOWN!\r\n",0
000410  595f335f
000414  444f574e
000418  210d0a00
                  |L11.1052|
00041c  20204b45          DCB      "  KEY_3_UP!\r\n",0
000420  595f335f
000424  5550210d
000428  0a00    
00042a  00                DCB      0
00042b  00                DCB      0
                  |L11.1068|
00042c  20204b45          DCB      "  KEY_4_DOWN!\r\n",0
000430  595f345f
000434  444f574e
000438  210d0a00
                  |L11.1084|
00043c  20204b45          DCB      "  KEY_4_UP!\r\n",0
000440  595f345f
000444  5550210d
000448  0a00    
00044a  00                DCB      0
00044b  00                DCB      0
                  |L11.1100|
                          DCD      RS485_Count
                  |L11.1104|
                          DCD      RS485Dat
                  |L11.1108|
000454  52533438          DCB      "RS485_ReceiveDat(),%02X,%02X.\r\n",0
000458  355f5265
00045c  63656976
000460  65446174
000464  28292c25
000468  3032582c
00046c  25303258
000470  2e0d0a00
                  |L11.1140|
                          DCD      gAp
                  |L11.1144|
                          DCD      gBp
                  |L11.1148|
                          DCD      StartTimerFlag

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  g_ShowDat
                          %        12

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  2d2d2d2d          DCB      "-------------------------------------------------------"
000004  2d2d2d2d
000008  2d2d2d2d
00000c  2d2d2d2d
000010  2d2d2d2d
000014  2d2d2d2d
000018  2d2d2d2d
00001c  2d2d2d2d
000020  2d2d2d2d
000024  2d2d2d2d
000028  2d2d2d2d
00002c  2d2d2d2d
000030  2d2d2d2d
000034  2d2d2d  
000037  2d2d2d2d          DCB      "------------\r\n",0
00003b  2d2d2d2d
00003f  2d2d2d2d
000043  0d0a00  

                          AREA ||.data||, DATA, ALIGN=2

                  g_RxMessage
000000  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
                  g_RxMessFlag
000008  00                DCB      0x00
                  OutFlag
000009  00                DCB      0x00
                  InPutCount
00000a  00                DCB      0x00
                  g_ShowUpDateFlag
00000b  00                DCB      0x00
                  g_RunningTime
                          DCD      0x00000000
                  StartTimerFlag
000010  0000              DCB      0x00,0x00
                  Time_count
000012  0000              DCW      0x0000
                  KMTime_count
000014  0000              DCW      0x0000
                  KMTime_Sec
000016  00                DCB      0x00
                  g_FlagDWG
000017  00                DCB      0x00

                  __ARM_use_no_argv EQU 0
