; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\main.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\main.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User -I"C:\Users\xuan5\Desktop\JOSONG-XS03 V3.0\Project\MDK-ARM(uV4)\RTE" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=521 -D_RTE_ -DSTM32F10X_MD -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=.\flash\obj\main.crf ..\..\User\main.c]
                          THUMB

                          AREA ||i.CPU_IDLE||, CODE, READONLY, ALIGN=2

                  CPU_IDLE PROC
;;;36     }
;;;37     void CPU_IDLE(void)
000000  b510              PUSH     {r4,lr}
;;;38     {
;;;39     	static uint8_t g_FlagDWG=0;
;;;40     	if(++g_FlagDWG%2==0)	HardWDG_ON();
000002  490b              LDR      r1,|L1.48|
000004  7809              LDRB     r1,[r1,#0]  ; g_FlagDWG
000006  1c49              ADDS     r1,r1,#1
000008  b2c9              UXTB     r1,r1
00000a  4a09              LDR      r2,|L1.48|
00000c  7011              STRB     r1,[r2,#0]
00000e  4608              MOV      r0,r1
000010  eb0171d0          ADD      r1,r1,r0,LSR #31
000014  1049              ASRS     r1,r1,#1
000016  eba00141          SUB      r1,r0,r1,LSL #1
00001a  b921              CBNZ     r1,|L1.38|
00001c  2110              MOVS     r1,#0x10
00001e  4805              LDR      r0,|L1.52|
000020  f7fffffe          BL       GPIO_SetBits
000024  e003              B        |L1.46|
                  |L1.38|
;;;41     	else 					HardWDG_OFF();
000026  2110              MOVS     r1,#0x10
000028  4802              LDR      r0,|L1.52|
00002a  f7fffffe          BL       GPIO_ResetBits
                  |L1.46|
;;;42     }
00002e  bd10              POP      {r4,pc}
;;;43     
                          ENDP

                  |L1.48|
                          DCD      g_FlagDWG
                  |L1.52|
                          DCD      0x40010800

                          AREA ||i.Delay||, CODE, READONLY, ALIGN=1

                  Delay PROC
;;;363    
;;;364    void Delay(__IO uint16_t nCount)
000000  b501              PUSH     {r0,lr}
;;;365    {
;;;366    	while (nCount != 0)
000002  e004              B        |L2.14|
                  |L2.4|
;;;367    	{
;;;368    		nCount--;
000004  f8bd0000          LDRH     r0,[sp,#0]
000008  1e40              SUBS     r0,r0,#1
00000a  b280              UXTH     r0,r0
00000c  9000              STR      r0,[sp,#0]
                  |L2.14|
00000e  f8bd0000          LDRH     r0,[sp,#0]            ;366
000012  2800              CMP      r0,#0                 ;366
000014  d1f6              BNE      |L2.4|
;;;369    	}
;;;370    }
000016  bd08              POP      {r3,pc}
;;;371    
                          ENDP


                          AREA ||i.InitBoard||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  InitBoard PROC
;;;302    */
;;;303    static void InitBoard(void)
000000  b510              PUSH     {r4,lr}
;;;304    {	
;;;305    	RCC_Configuration();
000002  f7fffffe          BL       RCC_Configuration
;;;306    	/* 初始化systick定时器，并启动定时中断 */
;;;307    	bsp_InitTimer(); 
000006  f7fffffe          BL       bsp_InitTimer
;;;308    	delay_init();
00000a  f7fffffe          BL       delay_init
;;;309    	delay_ms(500);
00000e  f44f70fa          MOV      r0,#0x1f4
000012  f7fffffe          BL       delay_ms
;;;310    	Init_GPIO();				//输出初始化
000016  f7fffffe          BL       Init_GPIO
;;;311    	bsp_InitKey();
00001a  f7fffffe          BL       bsp_InitKey
;;;312    	bsp_InitUart(); 	    	//初始化串口+RS485
00001e  f7fffffe          BL       bsp_InitUart
;;;313    	printf("\r\nStarting Up...\r\nJOSONG-XS03 V3.0...\r\n");
000022  a014              ADR      r0,|L3.116|
000024  f7fffffe          BL       __2printf
;;;314    	printf("VersionNo: %02X...\r\n",VERSION);
000028  2101              MOVS     r1,#1
00002a  a01c              ADR      r0,|L3.156|
00002c  f7fffffe          BL       __2printf
;;;315    	printf("SystemCoreClock: %d...\r\n",SystemCoreClock);
000030  4820              LDR      r0,|L3.180|
000032  6801              LDR      r1,[r0,#0]  ; SystemCoreClock
000034  a020              ADR      r0,|L3.184|
000036  f7fffffe          BL       __2printf
;;;316    	delay_ms(500);
00003a  f44f70fa          MOV      r0,#0x1f4
00003e  f7fffffe          BL       delay_ms
;;;317    	BspTm1639_Config();	        //TM1639初始化
000042  f7fffffe          BL       BspTm1639_Config
;;;318    	BspDht11_Config();			//温湿度传感器初始化
000046  f7fffffe          BL       BspDht11_Config
;;;319    	bsp_HC595_Config();			//HC595初始化 用于继电器输出
00004a  f7fffffe          BL       bsp_HC595_Config
;;;320    	BspInput_CD4067_Config();	//CD4067初始化 用于信号采集
00004e  f7fffffe          BL       BspInput_CD4067_Config
;;;321    	BspInput_CD4051_Config();	//CD4051*3
000052  f7fffffe          BL       BspInput_CD4051_Config
;;;322    	Bsp_CS5463_Config();
000056  f7fffffe          BL       Bsp_CS5463_Config
;;;323    	CS546x_Init(0);
00005a  2000              MOVS     r0,#0
00005c  f7fffffe          BL       CS546x_Init
;;;324    	TIM3_Int_Init(99,720-1);  	//以100khz的频率计数，0.01ms中断，计数到100 *0.01ms 为1ms 
000060  f24021cf          MOV      r1,#0x2cf
000064  2063              MOVS     r0,#0x63
000066  f7fffffe          BL       TIM3_Int_Init
;;;325    //	TIM2_Cap_Init(0xFFFF,72-1);	//以1Mhz的频率计数 
;;;326     	Adc_Init();		  		    //ADC初始化
00006a  f7fffffe          BL       Adc_Init
;;;327    	bsp_InitCQVar();
00006e  f7fffffe          BL       bsp_InitCQVar
;;;328    }
000072  bd10              POP      {r4,pc}
;;;329    
                          ENDP

                  |L3.116|
000074  0d0a5374          DCB      "\r\nStarting Up...\r\nJOSONG-XS03 V3.0...\r\n",0
000078  61727469
00007c  6e672055
000080  702e2e2e
000084  0d0a4a4f
000088  534f4e47
00008c  2d585330
000090  33205633
000094  2e302e2e
000098  2e0d0a00
                  |L3.156|
00009c  56657273          DCB      "VersionNo: %02X...\r\n",0
0000a0  696f6e4e
0000a4  6f3a2025
0000a8  3032582e
0000ac  2e2e0d0a
0000b0  00      
0000b1  00                DCB      0
0000b2  00                DCB      0
0000b3  00                DCB      0
                  |L3.180|
                          DCD      SystemCoreClock
                  |L3.184|
0000b8  53797374          DCB      "SystemCoreClock: %d...\r\n",0
0000bc  656d436f
0000c0  7265436c
0000c4  6f636b3a
0000c8  2025642e
0000cc  2e2e0d0a
0000d0  00      
0000d1  00                DCB      0
0000d2  00                DCB      0
0000d3  00                DCB      0

                          AREA ||i.Init_GPIO||, CODE, READONLY, ALIGN=2

                  Init_GPIO PROC
;;;89     
;;;90     void Init_GPIO(void)
000000  b508              PUSH     {r3,lr}
;;;91     {
;;;92     	GPIO_InitTypeDef GPIO_InitStructure;
;;;93     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); 
000002  2101              MOVS     r1,#1
000004  2004              MOVS     r0,#4
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;94     
;;;95     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;
00000a  2010              MOVS     r0,#0x10
00000c  f8ad0000          STRH     r0,[sp,#0]
;;;96     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
000010  f88d0003          STRB     r0,[sp,#3]
;;;97     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000014  2003              MOVS     r0,#3
000016  f88d0002          STRB     r0,[sp,#2]
;;;98     	GPIO_Init(GPIOA, &GPIO_InitStructure);
00001a  4669              MOV      r1,sp
00001c  4801              LDR      r0,|L4.36|
00001e  f7fffffe          BL       GPIO_Init
;;;99     }
000022  bd08              POP      {r3,pc}
;;;100    
                          ENDP

                  |L4.36|
                          DCD      0x40010800

                          AREA ||i.NVIC_Configuration||, CODE, READONLY, ALIGN=1

                  NVIC_Configuration PROC
;;;24     
;;;25     void NVIC_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;26     {
;;;27         NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);	//设置NVIC中断分组2:2位抢占优先级，2位响应优先级
000002  f44f60a0          MOV      r0,#0x500
000006  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;28     }
00000a  bd10              POP      {r4,pc}
;;;29     
                          ENDP


                          AREA ||i.PutInMemoryBuf||, CODE, READONLY, ALIGN=2

                  PutInMemoryBuf PROC
;;;61     
;;;62     void PutInMemoryBuf(u8 *Buf)	//末尾加入第一个缓存
000000  b51f              PUSH     {r0-r4,lr}
;;;63     {
000002  4604              MOV      r4,r0
;;;64         uint8_t BufDat[16]={0};
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
000008  9001              STR      r0,[sp,#4]
00000a  9002              STR      r0,[sp,#8]
00000c  9003              STR      r0,[sp,#0xc]
;;;65     	//日志存储
;;;66         BufDat[ 0] = (uint8_t)(g_RunningTime>>24); //时钟
00000e  482a              LDR      r0,|L6.184|
000010  6800              LDR      r0,[r0,#0]  ; g_RunningTime
000012  0e00              LSRS     r0,r0,#24
000014  f88d0000          STRB     r0,[sp,#0]
;;;67         BufDat[ 1] = (uint8_t)(g_RunningTime>>16); //时钟
000018  4827              LDR      r0,|L6.184|
00001a  6800              LDR      r0,[r0,#0]  ; g_RunningTime
00001c  0c00              LSRS     r0,r0,#16
00001e  f88d0001          STRB     r0,[sp,#1]
;;;68         BufDat[ 2] = (uint8_t)(g_RunningTime>>8);  //时钟
000022  4825              LDR      r0,|L6.184|
000024  8800              LDRH     r0,[r0,#0]  ; g_RunningTime
000026  0a00              LSRS     r0,r0,#8
000028  f88d0002          STRB     r0,[sp,#2]
;;;69         BufDat[ 3] = (uint8_t)(g_RunningTime);     //时钟
00002c  4822              LDR      r0,|L6.184|
00002e  7800              LDRB     r0,[r0,#0]  ; g_RunningTime
000030  f88d0003          STRB     r0,[sp,#3]
;;;70         BufDat[ 4] = Buf[1];     	
000034  7860              LDRB     r0,[r4,#1]
000036  f88d0004          STRB     r0,[sp,#4]
;;;71         BufDat[ 5] = Buf[2];     	
00003a  78a0              LDRB     r0,[r4,#2]
00003c  f88d0005          STRB     r0,[sp,#5]
;;;72         BufDat[ 6] = Buf[3];     	
000040  78e0              LDRB     r0,[r4,#3]
000042  f88d0006          STRB     r0,[sp,#6]
;;;73         BufDat[ 7] = Buf[4];     	
000046  7920              LDRB     r0,[r4,#4]
000048  f88d0007          STRB     r0,[sp,#7]
;;;74         BufDat[ 8] = Buf[8];		
00004c  7a20              LDRB     r0,[r4,#8]
00004e  f88d0008          STRB     r0,[sp,#8]
;;;75         BufDat[ 9] = Buf[5];     
000052  7960              LDRB     r0,[r4,#5]
000054  f88d0009          STRB     r0,[sp,#9]
;;;76         BufDat[10] = Buf[6];     
000058  79a0              LDRB     r0,[r4,#6]
00005a  f88d000a          STRB     r0,[sp,#0xa]
;;;77         BufDat[11] = Buf[7];  
00005e  79e0              LDRB     r0,[r4,#7]
000060  f88d000b          STRB     r0,[sp,#0xb]
;;;78         BufDat[12] = Buf[9];
000064  7a60              LDRB     r0,[r4,#9]
000066  f88d000c          STRB     r0,[sp,#0xc]
;;;79         BufDat[13] = Buf[10];
00006a  7aa0              LDRB     r0,[r4,#0xa]
00006c  f88d000d          STRB     r0,[sp,#0xd]
;;;80     	BufDat[14] = 0x02;
000070  2002              MOVS     r0,#2
000072  f88d000e          STRB     r0,[sp,#0xe]
;;;81         BufDat[15] = CRC8_Table(BufDat,15); 	//CRC
000076  210f              MOVS     r1,#0xf
000078  4668              MOV      r0,sp
00007a  f7fffffe          BL       CRC8_Table
00007e  f88d000f          STRB     r0,[sp,#0xf]
;;;82     
;;;83     	memcpy(s_gCQ.Buf[s_gCQ.Write],Buf,10);
000082  480e              LDR      r0,|L6.188|
000084  f89000a1          LDRB     r0,[r0,#0xa1]  ; s_gCQ
000088  490c              LDR      r1,|L6.188|
00008a  eb011000          ADD      r0,r1,r0,LSL #4
00008e  6821              LDR      r1,[r4,#0]
000090  6001              STR      r1,[r0,#0]
000092  6861              LDR      r1,[r4,#4]
000094  6041              STR      r1,[r0,#4]
000096  8921              LDRH     r1,[r4,#8]
000098  8101              STRH     r1,[r0,#8]
;;;84     	if (++s_gCQ.Write  >= CQ_FIFO_SIZE)
00009a  4808              LDR      r0,|L6.188|
00009c  f89000a1          LDRB     r0,[r0,#0xa1]  ; s_gCQ
0000a0  1c40              ADDS     r0,r0,#1
0000a2  b2c0              UXTB     r0,r0
0000a4  4905              LDR      r1,|L6.188|
0000a6  f88100a1          STRB     r0,[r1,#0xa1]
0000aa  280a              CMP      r0,#0xa
0000ac  db02              BLT      |L6.180|
;;;85     	{
;;;86     		s_gCQ.Write = 0;
0000ae  2000              MOVS     r0,#0
0000b0  f88100a1          STRB     r0,[r1,#0xa1]
                  |L6.180|
;;;87     	}
;;;88     }
0000b4  bd1f              POP      {r0-r4,pc}
;;;89     
                          ENDP

0000b6  0000              DCW      0x0000
                  |L6.184|
                          DCD      g_RunningTime
                  |L6.188|
                          DCD      s_gCQ

                          AREA ||i.PutOutMemoryBuf||, CODE, READONLY, ALIGN=2

                  PutOutMemoryBuf PROC
;;;44     
;;;45     uint8_t PutOutMemoryBuf(uint8_t *_Date)	//清第一个缓存
000000  b510              PUSH     {r4,lr}
;;;46     {
000002  4604              MOV      r4,r0
;;;47     	if (s_gCQ.Read == s_gCQ.Write)
000004  4811              LDR      r0,|L7.76|
000006  f89000a0          LDRB     r0,[r0,#0xa0]  ; s_gCQ
00000a  4910              LDR      r1,|L7.76|
00000c  f89110a1          LDRB     r1,[r1,#0xa1]  ; s_gCQ
000010  4288              CMP      r0,r1
000012  d101              BNE      |L7.24|
;;;48     	{
;;;49     		return CQ_NONE;
000014  2000              MOVS     r0,#0
                  |L7.22|
;;;50     	}
;;;51     	else
;;;52     	{
;;;53     		memcpy(_Date,s_gCQ.Buf[s_gCQ.Read],16);
;;;54     		if (++s_gCQ.Read >= CQ_FIFO_SIZE)
;;;55     		{
;;;56     			s_gCQ.Read = 0;
;;;57     		}
;;;58     		return CQ_OK;
;;;59     	}
;;;60     }
000016  bd10              POP      {r4,pc}
                  |L7.24|
000018  480c              LDR      r0,|L7.76|
00001a  f89000a0          LDRB     r0,[r0,#0xa0]         ;53  ; s_gCQ
00001e  4a0b              LDR      r2,|L7.76|
000020  eb021100          ADD      r1,r2,r0,LSL #4       ;53
000024  2210              MOVS     r2,#0x10              ;53
000026  4620              MOV      r0,r4                 ;53
000028  f7fffffe          BL       __aeabi_memcpy
00002c  4807              LDR      r0,|L7.76|
00002e  f89000a0          LDRB     r0,[r0,#0xa0]         ;54  ; s_gCQ
000032  1c40              ADDS     r0,r0,#1              ;54
000034  b2c0              UXTB     r0,r0                 ;54
000036  4905              LDR      r1,|L7.76|
000038  f88100a0          STRB     r0,[r1,#0xa0]         ;54
00003c  280a              CMP      r0,#0xa               ;54
00003e  db02              BLT      |L7.70|
000040  2000              MOVS     r0,#0                 ;56
000042  f88100a0          STRB     r0,[r1,#0xa0]         ;56
                  |L7.70|
000046  2001              MOVS     r0,#1                 ;58
000048  e7e5              B        |L7.22|
;;;61     
                          ENDP

00004a  0000              DCW      0x0000
                  |L7.76|
                          DCD      s_gCQ

                          AREA ||i.RCC_Configuration||, CODE, READONLY, ALIGN=1

                  RCC_Configuration PROC
;;;29     
;;;30     void RCC_Configuration(void)
000000  4770              BX       lr
;;;31     {
;;;32     //    RCC_DeInit();
;;;33     //    RCC_HSEConfig(RCC_HSE_OFF);
;;;34     //    RCC_HSICmd(ENABLE);
;;;35     //    RCC_HSEConfig(RCC_HSE_ON);
;;;36     }
;;;37     void CPU_IDLE(void)
                          ENDP


                          AREA ||i.SoftReset||, CODE, READONLY, ALIGN=2

                  SoftReset PROC
;;;100    
;;;101    void SoftReset(void)
000000  2001              MOVS     r0,#1
000002  f3808813          MSR      FAULTMASK,r0
000006  bf00              NOP      
;;;102    {
;;;103    	__set_FAULTMASK(1);		// 关闭所有中端
;;;104    	NVIC_SystemReset();		// 复位
000008  bf00              NOP      
00000a  4807              LDR      r0,|L9.40|
00000c  6800              LDR      r0,[r0,#0]
00000e  f40060e0          AND      r0,r0,#0x700
000012  4906              LDR      r1,|L9.44|
000014  4308              ORRS     r0,r0,r1
000016  1d00              ADDS     r0,r0,#4
000018  4903              LDR      r1,|L9.40|
00001a  6008              STR      r0,[r1,#0]
00001c  f3bf8f4f          DSB      
000020  bf00              NOP      
000022  bf00              NOP      
                  |L9.36|
000024  e7fe              B        |L9.36|
;;;105    }
;;;106    
                          ENDP

000026  0000              DCW      0x0000
                  |L9.40|
                          DCD      0xe000ed0c
                  |L9.44|
                          DCD      0x05fa0000

                          AREA ||i.TIM3_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM3_IRQHandler PROC
;;;333    //定时器3中断服务程序
;;;334    void TIM3_IRQHandler(void)   //TIM3中断
000000  b510              PUSH     {r4,lr}
;;;335    {
;;;336    	if (TIM_GetITStatus(TIM3, TIM_IT_Update) != RESET)  //TIM3更新中断 1ms中断
000002  2101              MOVS     r1,#1
000004  482a              LDR      r0,|L10.176|
000006  f7fffffe          BL       TIM_GetITStatus
00000a  2800              CMP      r0,#0
00000c  d04f              BEQ      |L10.174|
;;;337    	{
;;;338    		if(Time_count>3000) //3秒周期产生
00000e  4829              LDR      r0,|L10.180|
000010  8800              LDRH     r0,[r0,#0]  ; Time_count
000012  f64031b8          MOV      r1,#0xbb8
000016  4288              CMP      r0,r1
000018  dd0f              BLE      |L10.58|
;;;339            {
;;;340                Time_count = 0;
00001a  2000              MOVS     r0,#0
00001c  4925              LDR      r1,|L10.180|
00001e  8008              STRH     r0,[r1,#0]
;;;341                g_ShowUpDateFlag = (++g_ShowUpDateFlag)%6;  //0-1-2-3-4-5-0
000020  4825              LDR      r0,|L10.184|
000022  7800              LDRB     r0,[r0,#0]  ; g_ShowUpDateFlag
000024  1c40              ADDS     r0,r0,#1
000026  b2c0              UXTB     r0,r0
000028  4923              LDR      r1,|L10.184|
00002a  7008              STRB     r0,[r1,#0]
00002c  2106              MOVS     r1,#6
00002e  fb90f2f1          SDIV     r2,r0,r1
000032  fb010012          MLS      r0,r1,r2,r0
000036  4920              LDR      r1,|L10.184|
000038  7008              STRB     r0,[r1,#0]
                  |L10.58|
;;;342            }
;;;343    		Time_count++;
00003a  481e              LDR      r0,|L10.180|
00003c  8800              LDRH     r0,[r0,#0]  ; Time_count
00003e  1c40              ADDS     r0,r0,#1
000040  491c              LDR      r1,|L10.180|
000042  8008              STRH     r0,[r1,#0]
;;;344            if(StartTimerFlag==0xAA)    
000044  481d              LDR      r0,|L10.188|
000046  7800              LDRB     r0,[r0,#0]  ; StartTimerFlag
000048  28aa              CMP      r0,#0xaa
00004a  d118              BNE      |L10.126|
;;;345            {
;;;346                KMTime_count++;
00004c  481c              LDR      r0,|L10.192|
00004e  8800              LDRH     r0,[r0,#0]  ; KMTime_count
000050  1c40              ADDS     r0,r0,#1
000052  491b              LDR      r1,|L10.192|
000054  8008              STRH     r0,[r1,#0]
;;;347                if(KMTime_count>1000) //1秒周期定时
000056  4608              MOV      r0,r1
000058  8800              LDRH     r0,[r0,#0]  ; KMTime_count
00005a  f5b07f7a          CMP      r0,#0x3e8
00005e  dd16              BLE      |L10.142|
;;;348                {
;;;349                    KMTime_count = 0;
000060  2000              MOVS     r0,#0
000062  8008              STRH     r0,[r1,#0]
;;;350                    KMTime_Sec++;
000064  4817              LDR      r0,|L10.196|
000066  7800              LDRB     r0,[r0,#0]  ; KMTime_Sec
000068  1c40              ADDS     r0,r0,#1
00006a  4916              LDR      r1,|L10.196|
00006c  7008              STRB     r0,[r1,#0]
;;;351                    if(KMTime_Sec>6)    StartTimerFlag = 0xBB;  //定时时间到
00006e  4608              MOV      r0,r1
000070  7800              LDRB     r0,[r0,#0]  ; KMTime_Sec
000072  2806              CMP      r0,#6
000074  dd0b              BLE      |L10.142|
000076  20bb              MOVS     r0,#0xbb
000078  4910              LDR      r1,|L10.188|
00007a  7008              STRB     r0,[r1,#0]
00007c  e007              B        |L10.142|
                  |L10.126|
;;;352                }
;;;353            }
;;;354            else if(StartTimerFlag==0x00)
00007e  480f              LDR      r0,|L10.188|
000080  7800              LDRB     r0,[r0,#0]  ; StartTimerFlag
000082  b920              CBNZ     r0,|L10.142|
;;;355            {
;;;356                KMTime_count = 0;   KMTime_Sec = 0;
000084  2000              MOVS     r0,#0
000086  490e              LDR      r1,|L10.192|
000088  8008              STRH     r0,[r1,#0]
00008a  490e              LDR      r1,|L10.196|
00008c  7008              STRB     r0,[r1,#0]
                  |L10.142|
;;;357            }
;;;358    		SysTick_ISR();	//这个函数在bsp_timer.c中 
00008e  f7fffffe          BL       SysTick_ISR
;;;359    		if((Time_count%10)==0)			bsp_KeyScan();	//每10ms扫描按键一次
000092  4808              LDR      r0,|L10.180|
000094  8800              LDRH     r0,[r0,#0]  ; Time_count
000096  210a              MOVS     r1,#0xa
000098  fb90f2f1          SDIV     r2,r0,r1
00009c  fb010012          MLS      r0,r1,r2,r0
0000a0  b908              CBNZ     r0,|L10.166|
0000a2  f7fffffe          BL       bsp_KeyScan
                  |L10.166|
;;;360    		TIM_ClearITPendingBit(TIM3, TIM_IT_Update  );  	//清除TIMx更新中断标志 					
0000a6  2101              MOVS     r1,#1
0000a8  4801              LDR      r0,|L10.176|
0000aa  f7fffffe          BL       TIM_ClearITPendingBit
                  |L10.174|
;;;361    	}
;;;362    }
0000ae  bd10              POP      {r4,pc}
;;;363    
                          ENDP

                  |L10.176|
                          DCD      0x40000400
                  |L10.180|
                          DCD      Time_count
                  |L10.184|
                          DCD      g_ShowUpDateFlag
                  |L10.188|
                          DCD      StartTimerFlag
                  |L10.192|
                          DCD      KMTime_count
                  |L10.196|
                          DCD      KMTime_Sec

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;114    */
;;;115    int main(void)
000000  b51f              PUSH     {r0-r4,lr}
;;;116    {
;;;117    	uint8_t DHT_Dat[5]={0},RS485Dat_Key[2]={0};
000002  2000              MOVS     r0,#0
000004  9002              STR      r0,[sp,#8]
000006  9003              STR      r0,[sp,#0xc]
000008  9001              STR      r0,[sp,#4]
;;;118    	uint8_t Time_250ms=0;
00000a  2600              MOVS     r6,#0
;;;119    	uint8_t KeyDat=0;
00000c  2500              MOVS     r5,#0
;;;120        uint8_t RunMode = 0;    //0手动模式(默认)，1主一备二，2主二备一;
00000e  2400              MOVS     r4,#0
;;;121        uint8_t OldRunMode=0;
000010  2700              MOVS     r7,#0
;;;122        uint8_t RunStape = 0;   //0低速，1高速;
000012  4680              MOV      r8,r0
;;;123    	SystemInit();
000014  f7fffffe          BL       SystemInit
;;;124    	
;;;125    	InitBoard();		//硬件初始化
000018  f7fffffe          BL       InitBoard
;;;126    	BspTm1639_Show(0xA0,0x00);	//上电初始化显示
00001c  2100              MOVS     r1,#0
00001e  20a0              MOVS     r0,#0xa0
000020  f7fffffe          BL       BspTm1639_Show
;;;127    	CAN_Mode_Init(CAN_SJW_1tq,CAN_BS1_4tq,CAN_BS2_3tq,75,CAN_Mode_Normal);	//CAN初始化正常模式,波特率60Kbps  //则波特率为:36M/((1+2+1)*150)= 60Kbps CAN_Normal_Init(1,2,1,150,1);   
000024  2000              MOVS     r0,#0
000026  234b              MOVS     r3,#0x4b
000028  2202              MOVS     r2,#2
00002a  2103              MOVS     r1,#3
00002c  9000              STR      r0,[sp,#0]
00002e  f7fffffe          BL       CAN_Mode_Init
;;;128    	printf("CAN_Mode_Init,CAN_Baud: 60Kbps...\r\n");
000032  a0d5              ADR      r0,|L11.904|
000034  f7fffffe          BL       __2printf
;;;129    	
;;;130        printf("-------------------------------------------------------------------\r\n");
000038  48dc              LDR      r0,|L11.940|
00003a  f7fffffe          BL       __2printf
;;;131    	bsp_StartTimer(1, 200);			//定时器1周期 200毫秒
00003e  21c8              MOVS     r1,#0xc8
000040  2001              MOVS     r0,#1
000042  f7fffffe          BL       bsp_StartTimer
;;;132    	KMOFF_Show(ALARMALL);
000046  f64070ff          MOV      r0,#0xfff
00004a  f7fffffe          BL       KMOFF_Show
;;;133    	HC595_E1_ON();HC595_E2_ON();
00004e  2104              MOVS     r1,#4
000050  48d7              LDR      r0,|L11.944|
000052  f7fffffe          BL       GPIO_ResetBits
000056  2108              MOVS     r1,#8
000058  48d5              LDR      r0,|L11.944|
00005a  f7fffffe          BL       GPIO_ResetBits
;;;134        RS485Dat_LED1_ON();	//远程通信指示灯
00005e  f7fffffe          BL       RS485Dat_LED1_ON
;;;135        RS485Dat_LED2_ON(); //主板通信指示灯	
000062  f7fffffe          BL       RS485Dat_LED2_ON
;;;136        RS485Dat_LED12_ON();//A泵停止指示灯
000066  f7fffffe          BL       RS485Dat_LED12_ON
;;;137        RS485Dat_LED13_ON();//A泵停止指示灯
00006a  f7fffffe          BL       RS485Dat_LED13_ON
;;;138        RS485Dat_LED14_ON();//A泵停止指示灯
00006e  f7fffffe          BL       RS485Dat_LED14_ON
;;;139        RS485Dat_LED18_ON();//B泵停止指示灯
000072  f7fffffe          BL       RS485Dat_LED18_ON
;;;140        RS485Dat_LED19_ON();//B泵停止指示灯
000076  f7fffffe          BL       RS485Dat_LED19_ON
;;;141        RS485Dat_LED20_ON();//B泵停止指示灯
00007a  f7fffffe          BL       RS485Dat_LED20_ON
;;;142        RS485Dat_LED16_ON();//手动模式指示灯
00007e  f7fffffe          BL       RS485Dat_LED16_ON
;;;143        while (1)
000082  e180              B        |L11.902|
                  |L11.132|
;;;144    	{
;;;145    		CPU_IDLE();
000084  f7fffffe          BL       CPU_IDLE
;;;146    		if ( bsp_CheckTimer(1) )	//软定时器
000088  2001              MOVS     r0,#1
00008a  f7fffffe          BL       bsp_CheckTimer
00008e  2800              CMP      r0,#0
000090  d07e              BEQ      |L11.400|
;;;147    		{
;;;148    			bsp_StartTimer(1, 200);	//启动下个定时周期
000092  21c8              MOVS     r1,#0xc8
000094  2001              MOVS     r0,#1
000096  f7fffffe          BL       bsp_StartTimer
;;;149    			if(Time_250ms<20)	Time_250ms++;
00009a  2e14              CMP      r6,#0x14
00009c  da02              BGE      |L11.164|
00009e  1c70              ADDS     r0,r6,#1
0000a0  b2c6              UXTB     r6,r0
0000a2  e00d              B        |L11.192|
                  |L11.164|
;;;150    			else	
;;;151    			{	
;;;152    				Time_250ms=0;
0000a4  2600              MOVS     r6,#0
;;;153                    if(DHT11_Read_Data((uint8_t *)DHT_Dat)==0)
0000a6  a802              ADD      r0,sp,#8
0000a8  f7fffffe          BL       DHT11_Read_Data
0000ac  b930              CBNZ     r0,|L11.188|
;;;154                    {   g_ShowDat[2] = DHT_Dat[2]; g_ShowDat[3] = DHT_Dat[0];   }
0000ae  f89d000a          LDRB     r0,[sp,#0xa]
0000b2  49c0              LDR      r1,|L11.948|
0000b4  8088              STRH     r0,[r1,#4]
0000b6  f89d0008          LDRB     r0,[sp,#8]
0000ba  80c8              STRH     r0,[r1,#6]
                  |L11.188|
;;;155                    Get_InputValue();
0000bc  f7fffffe          BL       Get_InputValue
                  |L11.192|
;;;156    			}
;;;157                BspTm1639_Show(g_ShowUpDateFlag,g_ShowDat[g_ShowUpDateFlag]);
0000c0  48bc              LDR      r0,|L11.948|
0000c2  4abd              LDR      r2,|L11.952|
0000c4  7812              LDRB     r2,[r2,#0]  ; g_ShowUpDateFlag
0000c6  f8301012          LDRH     r1,[r0,r2,LSL #1]
0000ca  48bb              LDR      r0,|L11.952|
0000cc  7800              LDRB     r0,[r0,#0]  ; g_ShowUpDateFlag
0000ce  f7fffffe          BL       BspTm1639_Show
;;;158                ReadInputDat();     //读取A/B泵全部状态，存放在结构体中
0000d2  f7fffffe          BL       ReadInputDat
;;;159                DisplaySendDat();   //RS485数据发送
0000d6  f7fffffe          BL       DisplaySendDat
;;;160    			KeyDat = bsp_GetKey();
0000da  f7fffffe          BL       bsp_GetKey
0000de  4605              MOV      r5,r0
;;;161    			if(KeyDat!=KEY_NONE)	//按键检测及数据处理
0000e0  2d00              CMP      r5,#0
0000e2  d030              BEQ      |L11.326|
;;;162    			{
;;;163    				switch (KeyDat)
0000e4  2d0c              CMP      r5,#0xc
0000e6  d22c              BCS      |L11.322|
0000e8  e8dff005          TBB      [pc,r5]
0000ec  06070b2b          DCB      0x06,0x07,0x0b,0x2b
0000f0  0f132b17          DCB      0x0f,0x13,0x2b,0x17
0000f4  1b2b1f25          DCB      0x1b,0x2b,0x1f,0x25
;;;164    				{
;;;165    					case KEY_NONE:	//无按键按下
;;;166    						break;
0000f8  e024              B        |L11.324|
;;;167    					case KEY_1_DOWN:	//						
;;;168    						printf("  KEY_1_DOWN!\r\n");
0000fa  a0b0              ADR      r0,|L11.956|
0000fc  f7fffffe          BL       __2printf
;;;169    						break;
000100  e020              B        |L11.324|
;;;170    					case KEY_1_UP:		//
;;;171    						printf("  KEY_1_UP!\r\n");
000102  a0b2              ADR      r0,|L11.972|
000104  f7fffffe          BL       __2printf
;;;172    						break;
000108  e01c              B        |L11.324|
;;;173    					case KEY_2_DOWN:	//
;;;174    						printf("  KEY_2_DOWN!\r\n");						
00010a  a0b4              ADR      r0,|L11.988|
00010c  f7fffffe          BL       __2printf
;;;175    						break;
000110  e018              B        |L11.324|
;;;176    					case KEY_2_UP:		//
;;;177    						printf("  KEY_2_UP!\r\n");
000112  a0b6              ADR      r0,|L11.1004|
000114  f7fffffe          BL       __2printf
;;;178    						break;
000118  e014              B        |L11.324|
;;;179    					case KEY_3_DOWN:	//
;;;180    						printf("  KEY_3_DOWN!\r\n");
00011a  a0b8              ADR      r0,|L11.1020|
00011c  f7fffffe          BL       __2printf
;;;181    						break;
000120  e010              B        |L11.324|
;;;182    					case KEY_3_UP:		//
;;;183    						printf("  KEY_3_UP!\r\n");
000122  a0ba              ADR      r0,|L11.1036|
000124  f7fffffe          BL       __2printf
;;;184    						break;
000128  e00c              B        |L11.324|
;;;185    					case KEY_4_DOWN:	//
;;;186                            RS485Dat_LED2_ON();
00012a  f7fffffe          BL       RS485Dat_LED2_ON
;;;187    						printf("  KEY_4_DOWN!\r\n");						
00012e  a0bb              ADR      r0,|L11.1052|
000130  f7fffffe          BL       __2printf
;;;188    						break;
000134  e006              B        |L11.324|
;;;189    					case KEY_4_UP:		//
;;;190                            RS485Dat_LED2_OFF();
000136  f7fffffe          BL       RS485Dat_LED2_OFF
;;;191    						printf("  KEY_4_UP!\r\n");
00013a  a0bc              ADR      r0,|L11.1068|
00013c  f7fffffe          BL       __2printf
;;;192    						break;
000140  e000              B        |L11.324|
                  |L11.322|
;;;193    					default:
;;;194    						break;
000142  bf00              NOP      
                  |L11.324|
000144  bf00              NOP                            ;166
                  |L11.326|
;;;195    				}
;;;196    			}
;;;197    
;;;198    			RS485_ReceiveDat();
000146  f7fffffe          BL       RS485_ReceiveDat
;;;199    			if( ( 0x80 & RS485_Count ) == 0x80 )	//接收到数据
00014a  48bc              LDR      r0,|L11.1084|
00014c  7800              LDRB     r0,[r0,#0]  ; RS485_Count
00014e  f0000080          AND      r0,r0,#0x80
000152  2880              CMP      r0,#0x80
000154  d13d              BNE      |L11.466|
;;;200    			{
;;;201    				RS485_Count = 0;
000156  2000              MOVS     r0,#0
000158  49b8              LDR      r1,|L11.1084|
00015a  7008              STRB     r0,[r1,#0]
;;;202                    RS485Dat_Key[0] = RS485Dat[4];  RS485Dat_Key[1] = RS485Dat[5];  //获取按键值
00015c  48b8              LDR      r0,|L11.1088|
00015e  7900              LDRB     r0,[r0,#4]  ; RS485Dat
000160  f88d0004          STRB     r0,[sp,#4]
000164  48b6              LDR      r0,|L11.1088|
000166  7940              LDRB     r0,[r0,#5]  ; RS485Dat
000168  f88d0005          STRB     r0,[sp,#5]
;;;203                    if((RS485Dat_Key[0]!=0x00)||(RS485Dat_Key[1]!=0x00))
00016c  f89d0004          LDRB     r0,[sp,#4]
000170  b910              CBNZ     r0,|L11.376|
000172  f89d0005          LDRB     r0,[sp,#5]
000176  b1f8              CBZ      r0,|L11.440|
                  |L11.376|
;;;204                    {
;;;205                        //printf("RS485_ReceiveDat(),%02X,%02X.\r\n",RS485Dat_Key[0],RS485Dat_Key[1]);
;;;206                        if((RS485Dat_Key[1]&0x01)==0x01){;}       //系统复位
000178  f89d0005          LDRB     r0,[sp,#5]
00017c  f0000001          AND      r0,r0,#1
000180  b9d0              CBNZ     r0,|L11.440|
;;;207                        else if((RS485Dat_Key[1]&0x08)==0x08){RunMode=1;RS485Dat_Key[0]=0;RS485Dat_Key[1]=0;}  //主一备二
000182  f89d0005          LDRB     r0,[sp,#5]
000186  f0000008          AND      r0,r0,#8
00018a  2808              CMP      r0,#8
00018c  d108              BNE      |L11.416|
00018e  e000              B        |L11.402|
                  |L11.400|
000190  e0ea              B        |L11.872|
                  |L11.402|
000192  2401              MOVS     r4,#1
000194  2000              MOVS     r0,#0
000196  f88d0004          STRB     r0,[sp,#4]
00019a  f88d0005          STRB     r0,[sp,#5]
00019e  e018              B        |L11.466|
                  |L11.416|
;;;208                        else if((RS485Dat_Key[1]&0x10)==0x10){RunMode=0;RS485Dat_Key[0]=0;RS485Dat_Key[1]=0;}  //手动模式
0001a0  f89d0005          LDRB     r0,[sp,#5]
0001a4  f0000010          AND      r0,r0,#0x10
0001a8  2810              CMP      r0,#0x10
0001aa  d106              BNE      |L11.442|
0001ac  2400              MOVS     r4,#0
0001ae  2000              MOVS     r0,#0
0001b0  f88d0004          STRB     r0,[sp,#4]
0001b4  f88d0005          STRB     r0,[sp,#5]
                  |L11.440|
0001b8  e00b              B        |L11.466|
                  |L11.442|
;;;209                        else if((RS485Dat_Key[1]&0x20)==0x20){RunMode=2;RS485Dat_Key[0]=0;RS485Dat_Key[1]=0;}  //主二备一
0001ba  f89d0005          LDRB     r0,[sp,#5]
0001be  f0000020          AND      r0,r0,#0x20
0001c2  2820              CMP      r0,#0x20
0001c4  d105              BNE      |L11.466|
0001c6  2402              MOVS     r4,#2
0001c8  2000              MOVS     r0,#0
0001ca  f88d0004          STRB     r0,[sp,#4]
0001ce  f88d0005          STRB     r0,[sp,#5]
                  |L11.466|
;;;210                    }
;;;211    			}
;;;212                if(RunMode==0)      //手动模式,直接操作继电器输出
0001d2  2c00              CMP      r4,#0
0001d4  d176              BNE      |L11.708|
;;;213                {
;;;214                    RS485Dat_LED15_OFF();RS485Dat_LED16_ON();RS485Dat_LED17_OFF();
0001d6  f7fffffe          BL       RS485Dat_LED15_OFF
0001da  f7fffffe          BL       RS485Dat_LED16_ON
0001de  f7fffffe          BL       RS485Dat_LED17_OFF
;;;215                    if((RS485Dat_Key[1]&0x02)==0x02)//A泵停止        
0001e2  f89d0005          LDRB     r0,[sp,#5]
0001e6  f0000002          AND      r0,r0,#2
0001ea  2802              CMP      r0,#2
0001ec  d10c              BNE      |L11.520|
;;;216                    {   
;;;217                        gAp.Statue=Stop;
0001ee  2000              MOVS     r0,#0
0001f0  4994              LDR      r1,|L11.1092|
0001f2  7008              STRB     r0,[r1,#0]
;;;218                        KMOFF_Show(AKM1RUN);KMOFF_Show(AKM2RUN);KMOFF_Show(AKM3RUN);
0001f4  2001              MOVS     r0,#1
0001f6  f7fffffe          BL       KMOFF_Show
0001fa  2002              MOVS     r0,#2
0001fc  f7fffffe          BL       KMOFF_Show
000200  2004              MOVS     r0,#4
000202  f7fffffe          BL       KMOFF_Show
000206  e06e              B        |L11.742|
                  |L11.520|
;;;219                    }  
;;;220                    else if((RS485Dat_Key[0]&0x01)==0x01)   //A泵低速
000208  f89d0004          LDRB     r0,[sp,#4]
00020c  f0000001          AND      r0,r0,#1
000210  b158              CBZ      r0,|L11.554|
;;;221                    {   
;;;222                        gAp.Statue=Slow;     
000212  2001              MOVS     r0,#1
000214  498b              LDR      r1,|L11.1092|
000216  7008              STRB     r0,[r1,#0]
;;;223                        KMON_Show(AKM1RUN); KMON_Show(AKM2RUN); KMOFF_Show(AKM3RUN);
000218  f7fffffe          BL       KMON_Show
00021c  2002              MOVS     r0,#2
00021e  f7fffffe          BL       KMON_Show
000222  2004              MOVS     r0,#4
000224  f7fffffe          BL       KMOFF_Show
000228  e05d              B        |L11.742|
                  |L11.554|
;;;224                    }  
;;;225                    else if((RS485Dat_Key[1]&0x04)==0x04)   //A泵高速
00022a  f89d0005          LDRB     r0,[sp,#5]
00022e  f0000004          AND      r0,r0,#4
000232  2804              CMP      r0,#4
000234  d10c              BNE      |L11.592|
;;;226                    {   
;;;227                        gAp.Statue=HighSpeed;
000236  2002              MOVS     r0,#2
000238  4982              LDR      r1,|L11.1092|
00023a  7008              STRB     r0,[r1,#0]
;;;228                        KMON_Show(AKM1RUN); KMOFF_Show(AKM2RUN);KMON_Show(AKM3RUN); 
00023c  2001              MOVS     r0,#1
00023e  f7fffffe          BL       KMON_Show
000242  2002              MOVS     r0,#2
000244  f7fffffe          BL       KMOFF_Show
000248  2004              MOVS     r0,#4
00024a  f7fffffe          BL       KMON_Show
00024e  e04a              B        |L11.742|
                  |L11.592|
;;;229                    }  
;;;230                    else if((RS485Dat_Key[1]&0x40)==0x40)   //B泵停止
000250  f89d0005          LDRB     r0,[sp,#5]
000254  f0000040          AND      r0,r0,#0x40
000258  2840              CMP      r0,#0x40
00025a  d10c              BNE      |L11.630|
;;;231                    {   
;;;232                        gBp.Statue=Stop;     
00025c  2000              MOVS     r0,#0
00025e  497a              LDR      r1,|L11.1096|
000260  7008              STRB     r0,[r1,#0]
;;;233                        KMOFF_Show(BKM1RUN);KMOFF_Show(BKM2RUN);KMOFF_Show(BKM3RUN);
000262  2008              MOVS     r0,#8
000264  f7fffffe          BL       KMOFF_Show
000268  2010              MOVS     r0,#0x10
00026a  f7fffffe          BL       KMOFF_Show
00026e  2020              MOVS     r0,#0x20
000270  f7fffffe          BL       KMOFF_Show
000274  e037              B        |L11.742|
                  |L11.630|
;;;234                    }  
;;;235                    else if((RS485Dat_Key[0]&0x02)==0x02)   //B泵低速
000276  f89d0004          LDRB     r0,[sp,#4]
00027a  f0000002          AND      r0,r0,#2
00027e  2802              CMP      r0,#2
000280  d10c              BNE      |L11.668|
;;;236                    {   
;;;237                        gBp.Statue=Slow;     
000282  2001              MOVS     r0,#1
000284  4970              LDR      r1,|L11.1096|
000286  7008              STRB     r0,[r1,#0]
;;;238                        KMON_Show(BKM1RUN); KMON_Show(BKM2RUN); KMOFF_Show(BKM3RUN);
000288  2008              MOVS     r0,#8
00028a  f7fffffe          BL       KMON_Show
00028e  2010              MOVS     r0,#0x10
000290  f7fffffe          BL       KMON_Show
000294  2020              MOVS     r0,#0x20
000296  f7fffffe          BL       KMOFF_Show
00029a  e024              B        |L11.742|
                  |L11.668|
;;;239                    }  
;;;240                    else if((RS485Dat_Key[1]&0x80)==0x80)   //B泵高速 
00029c  f89d0005          LDRB     r0,[sp,#5]
0002a0  f0000080          AND      r0,r0,#0x80
0002a4  2880              CMP      r0,#0x80
0002a6  d11e              BNE      |L11.742|
;;;241                    {   
;;;242                        gBp.Statue=HighSpeed;
0002a8  2002              MOVS     r0,#2
0002aa  4967              LDR      r1,|L11.1096|
0002ac  7008              STRB     r0,[r1,#0]
;;;243                        KMON_Show(BKM1RUN); KMOFF_Show(BKM2RUN);KMON_Show(BKM3RUN); 
0002ae  2008              MOVS     r0,#8
0002b0  f7fffffe          BL       KMON_Show
0002b4  2010              MOVS     r0,#0x10
0002b6  f7fffffe          BL       KMOFF_Show
0002ba  2020              MOVS     r0,#0x20
0002bc  f7fffffe          BL       KMON_Show
0002c0  e011              B        |L11.742|
0002c2  e7ff              B        |L11.708|
                  |L11.708|
;;;244                    }                 
;;;245                }
;;;246                else if(RunMode==1)  //主一备二
0002c4  2c01              CMP      r4,#1
0002c6  d106              BNE      |L11.726|
;;;247                {
;;;248                    RS485Dat_LED15_ON();RS485Dat_LED16_OFF();RS485Dat_LED17_OFF();
0002c8  f7fffffe          BL       RS485Dat_LED15_ON
0002cc  f7fffffe          BL       RS485Dat_LED16_OFF
0002d0  f7fffffe          BL       RS485Dat_LED17_OFF
0002d4  e007              B        |L11.742|
                  |L11.726|
;;;249                }
;;;250                else if(RunMode==2)  //主二备一
0002d6  2c02              CMP      r4,#2
0002d8  d105              BNE      |L11.742|
;;;251                {
;;;252                    RS485Dat_LED15_OFF();RS485Dat_LED16_OFF();RS485Dat_LED17_ON();
0002da  f7fffffe          BL       RS485Dat_LED15_OFF
0002de  f7fffffe          BL       RS485Dat_LED16_OFF
0002e2  f7fffffe          BL       RS485Dat_LED17_ON
                  |L11.742|
;;;253                }
;;;254                if(RunMode!=OldRunMode) //运行模式切换，把运行模式全部转为停止
0002e6  42bc              CMP      r4,r7
0002e8  d01b              BEQ      |L11.802|
;;;255                {
;;;256                    OldRunMode = RunMode;StartTimerFlag = 0x00;
0002ea  4627              MOV      r7,r4
0002ec  2000              MOVS     r0,#0
0002ee  4957              LDR      r1,|L11.1100|
0002f0  7008              STRB     r0,[r1,#0]
;;;257                    gAp.Statue = Stop;
0002f2  4954              LDR      r1,|L11.1092|
0002f4  7008              STRB     r0,[r1,#0]
;;;258                    KMOFF_Show(AKM1RUN);KMOFF_Show(AKM2RUN);KMOFF_Show(AKM3RUN);
0002f6  2001              MOVS     r0,#1
0002f8  f7fffffe          BL       KMOFF_Show
0002fc  2002              MOVS     r0,#2
0002fe  f7fffffe          BL       KMOFF_Show
000302  2004              MOVS     r0,#4
000304  f7fffffe          BL       KMOFF_Show
;;;259                    gBp.Statue = Stop;     
000308  2000              MOVS     r0,#0
00030a  494f              LDR      r1,|L11.1096|
00030c  7008              STRB     r0,[r1,#0]
;;;260                    KMOFF_Show(BKM1RUN);KMOFF_Show(BKM2RUN);KMOFF_Show(BKM3RUN);
00030e  2008              MOVS     r0,#8
000310  f7fffffe          BL       KMOFF_Show
000314  2010              MOVS     r0,#0x10
000316  f7fffffe          BL       KMOFF_Show
00031a  2020              MOVS     r0,#0x20
00031c  f7fffffe          BL       KMOFF_Show
000320  e02f              B        |L11.898|
                  |L11.802|
;;;261                }
;;;262                else if(RunMode!=0)  //自动模式
000322  b30c              CBZ      r4,|L11.872|
;;;263                {
;;;264                    if((Read_Optocoupler(8)==0)||(Read_Optocoupler(9)==0)) //远控1/远控2检测
000324  2008              MOVS     r0,#8
000326  f7fffffe          BL       Read_Optocoupler
00032a  b118              CBZ      r0,|L11.820|
00032c  2009              MOVS     r0,#9
00032e  f7fffffe          BL       Read_Optocoupler
000332  b9d0              CBNZ     r0,|L11.874|
                  |L11.820|
;;;265                    {
;;;266                        if(StartTimerFlag==0x00)
000334  4845              LDR      r0,|L11.1100|
000336  7800              LDRB     r0,[r0,#0]  ; StartTimerFlag
000338  b948              CBNZ     r0,|L11.846|
;;;267                        {
;;;268                            RunStape = 1;
00033a  f04f0801          MOV      r8,#1
;;;269                            StartTimerFlag=0xAA;        //标记进入启动，开启定时功能
00033e  20aa              MOVS     r0,#0xaa
000340  4942              LDR      r1,|L11.1100|
000342  7008              STRB     r0,[r1,#0]
;;;270                            KMAutoRUN(RunMode,RunStape);//自动启动控制
000344  4641              MOV      r1,r8
000346  4620              MOV      r0,r4
000348  f7fffffe          BL       KMAutoRUN
00034c  e019              B        |L11.898|
                  |L11.846|
;;;271                        }
;;;272                        else if(StartTimerFlag==0xBB)   //进入第二阶段，定时时间到，该定时在定时器中实现
00034e  483f              LDR      r0,|L11.1100|
000350  7800              LDRB     r0,[r0,#0]  ; StartTimerFlag
000352  28bb              CMP      r0,#0xbb
000354  d115              BNE      |L11.898|
;;;273                        {
;;;274                            RunStape = 2;
000356  f04f0802          MOV      r8,#2
;;;275                            StartTimerFlag=0xCC;        //标记进入高速运行
00035a  20cc              MOVS     r0,#0xcc
00035c  493b              LDR      r1,|L11.1100|
00035e  7008              STRB     r0,[r1,#0]
;;;276                            KMAutoRUN(RunMode,RunStape);//自动启动控制                        
000360  4641              MOV      r1,r8
000362  4620              MOV      r0,r4
000364  f7fffffe          BL       KMAutoRUN
                  |L11.872|
000368  e00b              B        |L11.898|
                  |L11.874|
;;;277                        }
;;;278                    }
;;;279                    else
;;;280                    {
;;;281                        if(StartTimerFlag!=0x00)
00036a  4838              LDR      r0,|L11.1100|
00036c  7800              LDRB     r0,[r0,#0]  ; StartTimerFlag
00036e  b140              CBZ      r0,|L11.898|
;;;282                        {
;;;283                            RunStape = 0;
000370  f04f0800          MOV      r8,#0
;;;284                            StartTimerFlag = 0x00;
000374  2000              MOVS     r0,#0
000376  4935              LDR      r1,|L11.1100|
000378  7008              STRB     r0,[r1,#0]
;;;285                            KMAutoRUN(RunMode,RunStape);//自动启动控制
00037a  4641              MOV      r1,r8
00037c  4620              MOV      r0,r4
00037e  f7fffffe          BL       KMAutoRUN
                  |L11.898|
;;;286                        }
;;;287                    }
;;;288                }
;;;289            }
;;;290            KMOutUpdat();   //统一更新继电器输出
000382  f7fffffe          BL       KMOutUpdat
                  |L11.902|
000386  e67d              B        |L11.132|
;;;291    
;;;292    	}
;;;293    }
;;;294    
                          ENDP

                  |L11.904|
000388  43414e5f          DCB      "CAN_Mode_Init,CAN_Baud: 60Kbps...\r\n",0
00038c  4d6f6465
000390  5f496e69
000394  742c4341
000398  4e5f4261
00039c  75643a20
0003a0  36304b62
0003a4  70732e2e
0003a8  2e0d0a00
                  |L11.940|
                          DCD      ||.conststring||
                  |L11.944|
                          DCD      0x40010800
                  |L11.948|
                          DCD      g_ShowDat
                  |L11.952|
                          DCD      g_ShowUpDateFlag
                  |L11.956|
0003bc  20204b45          DCB      "  KEY_1_DOWN!\r\n",0
0003c0  595f315f
0003c4  444f574e
0003c8  210d0a00
                  |L11.972|
0003cc  20204b45          DCB      "  KEY_1_UP!\r\n",0
0003d0  595f315f
0003d4  5550210d
0003d8  0a00    
0003da  00                DCB      0
0003db  00                DCB      0
                  |L11.988|
0003dc  20204b45          DCB      "  KEY_2_DOWN!\r\n",0
0003e0  595f325f
0003e4  444f574e
0003e8  210d0a00
                  |L11.1004|
0003ec  20204b45          DCB      "  KEY_2_UP!\r\n",0
0003f0  595f325f
0003f4  5550210d
0003f8  0a00    
0003fa  00                DCB      0
0003fb  00                DCB      0
                  |L11.1020|
0003fc  20204b45          DCB      "  KEY_3_DOWN!\r\n",0
000400  595f335f
000404  444f574e
000408  210d0a00
                  |L11.1036|
00040c  20204b45          DCB      "  KEY_3_UP!\r\n",0
000410  595f335f
000414  5550210d
000418  0a00    
00041a  00                DCB      0
00041b  00                DCB      0
                  |L11.1052|
00041c  20204b45          DCB      "  KEY_4_DOWN!\r\n",0
000420  595f345f
000424  444f574e
000428  210d0a00
                  |L11.1068|
00042c  20204b45          DCB      "  KEY_4_UP!\r\n",0
000430  595f345f
000434  5550210d
000438  0a00    
00043a  00                DCB      0
00043b  00                DCB      0
                  |L11.1084|
                          DCD      RS485_Count
                  |L11.1088|
                          DCD      RS485Dat
                  |L11.1092|
                          DCD      gAp
                  |L11.1096|
                          DCD      gBp
                  |L11.1100|
                          DCD      StartTimerFlag

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  g_ShowDat
                          %        12

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  2d2d2d2d          DCB      "-------------------------------------------------------"
000004  2d2d2d2d
000008  2d2d2d2d
00000c  2d2d2d2d
000010  2d2d2d2d
000014  2d2d2d2d
000018  2d2d2d2d
00001c  2d2d2d2d
000020  2d2d2d2d
000024  2d2d2d2d
000028  2d2d2d2d
00002c  2d2d2d2d
000030  2d2d2d2d
000034  2d2d2d  
000037  2d2d2d2d          DCB      "------------\r\n",0
00003b  2d2d2d2d
00003f  2d2d2d2d
000043  0d0a00  

                          AREA ||.data||, DATA, ALIGN=2

                  g_RxMessage
000000  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
                  g_RxMessFlag
000008  00                DCB      0x00
                  OutFlag
000009  00                DCB      0x00
                  InPutCount
00000a  00                DCB      0x00
                  g_ShowUpDateFlag
00000b  00                DCB      0x00
                  g_RunningTime
                          DCD      0x00000000
                  StartTimerFlag
000010  0000              DCB      0x00,0x00
                  Time_count
000012  0000              DCW      0x0000
                  KMTime_count
000014  0000              DCW      0x0000
                  KMTime_Sec
000016  00                DCB      0x00
                  g_FlagDWG
000017  00                DCB      0x00

                  __ARM_use_no_argv EQU 0
