; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\main.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\main.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User -I"C:\Users\xuan5\Desktop\JOSONG-XS03 V3.0\Project\MDK-ARM(uV4)\RTE" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=521 -D_RTE_ -DSTM32F10X_MD -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=.\flash\obj\main.crf ..\..\User\main.c]
                          THUMB

                          AREA ||i.CPU_IDLE||, CODE, READONLY, ALIGN=2

                  CPU_IDLE PROC
;;;55     }
;;;56     void CPU_IDLE(void)
000000  b510              PUSH     {r4,lr}
;;;57     {
;;;58     	static uint8_t g_FlagDWG=0;
;;;59     	if(++g_FlagDWG%2==0)	HardWDG_ON();
000002  490b              LDR      r1,|L1.48|
000004  7809              LDRB     r1,[r1,#0]  ; g_FlagDWG
000006  1c49              ADDS     r1,r1,#1
000008  b2c9              UXTB     r1,r1
00000a  4a09              LDR      r2,|L1.48|
00000c  7011              STRB     r1,[r2,#0]
00000e  4608              MOV      r0,r1
000010  eb0171d0          ADD      r1,r1,r0,LSR #31
000014  1049              ASRS     r1,r1,#1
000016  eba00141          SUB      r1,r0,r1,LSL #1
00001a  b921              CBNZ     r1,|L1.38|
00001c  2110              MOVS     r1,#0x10
00001e  4805              LDR      r0,|L1.52|
000020  f7fffffe          BL       GPIO_SetBits
000024  e003              B        |L1.46|
                  |L1.38|
;;;60     	else 					HardWDG_OFF();
000026  2110              MOVS     r1,#0x10
000028  4802              LDR      r0,|L1.52|
00002a  f7fffffe          BL       GPIO_ResetBits
                  |L1.46|
;;;61     }
00002e  bd10              POP      {r4,pc}
;;;62     
                          ENDP

                  |L1.48|
                          DCD      g_FlagDWG
                  |L1.52|
                          DCD      0x40010800

                          AREA ||i.Delay||, CODE, READONLY, ALIGN=1

                  Delay PROC
;;;276    
;;;277    void Delay(__IO uint16_t nCount)
000000  b501              PUSH     {r0,lr}
;;;278    {
;;;279    	while (nCount != 0)
000002  e004              B        |L2.14|
                  |L2.4|
;;;280    	{
;;;281    		nCount--;
000004  f8bd0000          LDRH     r0,[sp,#0]
000008  1e40              SUBS     r0,r0,#1
00000a  b280              UXTH     r0,r0
00000c  9000              STR      r0,[sp,#0]
                  |L2.14|
00000e  f8bd0000          LDRH     r0,[sp,#0]            ;279
000012  2800              CMP      r0,#0                 ;279
000014  d1f6              BNE      |L2.4|
;;;282    	}
;;;283    }
000016  bd08              POP      {r3,pc}
;;;284    
                          ENDP


                          AREA ||i.InitBoard||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  InitBoard PROC
;;;234    */
;;;235    static void InitBoard(void)
000000  b510              PUSH     {r4,lr}
;;;236    {	
;;;237    	RCC_Configuration();
000002  f7fffffe          BL       RCC_Configuration
;;;238    	/* 初始化systick定时器，并启动定时中断 */
;;;239    	bsp_InitTimer(); 
000006  f7fffffe          BL       bsp_InitTimer
;;;240    	delay_init();
00000a  f7fffffe          BL       delay_init
;;;241    	delay_ms(500);
00000e  f44f70fa          MOV      r0,#0x1f4
000012  f7fffffe          BL       delay_ms
;;;242    	Init_GPIO();				//输出初始化
000016  f7fffffe          BL       Init_GPIO
;;;243    	bsp_InitKey();
00001a  f7fffffe          BL       bsp_InitKey
;;;244    	bsp_InitUart(); 	    	//初始化串口+RS485
00001e  f7fffffe          BL       bsp_InitUart
;;;245    	printf("\r\nStarting Up...\r\nJOSONG-XS03 V3.0...\r\n");
000022  a014              ADR      r0,|L3.116|
000024  f7fffffe          BL       __2printf
;;;246    	printf("VersionNo: %02X...\r\n",VERSION);
000028  2101              MOVS     r1,#1
00002a  a01c              ADR      r0,|L3.156|
00002c  f7fffffe          BL       __2printf
;;;247    	printf("SystemCoreClock: %d...\r\n",SystemCoreClock);
000030  4820              LDR      r0,|L3.180|
000032  6801              LDR      r1,[r0,#0]  ; SystemCoreClock
000034  a020              ADR      r0,|L3.184|
000036  f7fffffe          BL       __2printf
;;;248    	delay_ms(500);
00003a  f44f70fa          MOV      r0,#0x1f4
00003e  f7fffffe          BL       delay_ms
;;;249    	BspTm1639_Config();	        //TM1639初始化
000042  f7fffffe          BL       BspTm1639_Config
;;;250    	BspDht11_Config();			//温湿度传感器初始化
000046  f7fffffe          BL       BspDht11_Config
;;;251    	bsp_HC595_Config();			//HC595初始化 用于继电器输出
00004a  f7fffffe          BL       bsp_HC595_Config
;;;252    	BspInput_CD4067_Config();	//CD4067初始化 用于信号采集
00004e  f7fffffe          BL       BspInput_CD4067_Config
;;;253    	BspInput_CD4051_Config();	//CD4051*3
000052  f7fffffe          BL       BspInput_CD4051_Config
;;;254    	Bsp_CS5463_Config();
000056  f7fffffe          BL       Bsp_CS5463_Config
;;;255    	CS546x_Init(0);
00005a  2000              MOVS     r0,#0
00005c  f7fffffe          BL       CS546x_Init
;;;256    	TIM3_Int_Init(99,720-1);  	//以100khz的频率计数，0.01ms中断，计数到100 *0.01ms 为1ms 
000060  f24021cf          MOV      r1,#0x2cf
000064  2063              MOVS     r0,#0x63
000066  f7fffffe          BL       TIM3_Int_Init
;;;257    //	TIM2_Cap_Init(0xFFFF,72-1);	//以1Mhz的频率计数 
;;;258     	Adc_Init();		  		    //ADC初始化
00006a  f7fffffe          BL       Adc_Init
;;;259    	bsp_InitCQVar();
00006e  f7fffffe          BL       bsp_InitCQVar
;;;260    }
000072  bd10              POP      {r4,pc}
;;;261    
                          ENDP

                  |L3.116|
000074  0d0a5374          DCB      "\r\nStarting Up...\r\nJOSONG-XS03 V3.0...\r\n",0
000078  61727469
00007c  6e672055
000080  702e2e2e
000084  0d0a4a4f
000088  534f4e47
00008c  2d585330
000090  33205633
000094  2e302e2e
000098  2e0d0a00
                  |L3.156|
00009c  56657273          DCB      "VersionNo: %02X...\r\n",0
0000a0  696f6e4e
0000a4  6f3a2025
0000a8  3032582e
0000ac  2e2e0d0a
0000b0  00      
0000b1  00                DCB      0
0000b2  00                DCB      0
0000b3  00                DCB      0
                  |L3.180|
                          DCD      SystemCoreClock
                  |L3.184|
0000b8  53797374          DCB      "SystemCoreClock: %d...\r\n",0
0000bc  656d436f
0000c0  7265436c
0000c4  6f636b3a
0000c8  2025642e
0000cc  2e2e0d0a
0000d0  00      
0000d1  00                DCB      0
0000d2  00                DCB      0
0000d3  00                DCB      0

                          AREA ||i.Init_GPIO||, CODE, READONLY, ALIGN=2

                  Init_GPIO PROC
;;;116    
;;;117    void Init_GPIO(void)
000000  b508              PUSH     {r3,lr}
;;;118    {
;;;119    	GPIO_InitTypeDef GPIO_InitStructure;
;;;120    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); 
000002  2101              MOVS     r1,#1
000004  2004              MOVS     r0,#4
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;121    
;;;122    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;
00000a  2010              MOVS     r0,#0x10
00000c  f8ad0000          STRH     r0,[sp,#0]
;;;123    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
000010  f88d0003          STRB     r0,[sp,#3]
;;;124    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000014  2003              MOVS     r0,#3
000016  f88d0002          STRB     r0,[sp,#2]
;;;125    	GPIO_Init(GPIOA, &GPIO_InitStructure);
00001a  4669              MOV      r1,sp
00001c  4801              LDR      r0,|L4.36|
00001e  f7fffffe          BL       GPIO_Init
;;;126    }
000022  bd08              POP      {r3,pc}
;;;127    
                          ENDP

                  |L4.36|
                          DCD      0x40010800

                          AREA ||i.NVIC_Configuration||, CODE, READONLY, ALIGN=1

                  NVIC_Configuration PROC
;;;43     
;;;44     void NVIC_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;45     {
;;;46         NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);	//设置NVIC中断分组2:2位抢占优先级，2位响应优先级
000002  f44f60a0          MOV      r0,#0x500
000006  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;47     }
00000a  bd10              POP      {r4,pc}
;;;48     
                          ENDP


                          AREA ||i.PutInMemoryBuf||, CODE, READONLY, ALIGN=2

                  PutInMemoryBuf PROC
;;;80     
;;;81     void PutInMemoryBuf(u8 *Buf)	//末尾加入第一个缓存
000000  b51f              PUSH     {r0-r4,lr}
;;;82     {
000002  4604              MOV      r4,r0
;;;83         uint8_t BufDat[16]={0};
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
000008  9001              STR      r0,[sp,#4]
00000a  9002              STR      r0,[sp,#8]
00000c  9003              STR      r0,[sp,#0xc]
;;;84     	//日志存储
;;;85         BufDat[ 0] = (uint8_t)(g_RunningTime>>24); //时钟
00000e  4833              LDR      r0,|L6.220|
000010  6800              LDR      r0,[r0,#0]  ; g_RunningTime
000012  0e00              LSRS     r0,r0,#24
000014  f88d0000          STRB     r0,[sp,#0]
;;;86         BufDat[ 1] = (uint8_t)(g_RunningTime>>16); //时钟
000018  4830              LDR      r0,|L6.220|
00001a  6800              LDR      r0,[r0,#0]  ; g_RunningTime
00001c  0c00              LSRS     r0,r0,#16
00001e  f88d0001          STRB     r0,[sp,#1]
;;;87         BufDat[ 2] = (uint8_t)(g_RunningTime>>8);  //时钟
000022  482e              LDR      r0,|L6.220|
000024  8800              LDRH     r0,[r0,#0]  ; g_RunningTime
000026  0a00              LSRS     r0,r0,#8
000028  f88d0002          STRB     r0,[sp,#2]
;;;88         BufDat[ 3] = (uint8_t)(g_RunningTime);     //时钟
00002c  482b              LDR      r0,|L6.220|
00002e  7800              LDRB     r0,[r0,#0]  ; g_RunningTime
000030  f88d0003          STRB     r0,[sp,#3]
;;;89         BufDat[ 4] = Buf[1];     	//卡号0；
000034  7860              LDRB     r0,[r4,#1]
000036  f88d0004          STRB     r0,[sp,#4]
;;;90         BufDat[ 5] = Buf[2];     	//卡号1；
00003a  78a0              LDRB     r0,[r4,#2]
00003c  f88d0005          STRB     r0,[sp,#5]
;;;91         BufDat[ 6] = Buf[3];     	//卡号2；
000040  78e0              LDRB     r0,[r4,#3]
000042  f88d0006          STRB     r0,[sp,#6]
;;;92         BufDat[ 7] = Buf[4];     	//卡号3；
000046  7920              LDRB     r0,[r4,#4]
000048  f88d0007          STRB     r0,[sp,#7]
;;;93         BufDat[ 8] = Buf[8];		//校验	
00004c  7a20              LDRB     r0,[r4,#8]
00004e  f88d0008          STRB     r0,[sp,#8]
;;;94         BufDat[ 9] = Buf[ 5];     	//金额1高位
000052  7960              LDRB     r0,[r4,#5]
000054  f88d0009          STRB     r0,[sp,#9]
;;;95         BufDat[10] = Buf[ 6];     	//金额2
000058  79a0              LDRB     r0,[r4,#6]
00005a  f88d000a          STRB     r0,[sp,#0xa]
;;;96         BufDat[11] = Buf[ 7];     	//金额3
00005e  79e0              LDRB     r0,[r4,#7]
000060  f88d000b          STRB     r0,[sp,#0xb]
;;;97         BufDat[12] = Buf[ 9]&0x7F;	//DecSum高位
000064  7a60              LDRB     r0,[r4,#9]
000066  f000007f          AND      r0,r0,#0x7f
00006a  f88d000c          STRB     r0,[sp,#0xc]
;;;98         BufDat[13] = Buf[10];     	//DecSum低位
00006e  7aa0              LDRB     r0,[r4,#0xa]
000070  f88d000d          STRB     r0,[sp,#0xd]
;;;99     	
;;;100    	if((Buf[ 9]&0x80)==0x80)    BufDat[14] = 0x03;	 //连续消息标记; 
000074  7a60              LDRB     r0,[r4,#9]
000076  f0000080          AND      r0,r0,#0x80
00007a  2880              CMP      r0,#0x80
00007c  d103              BNE      |L6.134|
00007e  2003              MOVS     r0,#3
000080  f88d000e          STRB     r0,[sp,#0xe]
000084  e009              B        |L6.154|
                  |L6.134|
;;;101    	else
;;;102        {
;;;103            if( Buf[0] == 0xAA )	BufDat[14] = 0x01;  //插卡；
000086  7820              LDRB     r0,[r4,#0]
000088  28aa              CMP      r0,#0xaa
00008a  d103              BNE      |L6.148|
00008c  2001              MOVS     r0,#1
00008e  f88d000e          STRB     r0,[sp,#0xe]
000092  e002              B        |L6.154|
                  |L6.148|
;;;104            else					BufDat[14] = 0x02;  //取卡； 
000094  2002              MOVS     r0,#2
000096  f88d000e          STRB     r0,[sp,#0xe]
                  |L6.154|
;;;105    	}
;;;106        BufDat[15] = CRC8_Table(BufDat,15); 	//CRC
00009a  210f              MOVS     r1,#0xf
00009c  4668              MOV      r0,sp
00009e  f7fffffe          BL       CRC8_Table
0000a2  f88d000f          STRB     r0,[sp,#0xf]
;;;107    	
;;;108    
;;;109    	memcpy(s_gCQ.Buf[s_gCQ.Write],Buf,10);
0000a6  480e              LDR      r0,|L6.224|
0000a8  f89000a1          LDRB     r0,[r0,#0xa1]  ; s_gCQ
0000ac  490c              LDR      r1,|L6.224|
0000ae  eb011000          ADD      r0,r1,r0,LSL #4
0000b2  6821              LDR      r1,[r4,#0]
0000b4  6001              STR      r1,[r0,#0]
0000b6  6861              LDR      r1,[r4,#4]
0000b8  6041              STR      r1,[r0,#4]
0000ba  8921              LDRH     r1,[r4,#8]
0000bc  8101              STRH     r1,[r0,#8]
;;;110    
;;;111    	if (++s_gCQ.Write  >= CQ_FIFO_SIZE)
0000be  4808              LDR      r0,|L6.224|
0000c0  f89000a1          LDRB     r0,[r0,#0xa1]  ; s_gCQ
0000c4  1c40              ADDS     r0,r0,#1
0000c6  b2c0              UXTB     r0,r0
0000c8  4905              LDR      r1,|L6.224|
0000ca  f88100a1          STRB     r0,[r1,#0xa1]
0000ce  280a              CMP      r0,#0xa
0000d0  db02              BLT      |L6.216|
;;;112    	{
;;;113    		s_gCQ.Write = 0;
0000d2  2000              MOVS     r0,#0
0000d4  f88100a1          STRB     r0,[r1,#0xa1]
                  |L6.216|
;;;114    	}
;;;115    }
0000d8  bd1f              POP      {r0-r4,pc}
;;;116    
                          ENDP

0000da  0000              DCW      0x0000
                  |L6.220|
                          DCD      g_RunningTime
                  |L6.224|
                          DCD      s_gCQ

                          AREA ||i.PutOutMemoryBuf||, CODE, READONLY, ALIGN=2

                  PutOutMemoryBuf PROC
;;;63     
;;;64     uint8_t PutOutMemoryBuf(uint8_t *_Date)	//清第一个缓存
000000  b510              PUSH     {r4,lr}
;;;65     {
000002  4604              MOV      r4,r0
;;;66     	if (s_gCQ.Read == s_gCQ.Write)
000004  4811              LDR      r0,|L7.76|
000006  f89000a0          LDRB     r0,[r0,#0xa0]  ; s_gCQ
00000a  4910              LDR      r1,|L7.76|
00000c  f89110a1          LDRB     r1,[r1,#0xa1]  ; s_gCQ
000010  4288              CMP      r0,r1
000012  d101              BNE      |L7.24|
;;;67     	{
;;;68     		return CQ_NONE;
000014  2000              MOVS     r0,#0
                  |L7.22|
;;;69     	}
;;;70     	else
;;;71     	{
;;;72     		memcpy(_Date,s_gCQ.Buf[s_gCQ.Read],16);
;;;73     		if (++s_gCQ.Read >= CQ_FIFO_SIZE)
;;;74     		{
;;;75     			s_gCQ.Read = 0;
;;;76     		}
;;;77     		return CQ_OK;
;;;78     	}
;;;79     }
000016  bd10              POP      {r4,pc}
                  |L7.24|
000018  480c              LDR      r0,|L7.76|
00001a  f89000a0          LDRB     r0,[r0,#0xa0]         ;72  ; s_gCQ
00001e  4a0b              LDR      r2,|L7.76|
000020  eb021100          ADD      r1,r2,r0,LSL #4       ;72
000024  2210              MOVS     r2,#0x10              ;72
000026  4620              MOV      r0,r4                 ;72
000028  f7fffffe          BL       __aeabi_memcpy
00002c  4807              LDR      r0,|L7.76|
00002e  f89000a0          LDRB     r0,[r0,#0xa0]         ;73  ; s_gCQ
000032  1c40              ADDS     r0,r0,#1              ;73
000034  b2c0              UXTB     r0,r0                 ;73
000036  4905              LDR      r1,|L7.76|
000038  f88100a0          STRB     r0,[r1,#0xa0]         ;73
00003c  280a              CMP      r0,#0xa               ;73
00003e  db02              BLT      |L7.70|
000040  2000              MOVS     r0,#0                 ;75
000042  f88100a0          STRB     r0,[r1,#0xa0]         ;75
                  |L7.70|
000046  2001              MOVS     r0,#1                 ;77
000048  e7e5              B        |L7.22|
;;;80     
                          ENDP

00004a  0000              DCW      0x0000
                  |L7.76|
                          DCD      s_gCQ

                          AREA ||i.RCC_Configuration||, CODE, READONLY, ALIGN=1

                  RCC_Configuration PROC
;;;48     
;;;49     void RCC_Configuration(void)
000000  4770              BX       lr
;;;50     {
;;;51     //    RCC_DeInit();
;;;52     //    RCC_HSEConfig(RCC_HSE_OFF);
;;;53     //    RCC_HSICmd(ENABLE);
;;;54     //    RCC_HSEConfig(RCC_HSE_ON);
;;;55     }
;;;56     void CPU_IDLE(void)
                          ENDP


                          AREA ||i.SoftReset||, CODE, READONLY, ALIGN=2

                  SoftReset PROC
;;;127    
;;;128    void SoftReset(void)
000000  2001              MOVS     r0,#1
000002  f3808813          MSR      FAULTMASK,r0
000006  bf00              NOP      
;;;129    {
;;;130    	__set_FAULTMASK(1);		// 关闭所有中端
;;;131    	NVIC_SystemReset();		// 复位
000008  bf00              NOP      
00000a  4807              LDR      r0,|L9.40|
00000c  6800              LDR      r0,[r0,#0]
00000e  f40060e0          AND      r0,r0,#0x700
000012  4906              LDR      r1,|L9.44|
000014  4308              ORRS     r0,r0,r1
000016  1d00              ADDS     r0,r0,#4
000018  4903              LDR      r1,|L9.40|
00001a  6008              STR      r0,[r1,#0]
00001c  f3bf8f4f          DSB      
000020  bf00              NOP      
000022  bf00              NOP      
                  |L9.36|
000024  e7fe              B        |L9.36|
;;;132    }
;;;133    
                          ENDP

000026  0000              DCW      0x0000
                  |L9.40|
                          DCD      0xe000ed0c
                  |L9.44|
                          DCD      0x05fa0000

                          AREA ||i.TIM3_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM3_IRQHandler PROC
;;;264    //定时器3中断服务程序
;;;265    void TIM3_IRQHandler(void)   //TIM3中断
000000  b510              PUSH     {r4,lr}
;;;266    {
;;;267    	if (TIM_GetITStatus(TIM3, TIM_IT_Update) != RESET)  //TIM3更新中断 20ms中断
000002  2101              MOVS     r1,#1
000004  4810              LDR      r0,|L10.72|
000006  f7fffffe          BL       TIM_GetITStatus
00000a  b1d8              CBZ      r0,|L10.68|
;;;268    	{
;;;269    		if(Time_count>200)	Time_count=0;
00000c  480f              LDR      r0,|L10.76|
00000e  7800              LDRB     r0,[r0,#0]  ; Time_count
000010  28c8              CMP      r0,#0xc8
000012  dd02              BLE      |L10.26|
000014  2000              MOVS     r0,#0
000016  490d              LDR      r1,|L10.76|
000018  7008              STRB     r0,[r1,#0]
                  |L10.26|
;;;270    		Time_count++;
00001a  480c              LDR      r0,|L10.76|
00001c  7800              LDRB     r0,[r0,#0]  ; Time_count
00001e  1c40              ADDS     r0,r0,#1
000020  490a              LDR      r1,|L10.76|
000022  7008              STRB     r0,[r1,#0]
;;;271    		SysTick_ISR();	//这个函数在bsp_timer.c中 
000024  f7fffffe          BL       SysTick_ISR
;;;272    		if((Time_count%10)==0)			bsp_KeyScan();	//每10ms扫描按键一次
000028  4808              LDR      r0,|L10.76|
00002a  7800              LDRB     r0,[r0,#0]  ; Time_count
00002c  210a              MOVS     r1,#0xa
00002e  fb90f2f1          SDIV     r2,r0,r1
000032  fb010012          MLS      r0,r1,r2,r0
000036  b908              CBNZ     r0,|L10.60|
000038  f7fffffe          BL       bsp_KeyScan
                  |L10.60|
;;;273    		TIM_ClearITPendingBit(TIM3, TIM_IT_Update  );  	//清除TIMx更新中断标志 					
00003c  2101              MOVS     r1,#1
00003e  4802              LDR      r0,|L10.72|
000040  f7fffffe          BL       TIM_ClearITPendingBit
                  |L10.68|
;;;274    	}
;;;275    }
000044  bd10              POP      {r4,pc}
;;;276    
                          ENDP

000046  0000              DCW      0x0000
                  |L10.72|
                          DCD      0x40000400
                  |L10.76|
                          DCD      Time_count

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;141    */
;;;142    int main(void)
000000  b51f              PUSH     {r0-r4,lr}
;;;143    {
;;;144    	uint8_t DHT_Dat[5]={0},RS485Dat_Key[2]={0};
000002  2000              MOVS     r0,#0
000004  9002              STR      r0,[sp,#8]
000006  9003              STR      r0,[sp,#0xc]
000008  9001              STR      r0,[sp,#4]
;;;145    	uint8_t Time_250ms=0;
00000a  2500              MOVS     r5,#0
;;;146    	uint8_t KeyDat=0;
00000c  2400              MOVS     r4,#0
;;;147    	SystemInit();
00000e  f7fffffe          BL       SystemInit
;;;148    	
;;;149    	InitBoard();		//硬件初始化
000012  f7fffffe          BL       InitBoard
;;;150    	BspTm1639_Show(0x01,0x00);	//上电初始化显示
000016  2100              MOVS     r1,#0
000018  2001              MOVS     r0,#1
00001a  f7fffffe          BL       BspTm1639_Show
;;;151    	CAN_Mode_Init(CAN_SJW_1tq,CAN_BS1_4tq,CAN_BS2_3tq,75,CAN_Mode_Normal);	//CAN初始化正常模式,波特率60Kbps  //则波特率为:36M/((1+2+1)*150)= 60Kbps CAN_Normal_Init(1,2,1,150,1);   
00001e  2000              MOVS     r0,#0
000020  234b              MOVS     r3,#0x4b
000022  2202              MOVS     r2,#2
000024  2103              MOVS     r1,#3
000026  9000              STR      r0,[sp,#0]
000028  f7fffffe          BL       CAN_Mode_Init
;;;152    	printf("CAN_Mode_Init,CAN_Baud: 60Kbps...\r\n");
00002c  a03e              ADR      r0,|L11.296|
00002e  f7fffffe          BL       __2printf
;;;153    	
;;;154        printf("-------------------------------------------------------------------\r\n");
000032  4846              LDR      r0,|L11.332|
000034  f7fffffe          BL       __2printf
;;;155    	bsp_StartTimer(1, 200);			//定时器1周期 200毫秒
000038  21c8              MOVS     r1,#0xc8
00003a  2001              MOVS     r0,#1
00003c  f7fffffe          BL       bsp_StartTimer
;;;156    	KMOFF_Show(ALARMALL);
000040  f64070ff          MOV      r0,#0xfff
000044  f7fffffe          BL       KMOFF_Show
;;;157    	HC595_E1_ON();HC595_E2_ON();	
000048  2104              MOVS     r1,#4
00004a  4841              LDR      r0,|L11.336|
00004c  f7fffffe          BL       GPIO_ResetBits
000050  2108              MOVS     r1,#8
000052  483f              LDR      r0,|L11.336|
000054  f7fffffe          BL       GPIO_ResetBits
;;;158    	while (1)
000058  e064              B        |L11.292|
                  |L11.90|
;;;159    	{
;;;160    		CPU_IDLE();
00005a  f7fffffe          BL       CPU_IDLE
;;;161    		if ( bsp_CheckTimer(1) )	//软定时器
00005e  2001              MOVS     r0,#1
000060  f7fffffe          BL       bsp_CheckTimer
000064  2800              CMP      r0,#0
000066  d05d              BEQ      |L11.292|
;;;162    		{
;;;163    			bsp_StartTimer(1, 200);	//启动下个定时周期
000068  21c8              MOVS     r1,#0xc8
00006a  2001              MOVS     r0,#1
00006c  f7fffffe          BL       bsp_StartTimer
;;;164    			if(Time_250ms<9)	Time_250ms++;
000070  2d09              CMP      r5,#9
000072  da02              BGE      |L11.122|
000074  1c68              ADDS     r0,r5,#1
000076  b2c5              UXTB     r5,r0
000078  e005              B        |L11.134|
                  |L11.122|
;;;165    			else	
;;;166    			{	
;;;167    				Time_250ms=0;
00007a  2500              MOVS     r5,#0
;;;168                    if(DHT11_Read_Data((uint8_t *)DHT_Dat)==0){;}
00007c  a802              ADD      r0,sp,#8
00007e  f7fffffe          BL       DHT11_Read_Data
;;;169                    Get_InputValue();
000082  f7fffffe          BL       Get_InputValue
                  |L11.134|
;;;170    			}
;;;171                DisplaySendDat();
000086  f7fffffe          BL       DisplaySendDat
;;;172    			KeyDat = bsp_GetKey();
00008a  f7fffffe          BL       bsp_GetKey
00008e  4604              MOV      r4,r0
;;;173    			if(KeyDat!=KEY_NONE)	//按键检测及数据处理
000090  2c00              CMP      r4,#0
000092  d034              BEQ      |L11.254|
;;;174    			{
;;;175    				switch (KeyDat)
000094  2c0c              CMP      r4,#0xc
000096  d230              BCS      |L11.250|
000098  e8dff004          TBB      [pc,r4]
00009c  06070b2f          DCB      0x06,0x07,0x0b,0x2f
0000a0  0f132f17          DCB      0x0f,0x13,0x2f,0x17
0000a4  1d2f2329          DCB      0x1d,0x2f,0x23,0x29
;;;176    				{
;;;177    					case KEY_NONE:	//无按键按下
;;;178    						break;
0000a8  e028              B        |L11.252|
;;;179    					case KEY_1_DOWN:	//						
;;;180    						printf("  KEY_1_DOWN!\r\n");
0000aa  a02a              ADR      r0,|L11.340|
0000ac  f7fffffe          BL       __2printf
;;;181    						break;
0000b0  e024              B        |L11.252|
;;;182    					case KEY_1_UP:		//
;;;183    						printf("  KEY_1_UP!\r\n");
0000b2  a02c              ADR      r0,|L11.356|
0000b4  f7fffffe          BL       __2printf
;;;184    						break;
0000b8  e020              B        |L11.252|
;;;185    					case KEY_2_DOWN:	//
;;;186    						printf("  KEY_2_DOWN!\r\n");						
0000ba  a02e              ADR      r0,|L11.372|
0000bc  f7fffffe          BL       __2printf
;;;187    						break;
0000c0  e01c              B        |L11.252|
;;;188    					case KEY_2_UP:		//
;;;189    						printf("  KEY_2_UP!\r\n");
0000c2  a030              ADR      r0,|L11.388|
0000c4  f7fffffe          BL       __2printf
;;;190    						break;
0000c8  e018              B        |L11.252|
;;;191    					case KEY_3_DOWN:	//
;;;192                            RS485Dat_LED1_ON();
0000ca  f7fffffe          BL       RS485Dat_LED1_ON
;;;193    						printf("  KEY_3_DOWN!\r\n");
0000ce  a031              ADR      r0,|L11.404|
0000d0  f7fffffe          BL       __2printf
;;;194    						break;
0000d4  e012              B        |L11.252|
;;;195    					case KEY_3_UP:		//
;;;196                            RS485Dat_LED1_OFF();
0000d6  f7fffffe          BL       RS485Dat_LED1_OFF
;;;197    						printf("  KEY_3_UP!\r\n");
0000da  a032              ADR      r0,|L11.420|
0000dc  f7fffffe          BL       __2printf
;;;198    						break;
0000e0  e00c              B        |L11.252|
;;;199    					case KEY_4_DOWN:	//
;;;200                            RS485Dat_LED2_ON();
0000e2  f7fffffe          BL       RS485Dat_LED2_ON
;;;201    						printf("  KEY_4_DOWN!\r\n");						
0000e6  a033              ADR      r0,|L11.436|
0000e8  f7fffffe          BL       __2printf
;;;202    						break;
0000ec  e006              B        |L11.252|
;;;203    					case KEY_4_UP:		//
;;;204                            RS485Dat_LED2_OFF();
0000ee  f7fffffe          BL       RS485Dat_LED2_OFF
;;;205    						printf("  KEY_4_UP!\r\n");
0000f2  a034              ADR      r0,|L11.452|
0000f4  f7fffffe          BL       __2printf
;;;206    						break;
0000f8  e000              B        |L11.252|
                  |L11.250|
;;;207    					default:
;;;208    						break;
0000fa  bf00              NOP      
                  |L11.252|
0000fc  bf00              NOP                            ;178
                  |L11.254|
;;;209    				}
;;;210    			}
;;;211    
;;;212    
;;;213    			RS485_ReceiveDat();
0000fe  f7fffffe          BL       RS485_ReceiveDat
;;;214    			if( ( 0x80 & RS485_Count ) == 0x80 )	//接收到数据
000102  4834              LDR      r0,|L11.468|
000104  7800              LDRB     r0,[r0,#0]  ; RS485_Count
000106  f0000080          AND      r0,r0,#0x80
00010a  2880              CMP      r0,#0x80
00010c  d10a              BNE      |L11.292|
;;;215    			{
;;;216    				RS485_Count = 0;
00010e  2000              MOVS     r0,#0
000110  4930              LDR      r1,|L11.468|
000112  7008              STRB     r0,[r1,#0]
;;;217    				//printf("RS485:%02X%02X %02X%02X%02X %02X %02X %02X%02X.\r\n",\
;;;218    				RS485Dat[0],RS485Dat[1],RS485Dat[2],RS485Dat[3],RS485Dat[4],RS485Dat[5],RS485Dat[6],RS485Dat[7],RS485Dat[8]); 
;;;219                    RS485Dat_Key[0] = RS485Dat[4];  RS485Dat_Key[1] = RS485Dat[5];  //获取按键值
000114  4830              LDR      r0,|L11.472|
000116  7900              LDRB     r0,[r0,#4]  ; RS485Dat
000118  f88d0004          STRB     r0,[sp,#4]
00011c  482e              LDR      r0,|L11.472|
00011e  7940              LDRB     r0,[r0,#5]  ; RS485Dat
000120  f88d0005          STRB     r0,[sp,#5]
                  |L11.292|
000124  e799              B        |L11.90|
;;;220    			}
;;;221    
;;;222    		}
;;;223    
;;;224    	}
;;;225    }
;;;226    
                          ENDP

000126  0000              DCW      0x0000
                  |L11.296|
000128  43414e5f          DCB      "CAN_Mode_Init,CAN_Baud: 60Kbps...\r\n",0
00012c  4d6f6465
000130  5f496e69
000134  742c4341
000138  4e5f4261
00013c  75643a20
000140  36304b62
000144  70732e2e
000148  2e0d0a00
                  |L11.332|
                          DCD      ||.conststring||
                  |L11.336|
                          DCD      0x40010800
                  |L11.340|
000154  20204b45          DCB      "  KEY_1_DOWN!\r\n",0
000158  595f315f
00015c  444f574e
000160  210d0a00
                  |L11.356|
000164  20204b45          DCB      "  KEY_1_UP!\r\n",0
000168  595f315f
00016c  5550210d
000170  0a00    
000172  00                DCB      0
000173  00                DCB      0
                  |L11.372|
000174  20204b45          DCB      "  KEY_2_DOWN!\r\n",0
000178  595f325f
00017c  444f574e
000180  210d0a00
                  |L11.388|
000184  20204b45          DCB      "  KEY_2_UP!\r\n",0
000188  595f325f
00018c  5550210d
000190  0a00    
000192  00                DCB      0
000193  00                DCB      0
                  |L11.404|
000194  20204b45          DCB      "  KEY_3_DOWN!\r\n",0
000198  595f335f
00019c  444f574e
0001a0  210d0a00
                  |L11.420|
0001a4  20204b45          DCB      "  KEY_3_UP!\r\n",0
0001a8  595f335f
0001ac  5550210d
0001b0  0a00    
0001b2  00                DCB      0
0001b3  00                DCB      0
                  |L11.436|
0001b4  20204b45          DCB      "  KEY_4_DOWN!\r\n",0
0001b8  595f345f
0001bc  444f574e
0001c0  210d0a00
                  |L11.452|
0001c4  20204b45          DCB      "  KEY_4_UP!\r\n",0
0001c8  595f345f
0001cc  5550210d
0001d0  0a00    
0001d2  00                DCB      0
0001d3  00                DCB      0
                  |L11.468|
                          DCD      RS485_Count
                  |L11.472|
                          DCD      RS485Dat

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  2d2d2d2d          DCB      "-------------------------------------------------------"
000004  2d2d2d2d
000008  2d2d2d2d
00000c  2d2d2d2d
000010  2d2d2d2d
000014  2d2d2d2d
000018  2d2d2d2d
00001c  2d2d2d2d
000020  2d2d2d2d
000024  2d2d2d2d
000028  2d2d2d2d
00002c  2d2d2d2d
000030  2d2d2d2d
000034  2d2d2d  
000037  2d2d2d2d          DCB      "------------\r\n",0
00003b  2d2d2d2d
00003f  2d2d2d2d
000043  0d0a00  

                          AREA ||.data||, DATA, ALIGN=2

                  g_RxMessage
000000  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
                  g_RxMessFlag
000008  00                DCB      0x00
                  OutFlag
000009  00                DCB      0x00
                  InPutCount
00000a  0000              DCB      0x00,0x00
                  g_RunningTime
                          DCD      0x00000000
                  Time_count
000010  00                DCB      0x00
                  g_FlagDWG
000011  00                DCB      0x00

                  __ARM_use_no_argv EQU 0
