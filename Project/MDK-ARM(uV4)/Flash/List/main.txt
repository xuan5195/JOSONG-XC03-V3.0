; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\flash\obj\main.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\main.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\User\bsp -I..\..\User -I"C:\Users\xuan5\Desktop\JOSONG-XS03 V3.0\Project\MDK-ARM(uV4)\RTE" -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.5.0\CMSIS\Include -IC:\Keil_v5\ARM\PACK\Keil\STM32F1xx_DFP\1.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=521 -D_RTE_ -DSTM32F10X_MD -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=.\flash\obj\main.crf ..\..\User\main.c]
                          THUMB

                          AREA ||i.CPU_IDLE||, CODE, READONLY, ALIGN=2

                  CPU_IDLE PROC
;;;34     }
;;;35     void CPU_IDLE(void)
000000  b510              PUSH     {r4,lr}
;;;36     {
;;;37     	static uint8_t g_FlagDWG=0;
;;;38     	if(++g_FlagDWG%2==0)	HardWDG_ON();
000002  490b              LDR      r1,|L1.48|
000004  7809              LDRB     r1,[r1,#0]  ; g_FlagDWG
000006  1c49              ADDS     r1,r1,#1
000008  b2c9              UXTB     r1,r1
00000a  4a09              LDR      r2,|L1.48|
00000c  7011              STRB     r1,[r2,#0]
00000e  4608              MOV      r0,r1
000010  eb0171d0          ADD      r1,r1,r0,LSR #31
000014  1049              ASRS     r1,r1,#1
000016  eba00141          SUB      r1,r0,r1,LSL #1
00001a  b921              CBNZ     r1,|L1.38|
00001c  2110              MOVS     r1,#0x10
00001e  4805              LDR      r0,|L1.52|
000020  f7fffffe          BL       GPIO_SetBits
000024  e003              B        |L1.46|
                  |L1.38|
;;;39     	else 					HardWDG_OFF();
000026  2110              MOVS     r1,#0x10
000028  4802              LDR      r0,|L1.52|
00002a  f7fffffe          BL       GPIO_ResetBits
                  |L1.46|
;;;40     }
00002e  bd10              POP      {r4,pc}
;;;41     
                          ENDP

                  |L1.48|
                          DCD      g_FlagDWG
                  |L1.52|
                          DCD      0x40010800

                          AREA ||i.Delay||, CODE, READONLY, ALIGN=1

                  Delay PROC
;;;306    
;;;307    void Delay(__IO uint16_t nCount)
000000  b501              PUSH     {r0,lr}
;;;308    {
;;;309    	while (nCount != 0)
000002  e004              B        |L2.14|
                  |L2.4|
;;;310    	{
;;;311    		nCount--;
000004  f8bd0000          LDRH     r0,[sp,#0]
000008  1e40              SUBS     r0,r0,#1
00000a  b280              UXTH     r0,r0
00000c  9000              STR      r0,[sp,#0]
                  |L2.14|
00000e  f8bd0000          LDRH     r0,[sp,#0]            ;309
000012  2800              CMP      r0,#0                 ;309
000014  d1f6              BNE      |L2.4|
;;;312    	}
;;;313    }
000016  bd08              POP      {r3,pc}
;;;314    
                          ENDP


                          AREA ||i.InitBoard||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  InitBoard PROC
;;;264    */
;;;265    static void InitBoard(void)
000000  b510              PUSH     {r4,lr}
;;;266    {	
;;;267    	RCC_Configuration();
000002  f7fffffe          BL       RCC_Configuration
;;;268    	/* 初始化systick定时器，并启动定时中断 */
;;;269    	bsp_InitTimer(); 
000006  f7fffffe          BL       bsp_InitTimer
;;;270    	delay_init();
00000a  f7fffffe          BL       delay_init
;;;271    	delay_ms(500);
00000e  f44f70fa          MOV      r0,#0x1f4
000012  f7fffffe          BL       delay_ms
;;;272    	Init_GPIO();				//输出初始化
000016  f7fffffe          BL       Init_GPIO
;;;273    	bsp_InitKey();
00001a  f7fffffe          BL       bsp_InitKey
;;;274    	bsp_InitUart(); 	    	//初始化串口+RS485
00001e  f7fffffe          BL       bsp_InitUart
;;;275    	printf("\r\nStarting Up...\r\nJOSONG-XS03 V3.0...\r\n");
000022  a014              ADR      r0,|L3.116|
000024  f7fffffe          BL       __2printf
;;;276    	printf("VersionNo: %02X...\r\n",VERSION);
000028  2101              MOVS     r1,#1
00002a  a01c              ADR      r0,|L3.156|
00002c  f7fffffe          BL       __2printf
;;;277    	printf("SystemCoreClock: %d...\r\n",SystemCoreClock);
000030  4820              LDR      r0,|L3.180|
000032  6801              LDR      r1,[r0,#0]  ; SystemCoreClock
000034  a020              ADR      r0,|L3.184|
000036  f7fffffe          BL       __2printf
;;;278    	delay_ms(500);
00003a  f44f70fa          MOV      r0,#0x1f4
00003e  f7fffffe          BL       delay_ms
;;;279    	BspTm1639_Config();	        //TM1639初始化
000042  f7fffffe          BL       BspTm1639_Config
;;;280    	BspDht11_Config();			//温湿度传感器初始化
000046  f7fffffe          BL       BspDht11_Config
;;;281    	bsp_HC595_Config();			//HC595初始化 用于继电器输出
00004a  f7fffffe          BL       bsp_HC595_Config
;;;282    	BspInput_CD4067_Config();	//CD4067初始化 用于信号采集
00004e  f7fffffe          BL       BspInput_CD4067_Config
;;;283    	BspInput_CD4051_Config();	//CD4051*3
000052  f7fffffe          BL       BspInput_CD4051_Config
;;;284    	Bsp_CS5463_Config();
000056  f7fffffe          BL       Bsp_CS5463_Config
;;;285    	CS546x_Init(0);
00005a  2000              MOVS     r0,#0
00005c  f7fffffe          BL       CS546x_Init
;;;286    	TIM3_Int_Init(99,720-1);  	//以100khz的频率计数，0.01ms中断，计数到100 *0.01ms 为1ms 
000060  f24021cf          MOV      r1,#0x2cf
000064  2063              MOVS     r0,#0x63
000066  f7fffffe          BL       TIM3_Int_Init
;;;287    //	TIM2_Cap_Init(0xFFFF,72-1);	//以1Mhz的频率计数 
;;;288     	Adc_Init();		  		    //ADC初始化
00006a  f7fffffe          BL       Adc_Init
;;;289    	bsp_InitCQVar();
00006e  f7fffffe          BL       bsp_InitCQVar
;;;290    }
000072  bd10              POP      {r4,pc}
;;;291    
                          ENDP

                  |L3.116|
000074  0d0a5374          DCB      "\r\nStarting Up...\r\nJOSONG-XS03 V3.0...\r\n",0
000078  61727469
00007c  6e672055
000080  702e2e2e
000084  0d0a4a4f
000088  534f4e47
00008c  2d585330
000090  33205633
000094  2e302e2e
000098  2e0d0a00
                  |L3.156|
00009c  56657273          DCB      "VersionNo: %02X...\r\n",0
0000a0  696f6e4e
0000a4  6f3a2025
0000a8  3032582e
0000ac  2e2e0d0a
0000b0  00      
0000b1  00                DCB      0
0000b2  00                DCB      0
0000b3  00                DCB      0
                  |L3.180|
                          DCD      SystemCoreClock
                  |L3.184|
0000b8  53797374          DCB      "SystemCoreClock: %d...\r\n",0
0000bc  656d436f
0000c0  7265436c
0000c4  6f636b3a
0000c8  2025642e
0000cc  2e2e0d0a
0000d0  00      
0000d1  00                DCB      0
0000d2  00                DCB      0
0000d3  00                DCB      0

                          AREA ||i.Init_GPIO||, CODE, READONLY, ALIGN=2

                  Init_GPIO PROC
;;;95     
;;;96     void Init_GPIO(void)
000000  b508              PUSH     {r3,lr}
;;;97     {
;;;98     	GPIO_InitTypeDef GPIO_InitStructure;
;;;99     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); 
000002  2101              MOVS     r1,#1
000004  2004              MOVS     r0,#4
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;100    
;;;101    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;
00000a  2010              MOVS     r0,#0x10
00000c  f8ad0000          STRH     r0,[sp,#0]
;;;102    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
000010  f88d0003          STRB     r0,[sp,#3]
;;;103    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000014  2003              MOVS     r0,#3
000016  f88d0002          STRB     r0,[sp,#2]
;;;104    	GPIO_Init(GPIOA, &GPIO_InitStructure);
00001a  4669              MOV      r1,sp
00001c  4801              LDR      r0,|L4.36|
00001e  f7fffffe          BL       GPIO_Init
;;;105    }
000022  bd08              POP      {r3,pc}
;;;106    
                          ENDP

                  |L4.36|
                          DCD      0x40010800

                          AREA ||i.NVIC_Configuration||, CODE, READONLY, ALIGN=1

                  NVIC_Configuration PROC
;;;22     
;;;23     void NVIC_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;24     {
;;;25         NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);	//设置NVIC中断分组2:2位抢占优先级，2位响应优先级
000002  f44f60a0          MOV      r0,#0x500
000006  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;26     }
00000a  bd10              POP      {r4,pc}
;;;27     
                          ENDP


                          AREA ||i.PutInMemoryBuf||, CODE, READONLY, ALIGN=2

                  PutInMemoryBuf PROC
;;;59     
;;;60     void PutInMemoryBuf(u8 *Buf)	//末尾加入第一个缓存
000000  b51f              PUSH     {r0-r4,lr}
;;;61     {
000002  4604              MOV      r4,r0
;;;62         uint8_t BufDat[16]={0};
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
000008  9001              STR      r0,[sp,#4]
00000a  9002              STR      r0,[sp,#8]
00000c  9003              STR      r0,[sp,#0xc]
;;;63     	//日志存储
;;;64         BufDat[ 0] = (uint8_t)(g_RunningTime>>24); //时钟
00000e  4833              LDR      r0,|L6.220|
000010  6800              LDR      r0,[r0,#0]  ; g_RunningTime
000012  0e00              LSRS     r0,r0,#24
000014  f88d0000          STRB     r0,[sp,#0]
;;;65         BufDat[ 1] = (uint8_t)(g_RunningTime>>16); //时钟
000018  4830              LDR      r0,|L6.220|
00001a  6800              LDR      r0,[r0,#0]  ; g_RunningTime
00001c  0c00              LSRS     r0,r0,#16
00001e  f88d0001          STRB     r0,[sp,#1]
;;;66         BufDat[ 2] = (uint8_t)(g_RunningTime>>8);  //时钟
000022  482e              LDR      r0,|L6.220|
000024  8800              LDRH     r0,[r0,#0]  ; g_RunningTime
000026  0a00              LSRS     r0,r0,#8
000028  f88d0002          STRB     r0,[sp,#2]
;;;67         BufDat[ 3] = (uint8_t)(g_RunningTime);     //时钟
00002c  482b              LDR      r0,|L6.220|
00002e  7800              LDRB     r0,[r0,#0]  ; g_RunningTime
000030  f88d0003          STRB     r0,[sp,#3]
;;;68         BufDat[ 4] = Buf[1];     	//卡号0；
000034  7860              LDRB     r0,[r4,#1]
000036  f88d0004          STRB     r0,[sp,#4]
;;;69         BufDat[ 5] = Buf[2];     	//卡号1；
00003a  78a0              LDRB     r0,[r4,#2]
00003c  f88d0005          STRB     r0,[sp,#5]
;;;70         BufDat[ 6] = Buf[3];     	//卡号2；
000040  78e0              LDRB     r0,[r4,#3]
000042  f88d0006          STRB     r0,[sp,#6]
;;;71         BufDat[ 7] = Buf[4];     	//卡号3；
000046  7920              LDRB     r0,[r4,#4]
000048  f88d0007          STRB     r0,[sp,#7]
;;;72         BufDat[ 8] = Buf[8];		//校验	
00004c  7a20              LDRB     r0,[r4,#8]
00004e  f88d0008          STRB     r0,[sp,#8]
;;;73         BufDat[ 9] = Buf[ 5];     	//金额1高位
000052  7960              LDRB     r0,[r4,#5]
000054  f88d0009          STRB     r0,[sp,#9]
;;;74         BufDat[10] = Buf[ 6];     	//金额2
000058  79a0              LDRB     r0,[r4,#6]
00005a  f88d000a          STRB     r0,[sp,#0xa]
;;;75         BufDat[11] = Buf[ 7];     	//金额3
00005e  79e0              LDRB     r0,[r4,#7]
000060  f88d000b          STRB     r0,[sp,#0xb]
;;;76         BufDat[12] = Buf[ 9]&0x7F;	//DecSum高位
000064  7a60              LDRB     r0,[r4,#9]
000066  f000007f          AND      r0,r0,#0x7f
00006a  f88d000c          STRB     r0,[sp,#0xc]
;;;77         BufDat[13] = Buf[10];     	//DecSum低位
00006e  7aa0              LDRB     r0,[r4,#0xa]
000070  f88d000d          STRB     r0,[sp,#0xd]
;;;78     	
;;;79     	if((Buf[ 9]&0x80)==0x80)    BufDat[14] = 0x03;	 //连续消息标记; 
000074  7a60              LDRB     r0,[r4,#9]
000076  f0000080          AND      r0,r0,#0x80
00007a  2880              CMP      r0,#0x80
00007c  d103              BNE      |L6.134|
00007e  2003              MOVS     r0,#3
000080  f88d000e          STRB     r0,[sp,#0xe]
000084  e009              B        |L6.154|
                  |L6.134|
;;;80     	else
;;;81         {
;;;82             if( Buf[0] == 0xAA )	BufDat[14] = 0x01;  //插卡；
000086  7820              LDRB     r0,[r4,#0]
000088  28aa              CMP      r0,#0xaa
00008a  d103              BNE      |L6.148|
00008c  2001              MOVS     r0,#1
00008e  f88d000e          STRB     r0,[sp,#0xe]
000092  e002              B        |L6.154|
                  |L6.148|
;;;83             else					BufDat[14] = 0x02;  //取卡； 
000094  2002              MOVS     r0,#2
000096  f88d000e          STRB     r0,[sp,#0xe]
                  |L6.154|
;;;84     	}
;;;85         BufDat[15] = CRC8_Table(BufDat,15); 	//CRC
00009a  210f              MOVS     r1,#0xf
00009c  4668              MOV      r0,sp
00009e  f7fffffe          BL       CRC8_Table
0000a2  f88d000f          STRB     r0,[sp,#0xf]
;;;86     	
;;;87     
;;;88     	memcpy(s_gCQ.Buf[s_gCQ.Write],Buf,10);
0000a6  480e              LDR      r0,|L6.224|
0000a8  f89000a1          LDRB     r0,[r0,#0xa1]  ; s_gCQ
0000ac  490c              LDR      r1,|L6.224|
0000ae  eb011000          ADD      r0,r1,r0,LSL #4
0000b2  6821              LDR      r1,[r4,#0]
0000b4  6001              STR      r1,[r0,#0]
0000b6  6861              LDR      r1,[r4,#4]
0000b8  6041              STR      r1,[r0,#4]
0000ba  8921              LDRH     r1,[r4,#8]
0000bc  8101              STRH     r1,[r0,#8]
;;;89     
;;;90     	if (++s_gCQ.Write  >= CQ_FIFO_SIZE)
0000be  4808              LDR      r0,|L6.224|
0000c0  f89000a1          LDRB     r0,[r0,#0xa1]  ; s_gCQ
0000c4  1c40              ADDS     r0,r0,#1
0000c6  b2c0              UXTB     r0,r0
0000c8  4905              LDR      r1,|L6.224|
0000ca  f88100a1          STRB     r0,[r1,#0xa1]
0000ce  280a              CMP      r0,#0xa
0000d0  db02              BLT      |L6.216|
;;;91     	{
;;;92     		s_gCQ.Write = 0;
0000d2  2000              MOVS     r0,#0
0000d4  f88100a1          STRB     r0,[r1,#0xa1]
                  |L6.216|
;;;93     	}
;;;94     }
0000d8  bd1f              POP      {r0-r4,pc}
;;;95     
                          ENDP

0000da  0000              DCW      0x0000
                  |L6.220|
                          DCD      g_RunningTime
                  |L6.224|
                          DCD      s_gCQ

                          AREA ||i.PutOutMemoryBuf||, CODE, READONLY, ALIGN=2

                  PutOutMemoryBuf PROC
;;;42     
;;;43     uint8_t PutOutMemoryBuf(uint8_t *_Date)	//清第一个缓存
000000  b510              PUSH     {r4,lr}
;;;44     {
000002  4604              MOV      r4,r0
;;;45     	if (s_gCQ.Read == s_gCQ.Write)
000004  4811              LDR      r0,|L7.76|
000006  f89000a0          LDRB     r0,[r0,#0xa0]  ; s_gCQ
00000a  4910              LDR      r1,|L7.76|
00000c  f89110a1          LDRB     r1,[r1,#0xa1]  ; s_gCQ
000010  4288              CMP      r0,r1
000012  d101              BNE      |L7.24|
;;;46     	{
;;;47     		return CQ_NONE;
000014  2000              MOVS     r0,#0
                  |L7.22|
;;;48     	}
;;;49     	else
;;;50     	{
;;;51     		memcpy(_Date,s_gCQ.Buf[s_gCQ.Read],16);
;;;52     		if (++s_gCQ.Read >= CQ_FIFO_SIZE)
;;;53     		{
;;;54     			s_gCQ.Read = 0;
;;;55     		}
;;;56     		return CQ_OK;
;;;57     	}
;;;58     }
000016  bd10              POP      {r4,pc}
                  |L7.24|
000018  480c              LDR      r0,|L7.76|
00001a  f89000a0          LDRB     r0,[r0,#0xa0]         ;51  ; s_gCQ
00001e  4a0b              LDR      r2,|L7.76|
000020  eb021100          ADD      r1,r2,r0,LSL #4       ;51
000024  2210              MOVS     r2,#0x10              ;51
000026  4620              MOV      r0,r4                 ;51
000028  f7fffffe          BL       __aeabi_memcpy
00002c  4807              LDR      r0,|L7.76|
00002e  f89000a0          LDRB     r0,[r0,#0xa0]         ;52  ; s_gCQ
000032  1c40              ADDS     r0,r0,#1              ;52
000034  b2c0              UXTB     r0,r0                 ;52
000036  4905              LDR      r1,|L7.76|
000038  f88100a0          STRB     r0,[r1,#0xa0]         ;52
00003c  280a              CMP      r0,#0xa               ;52
00003e  db02              BLT      |L7.70|
000040  2000              MOVS     r0,#0                 ;54
000042  f88100a0          STRB     r0,[r1,#0xa0]         ;54
                  |L7.70|
000046  2001              MOVS     r0,#1                 ;56
000048  e7e5              B        |L7.22|
;;;59     
                          ENDP

00004a  0000              DCW      0x0000
                  |L7.76|
                          DCD      s_gCQ

                          AREA ||i.RCC_Configuration||, CODE, READONLY, ALIGN=1

                  RCC_Configuration PROC
;;;27     
;;;28     void RCC_Configuration(void)
000000  4770              BX       lr
;;;29     {
;;;30     //    RCC_DeInit();
;;;31     //    RCC_HSEConfig(RCC_HSE_OFF);
;;;32     //    RCC_HSICmd(ENABLE);
;;;33     //    RCC_HSEConfig(RCC_HSE_ON);
;;;34     }
;;;35     void CPU_IDLE(void)
                          ENDP


                          AREA ||i.SoftReset||, CODE, READONLY, ALIGN=2

                  SoftReset PROC
;;;106    
;;;107    void SoftReset(void)
000000  2001              MOVS     r0,#1
000002  f3808813          MSR      FAULTMASK,r0
000006  bf00              NOP      
;;;108    {
;;;109    	__set_FAULTMASK(1);		// 关闭所有中端
;;;110    	NVIC_SystemReset();		// 复位
000008  bf00              NOP      
00000a  4807              LDR      r0,|L9.40|
00000c  6800              LDR      r0,[r0,#0]
00000e  f40060e0          AND      r0,r0,#0x700
000012  4906              LDR      r1,|L9.44|
000014  4308              ORRS     r0,r0,r1
000016  1d00              ADDS     r0,r0,#4
000018  4903              LDR      r1,|L9.40|
00001a  6008              STR      r0,[r1,#0]
00001c  f3bf8f4f          DSB      
000020  bf00              NOP      
000022  bf00              NOP      
                  |L9.36|
000024  e7fe              B        |L9.36|
;;;111    }
;;;112    
                          ENDP

000026  0000              DCW      0x0000
                  |L9.40|
                          DCD      0xe000ed0c
                  |L9.44|
                          DCD      0x05fa0000

                          AREA ||i.TIM3_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM3_IRQHandler PROC
;;;294    //定时器3中断服务程序
;;;295    void TIM3_IRQHandler(void)   //TIM3中断
000000  b510              PUSH     {r4,lr}
;;;296    {
;;;297    	if (TIM_GetITStatus(TIM3, TIM_IT_Update) != RESET)  //TIM3更新中断 20ms中断
000002  2101              MOVS     r1,#1
000004  4810              LDR      r0,|L10.72|
000006  f7fffffe          BL       TIM_GetITStatus
00000a  b1d8              CBZ      r0,|L10.68|
;;;298    	{
;;;299    		if(Time_count>200)	Time_count=0;
00000c  480f              LDR      r0,|L10.76|
00000e  7800              LDRB     r0,[r0,#0]  ; Time_count
000010  28c8              CMP      r0,#0xc8
000012  dd02              BLE      |L10.26|
000014  2000              MOVS     r0,#0
000016  490d              LDR      r1,|L10.76|
000018  7008              STRB     r0,[r1,#0]
                  |L10.26|
;;;300    		Time_count++;
00001a  480c              LDR      r0,|L10.76|
00001c  7800              LDRB     r0,[r0,#0]  ; Time_count
00001e  1c40              ADDS     r0,r0,#1
000020  490a              LDR      r1,|L10.76|
000022  7008              STRB     r0,[r1,#0]
;;;301    		SysTick_ISR();	//这个函数在bsp_timer.c中 
000024  f7fffffe          BL       SysTick_ISR
;;;302    		if((Time_count%10)==0)			bsp_KeyScan();	//每10ms扫描按键一次
000028  4808              LDR      r0,|L10.76|
00002a  7800              LDRB     r0,[r0,#0]  ; Time_count
00002c  210a              MOVS     r1,#0xa
00002e  fb90f2f1          SDIV     r2,r0,r1
000032  fb010012          MLS      r0,r1,r2,r0
000036  b908              CBNZ     r0,|L10.60|
000038  f7fffffe          BL       bsp_KeyScan
                  |L10.60|
;;;303    		TIM_ClearITPendingBit(TIM3, TIM_IT_Update  );  	//清除TIMx更新中断标志 					
00003c  2101              MOVS     r1,#1
00003e  4802              LDR      r0,|L10.72|
000040  f7fffffe          BL       TIM_ClearITPendingBit
                  |L10.68|
;;;304    	}
;;;305    }
000044  bd10              POP      {r4,pc}
;;;306    
                          ENDP

000046  0000              DCW      0x0000
                  |L10.72|
                          DCD      0x40000400
                  |L10.76|
                          DCD      Time_count

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  main PROC
;;;120    */
;;;121    int main(void)
000000  b086              SUB      sp,sp,#0x18
;;;122    {
;;;123    	uint8_t DHT_Dat[5]={0},RS485Dat_Key[2]={0};
000002  2000              MOVS     r0,#0
000004  9004              STR      r0,[sp,#0x10]
000006  9005              STR      r0,[sp,#0x14]
000008  9003              STR      r0,[sp,#0xc]
;;;124    	uint8_t Time_250ms=0;
00000a  2500              MOVS     r5,#0
;;;125    	uint8_t KeyDat=0;
00000c  2400              MOVS     r4,#0
;;;126        uint8_t RunMode = 0;    //0手动模式(默认)，1主一备二，2主二备一;
00000e  2600              MOVS     r6,#0
;;;127        KMDat ApRun,BpRun;      //A/B泵 运行状态    
;;;128    	SystemInit();
000010  f7fffffe          BL       SystemInit
;;;129    	
;;;130    	InitBoard();		//硬件初始化
000014  f7fffffe          BL       InitBoard
;;;131    	BspTm1639_Show(0x01,0x00);	//上电初始化显示
000018  2100              MOVS     r1,#0
00001a  2001              MOVS     r0,#1
00001c  f7fffffe          BL       BspTm1639_Show
;;;132    	CAN_Mode_Init(CAN_SJW_1tq,CAN_BS1_4tq,CAN_BS2_3tq,75,CAN_Mode_Normal);	//CAN初始化正常模式,波特率60Kbps  //则波特率为:36M/((1+2+1)*150)= 60Kbps CAN_Normal_Init(1,2,1,150,1);   
000020  2000              MOVS     r0,#0
000022  234b              MOVS     r3,#0x4b
000024  2202              MOVS     r2,#2
000026  2103              MOVS     r1,#3
000028  9000              STR      r0,[sp,#0]
00002a  f7fffffe          BL       CAN_Mode_Init
;;;133    	printf("CAN_Mode_Init,CAN_Baud: 60Kbps...\r\n");
00002e  a0a2              ADR      r0,|L11.696|
000030  f7fffffe          BL       __2printf
;;;134    	
;;;135        printf("-------------------------------------------------------------------\r\n");
000034  48a9              LDR      r0,|L11.732|
000036  f7fffffe          BL       __2printf
;;;136    	bsp_StartTimer(1, 200);			//定时器1周期 200毫秒
00003a  21c8              MOVS     r1,#0xc8
00003c  2001              MOVS     r0,#1
00003e  f7fffffe          BL       bsp_StartTimer
;;;137    	KMOFF_Show(ALARMALL);
000042  f64070ff          MOV      r0,#0xfff
000046  f7fffffe          BL       KMOFF_Show
;;;138    	HC595_E1_ON();HC595_E2_ON();
00004a  2104              MOVS     r1,#4
00004c  48a4              LDR      r0,|L11.736|
00004e  f7fffffe          BL       GPIO_ResetBits
000052  2108              MOVS     r1,#8
000054  48a2              LDR      r0,|L11.736|
000056  f7fffffe          BL       GPIO_ResetBits
;;;139        RS485Dat_LED1_ON();	//远程通信指示灯
00005a  f7fffffe          BL       RS485Dat_LED1_ON
;;;140        RS485Dat_LED2_ON(); //主板通信指示灯	
00005e  f7fffffe          BL       RS485Dat_LED2_ON
;;;141        RS485Dat_LED12_ON();//A泵停止指示灯
000062  f7fffffe          BL       RS485Dat_LED12_ON
;;;142        RS485Dat_LED18_ON();//B泵停止指示灯
000066  f7fffffe          BL       RS485Dat_LED18_ON
;;;143        RS485Dat_LED16_ON();//手动模式指示灯
00006a  f7fffffe          BL       RS485Dat_LED16_ON
                  |L11.110|
;;;144        while (1)
00006e  e122              B        |L11.694|
                  |L11.112|
;;;145    	{
;;;146    		CPU_IDLE();
000070  f7fffffe          BL       CPU_IDLE
;;;147    		if ( bsp_CheckTimer(1) )	//软定时器
000074  2001              MOVS     r0,#1
000076  f7fffffe          BL       bsp_CheckTimer
00007a  2800              CMP      r0,#0
00007c  d0f7              BEQ      |L11.110|
;;;148    		{
;;;149    			bsp_StartTimer(1, 200);	//启动下个定时周期
00007e  21c8              MOVS     r1,#0xc8
000080  2001              MOVS     r0,#1
000082  f7fffffe          BL       bsp_StartTimer
;;;150    			if(Time_250ms<20)	Time_250ms++;
000086  2d14              CMP      r5,#0x14
000088  da02              BGE      |L11.144|
00008a  1c68              ADDS     r0,r5,#1
00008c  b2c5              UXTB     r5,r0
00008e  e005              B        |L11.156|
                  |L11.144|
;;;151    			else	
;;;152    			{	
;;;153    				Time_250ms=0;
000090  2500              MOVS     r5,#0
;;;154                    if(DHT11_Read_Data((uint8_t *)DHT_Dat)==0){;}
000092  a804              ADD      r0,sp,#0x10
000094  f7fffffe          BL       DHT11_Read_Data
;;;155                    Get_InputValue();
000098  f7fffffe          BL       Get_InputValue
                  |L11.156|
;;;156    			}
;;;157                //ReadDat_CD4067();
;;;158                ReadInputDat();
00009c  f7fffffe          BL       ReadInputDat
;;;159                DisplaySendDat();
0000a0  f7fffffe          BL       DisplaySendDat
;;;160    			KeyDat = bsp_GetKey();
0000a4  f7fffffe          BL       bsp_GetKey
0000a8  4604              MOV      r4,r0
;;;161    			if(KeyDat!=KEY_NONE)	//按键检测及数据处理
0000aa  2c00              CMP      r4,#0
0000ac  d034              BEQ      |L11.280|
;;;162    			{
;;;163    				switch (KeyDat)
0000ae  2c0c              CMP      r4,#0xc
0000b0  d230              BCS      |L11.276|
0000b2  e8dff004          TBB      [pc,r4]
0000b6  0607              DCB      0x06,0x07
0000b8  0b2f0f13          DCB      0x0b,0x2f,0x0f,0x13
0000bc  2f171d2f          DCB      0x2f,0x17,0x1d,0x2f
0000c0  2329              DCB      0x23,0x29
;;;164    				{
;;;165    					case KEY_NONE:	//无按键按下
;;;166    						break;
0000c2  e028              B        |L11.278|
;;;167    					case KEY_1_DOWN:	//						
;;;168    						printf("  KEY_1_DOWN!\r\n");
0000c4  a087              ADR      r0,|L11.740|
0000c6  f7fffffe          BL       __2printf
;;;169    						break;
0000ca  e024              B        |L11.278|
;;;170    					case KEY_1_UP:		//
;;;171    						printf("  KEY_1_UP!\r\n");
0000cc  a089              ADR      r0,|L11.756|
0000ce  f7fffffe          BL       __2printf
;;;172    						break;
0000d2  e020              B        |L11.278|
;;;173    					case KEY_2_DOWN:	//
;;;174    						printf("  KEY_2_DOWN!\r\n");						
0000d4  a08b              ADR      r0,|L11.772|
0000d6  f7fffffe          BL       __2printf
;;;175    						break;
0000da  e01c              B        |L11.278|
;;;176    					case KEY_2_UP:		//
;;;177    						printf("  KEY_2_UP!\r\n");
0000dc  a08d              ADR      r0,|L11.788|
0000de  f7fffffe          BL       __2printf
;;;178    						break;
0000e2  e018              B        |L11.278|
;;;179    					case KEY_3_DOWN:	//
;;;180                            RS485Dat_LED1_ON();
0000e4  f7fffffe          BL       RS485Dat_LED1_ON
;;;181    						printf("  KEY_3_DOWN!\r\n");
0000e8  a08e              ADR      r0,|L11.804|
0000ea  f7fffffe          BL       __2printf
;;;182    						break;
0000ee  e012              B        |L11.278|
;;;183    					case KEY_3_UP:		//
;;;184                            RS485Dat_LED1_OFF();
0000f0  f7fffffe          BL       RS485Dat_LED1_OFF
;;;185    						printf("  KEY_3_UP!\r\n");
0000f4  a08f              ADR      r0,|L11.820|
0000f6  f7fffffe          BL       __2printf
;;;186    						break;
0000fa  e00c              B        |L11.278|
;;;187    					case KEY_4_DOWN:	//
;;;188                            RS485Dat_LED2_ON();
0000fc  f7fffffe          BL       RS485Dat_LED2_ON
;;;189    						printf("  KEY_4_DOWN!\r\n");						
000100  a090              ADR      r0,|L11.836|
000102  f7fffffe          BL       __2printf
;;;190    						break;
000106  e006              B        |L11.278|
;;;191    					case KEY_4_UP:		//
;;;192                            RS485Dat_LED2_OFF();
000108  f7fffffe          BL       RS485Dat_LED2_OFF
;;;193    						printf("  KEY_4_UP!\r\n");
00010c  a091              ADR      r0,|L11.852|
00010e  f7fffffe          BL       __2printf
;;;194    						break;
000112  e000              B        |L11.278|
                  |L11.276|
;;;195    					default:
;;;196    						break;
000114  bf00              NOP      
                  |L11.278|
000116  bf00              NOP                            ;166
                  |L11.280|
;;;197    				}
;;;198    			}
;;;199    
;;;200    			RS485_ReceiveDat();
000118  f7fffffe          BL       RS485_ReceiveDat
;;;201    			if( ( 0x80 & RS485_Count ) == 0x80 )	//接收到数据
00011c  4891              LDR      r0,|L11.868|
00011e  7800              LDRB     r0,[r0,#0]  ; RS485_Count
000120  f0000080          AND      r0,r0,#0x80
000124  2880              CMP      r0,#0x80
000126  d142              BNE      |L11.430|
;;;202    			{
;;;203    				RS485_Count = 0;
000128  2000              MOVS     r0,#0
00012a  498e              LDR      r1,|L11.868|
00012c  7008              STRB     r0,[r1,#0]
;;;204                    RS485Dat_Key[0] = RS485Dat[4];  RS485Dat_Key[1] = RS485Dat[5];  //获取按键值
00012e  488e              LDR      r0,|L11.872|
000130  7900              LDRB     r0,[r0,#4]  ; RS485Dat
000132  f88d000c          STRB     r0,[sp,#0xc]
000136  488c              LDR      r0,|L11.872|
000138  7940              LDRB     r0,[r0,#5]  ; RS485Dat
00013a  f88d000d          STRB     r0,[sp,#0xd]
;;;205                    if((RS485Dat_Key[0]!=0x00)||(RS485Dat_Key[1]!=0x00))
00013e  f89d000c          LDRB     r0,[sp,#0xc]
000142  b910              CBNZ     r0,|L11.330|
000144  f89d000d          LDRB     r0,[sp,#0xd]
000148  b130              CBZ      r0,|L11.344|
                  |L11.330|
;;;206                    printf("RS485_ReceiveDat(),%02X,%02X.\r\n",RS485Dat_Key[0],RS485Dat_Key[1]);
00014a  f89d200d          LDRB     r2,[sp,#0xd]
00014e  f89d100c          LDRB     r1,[sp,#0xc]
000152  a086              ADR      r0,|L11.876|
000154  f7fffffe          BL       __2printf
                  |L11.344|
;;;207                    if(RS485Dat_Key[1]&0x01==0x01){;}       //系统复位
000158  f89d000d          LDRB     r0,[sp,#0xd]
00015c  f0000001          AND      r0,r0,#1
000160  bb28              CBNZ     r0,|L11.430|
;;;208                    else if((RS485Dat_Key[1]&0x08)==0x08){RunMode=1;RS485Dat_Key[0]=0;RS485Dat_Key[1]=0;}  //主一备二
000162  f89d000d          LDRB     r0,[sp,#0xd]
000166  f0000008          AND      r0,r0,#8
00016a  2808              CMP      r0,#8
00016c  d106              BNE      |L11.380|
00016e  2601              MOVS     r6,#1
000170  2000              MOVS     r0,#0
000172  f88d000c          STRB     r0,[sp,#0xc]
000176  f88d000d          STRB     r0,[sp,#0xd]
00017a  e018              B        |L11.430|
                  |L11.380|
;;;209                    else if((RS485Dat_Key[1]&0x10)==0x10){RunMode=0;RS485Dat_Key[0]=0;RS485Dat_Key[1]=0;}  //手动模式
00017c  f89d000d          LDRB     r0,[sp,#0xd]
000180  f0000010          AND      r0,r0,#0x10
000184  2810              CMP      r0,#0x10
000186  d106              BNE      |L11.406|
000188  2600              MOVS     r6,#0
00018a  2000              MOVS     r0,#0
00018c  f88d000c          STRB     r0,[sp,#0xc]
000190  f88d000d          STRB     r0,[sp,#0xd]
000194  e00b              B        |L11.430|
                  |L11.406|
;;;210                    else if((RS485Dat_Key[1]&0x20)==0x20){RunMode=2;RS485Dat_Key[0]=0;RS485Dat_Key[1]=0;}  //主二备一
000196  f89d000d          LDRB     r0,[sp,#0xd]
00019a  f0000020          AND      r0,r0,#0x20
00019e  2820              CMP      r0,#0x20
0001a0  d105              BNE      |L11.430|
0001a2  2602              MOVS     r6,#2
0001a4  2000              MOVS     r0,#0
0001a6  f88d000c          STRB     r0,[sp,#0xc]
0001aa  f88d000d          STRB     r0,[sp,#0xd]
                  |L11.430|
;;;211    			}
;;;212                if(RunMode==0)  //手动模式
0001ae  2e00              CMP      r6,#0
0001b0  d114              BNE      |L11.476|
;;;213                {
;;;214                    if((RS485Dat_Key[1]&0x02)==0x02)//A泵停止        
0001b2  f89d000d          LDRB     r0,[sp,#0xd]
0001b6  f0000002          AND      r0,r0,#2
0001ba  2802              CMP      r0,#2
0001bc  d10f              BNE      |L11.478|
;;;215                    {   
;;;216                        ApRun.Statue=Stop;
0001be  2000              MOVS     r0,#0
0001c0  f88d0008          STRB     r0,[sp,#8]
;;;217                        printf("手动模式,A泵停止.\r\n");
0001c4  a071              ADR      r0,|L11.908|
0001c6  f7fffffe          BL       __2printf
;;;218                        KMOFF_Show(AKM1RUN);KMOFF_Show(AKM2RUN);KMOFF_Show(AKM3RUN);
0001ca  2001              MOVS     r0,#1
0001cc  f7fffffe          BL       KMOFF_Show
0001d0  2002              MOVS     r0,#2
0001d2  f7fffffe          BL       KMOFF_Show
0001d6  2004              MOVS     r0,#4
0001d8  f7fffffe          BL       KMOFF_Show
                  |L11.476|
0001dc  e06b              B        |L11.694|
                  |L11.478|
;;;219                    }  
;;;220                    else if((RS485Dat_Key[0]&0x01)==0x01)   //A泵低速
0001de  f89d000c          LDRB     r0,[sp,#0xc]
0001e2  f0000001          AND      r0,r0,#1
0001e6  b178              CBZ      r0,|L11.520|
;;;221                    {   
;;;222                        ApRun.Statue=Slow;     
0001e8  2001              MOVS     r0,#1
0001ea  f88d0008          STRB     r0,[sp,#8]
;;;223                        printf("手动模式,A泵低速.\r\n");
0001ee  a06c              ADR      r0,|L11.928|
0001f0  f7fffffe          BL       __2printf
;;;224                        KMON_Show(AKM1RUN); KMON_Show(AKM2RUN); KMOFF_Show(AKM3RUN);
0001f4  2001              MOVS     r0,#1
0001f6  f7fffffe          BL       KMON_Show
0001fa  2002              MOVS     r0,#2
0001fc  f7fffffe          BL       KMON_Show
000200  2004              MOVS     r0,#4
000202  f7fffffe          BL       KMOFF_Show
000206  e056              B        |L11.694|
                  |L11.520|
;;;225                    }  
;;;226                    else if((RS485Dat_Key[1]&0x04)==0x04)   //A泵高速
000208  f89d000d          LDRB     r0,[sp,#0xd]
00020c  f0000004          AND      r0,r0,#4
000210  2804              CMP      r0,#4
000212  d10f              BNE      |L11.564|
;;;227                    {   
;;;228                        ApRun.Statue=HighSpeed;
000214  2002              MOVS     r0,#2
000216  f88d0008          STRB     r0,[sp,#8]
;;;229                        printf("手动模式,A泵高速.\r\n");
00021a  a066              ADR      r0,|L11.948|
00021c  f7fffffe          BL       __2printf
;;;230                        KMON_Show(AKM1RUN); KMOFF_Show(AKM2RUN);KMON_Show(AKM3RUN); 
000220  2001              MOVS     r0,#1
000222  f7fffffe          BL       KMON_Show
000226  2002              MOVS     r0,#2
000228  f7fffffe          BL       KMOFF_Show
00022c  2004              MOVS     r0,#4
00022e  f7fffffe          BL       KMON_Show
000232  e040              B        |L11.694|
                  |L11.564|
;;;231                    }  
;;;232                    else if((RS485Dat_Key[1]&0x40)==0x40)   //B泵停止
000234  f89d000d          LDRB     r0,[sp,#0xd]
000238  f0000040          AND      r0,r0,#0x40
00023c  2840              CMP      r0,#0x40
00023e  d10f              BNE      |L11.608|
;;;233                    {   
;;;234                        BpRun.Statue=Stop;     
000240  2000              MOVS     r0,#0
000242  f88d0004          STRB     r0,[sp,#4]
;;;235                        printf("手动模式,B泵停止.\r\n");
000246  a060              ADR      r0,|L11.968|
000248  f7fffffe          BL       __2printf
;;;236                        KMOFF_Show(BKM1RUN);KMOFF_Show(BKM2RUN);KMOFF_Show(BKM3RUN);
00024c  2008              MOVS     r0,#8
00024e  f7fffffe          BL       KMOFF_Show
000252  2010              MOVS     r0,#0x10
000254  f7fffffe          BL       KMOFF_Show
000258  2020              MOVS     r0,#0x20
00025a  f7fffffe          BL       KMOFF_Show
00025e  e02a              B        |L11.694|
                  |L11.608|
;;;237                    }  
;;;238                    else if((RS485Dat_Key[0]&0x02)==0x02)   //B泵低速
000260  f89d000c          LDRB     r0,[sp,#0xc]
000264  f0000002          AND      r0,r0,#2
000268  2802              CMP      r0,#2
00026a  d10f              BNE      |L11.652|
;;;239                    {   
;;;240                        BpRun.Statue=Slow;     
00026c  2001              MOVS     r0,#1
00026e  f88d0004          STRB     r0,[sp,#4]
;;;241                        printf("手动模式,B泵低速.\r\n");
000272  a05a              ADR      r0,|L11.988|
000274  f7fffffe          BL       __2printf
;;;242                        KMON_Show(BKM1RUN); KMON_Show(BKM2RUN); KMOFF_Show(BKM3RUN);
000278  2008              MOVS     r0,#8
00027a  f7fffffe          BL       KMON_Show
00027e  2010              MOVS     r0,#0x10
000280  f7fffffe          BL       KMON_Show
000284  2020              MOVS     r0,#0x20
000286  f7fffffe          BL       KMOFF_Show
00028a  e014              B        |L11.694|
                  |L11.652|
;;;243                    }  
;;;244                    else if((RS485Dat_Key[1]&0x80)==0x80)   //B泵高速 
00028c  f89d000d          LDRB     r0,[sp,#0xd]
000290  f0000080          AND      r0,r0,#0x80
000294  2880              CMP      r0,#0x80
000296  d10e              BNE      |L11.694|
;;;245                    {   
;;;246                        BpRun.Statue=HighSpeed;
000298  2002              MOVS     r0,#2
00029a  f88d0004          STRB     r0,[sp,#4]
;;;247                        printf("手动模式,B泵高速.\r\n");
00029e  a054              ADR      r0,|L11.1008|
0002a0  f7fffffe          BL       __2printf
;;;248                        KMON_Show(BKM1RUN); KMOFF_Show(BKM2RUN);KMON_Show(BKM3RUN); 
0002a4  2008              MOVS     r0,#8
0002a6  f7fffffe          BL       KMON_Show
0002aa  2010              MOVS     r0,#0x10
0002ac  f7fffffe          BL       KMOFF_Show
0002b0  2020              MOVS     r0,#0x20
0002b2  f7fffffe          BL       KMON_Show
                  |L11.694|
0002b6  e6db              B        |L11.112|
;;;249                    }                 
;;;250                }
;;;251    
;;;252    		}
;;;253    
;;;254    	}
;;;255    }
;;;256    
                          ENDP

                  |L11.696|
0002b8  43414e5f          DCB      "CAN_Mode_Init,CAN_Baud: 60Kbps...\r\n",0
0002bc  4d6f6465
0002c0  5f496e69
0002c4  742c4341
0002c8  4e5f4261
0002cc  75643a20
0002d0  36304b62
0002d4  70732e2e
0002d8  2e0d0a00
                  |L11.732|
                          DCD      ||.conststring||
                  |L11.736|
                          DCD      0x40010800
                  |L11.740|
0002e4  20204b45          DCB      "  KEY_1_DOWN!\r\n",0
0002e8  595f315f
0002ec  444f574e
0002f0  210d0a00
                  |L11.756|
0002f4  20204b45          DCB      "  KEY_1_UP!\r\n",0
0002f8  595f315f
0002fc  5550210d
000300  0a00    
000302  00                DCB      0
000303  00                DCB      0
                  |L11.772|
000304  20204b45          DCB      "  KEY_2_DOWN!\r\n",0
000308  595f325f
00030c  444f574e
000310  210d0a00
                  |L11.788|
000314  20204b45          DCB      "  KEY_2_UP!\r\n",0
000318  595f325f
00031c  5550210d
000320  0a00    
000322  00                DCB      0
000323  00                DCB      0
                  |L11.804|
000324  20204b45          DCB      "  KEY_3_DOWN!\r\n",0
000328  595f335f
00032c  444f574e
000330  210d0a00
                  |L11.820|
000334  20204b45          DCB      "  KEY_3_UP!\r\n",0
000338  595f335f
00033c  5550210d
000340  0a00    
000342  00                DCB      0
000343  00                DCB      0
                  |L11.836|
000344  20204b45          DCB      "  KEY_4_DOWN!\r\n",0
000348  595f345f
00034c  444f574e
000350  210d0a00
                  |L11.852|
000354  20204b45          DCB      "  KEY_4_UP!\r\n",0
000358  595f345f
00035c  5550210d
000360  0a00    
000362  00                DCB      0
000363  00                DCB      0
                  |L11.868|
                          DCD      RS485_Count
                  |L11.872|
                          DCD      RS485Dat
                  |L11.876|
00036c  52533438          DCB      "RS485_ReceiveDat(),%02X,%02X.\r\n",0
000370  355f5265
000374  63656976
000378  65446174
00037c  28292c25
000380  3032582c
000384  25303258
000388  2e0d0a00
                  |L11.908|
00038c  cad6b6af          DCB      202,214,182,175,196,163,202,189,",A",177,195,205,163,214
000390  c4a3cabd
000394  2c41b1c3
000398  cda3d6  
00039b  b92e0d0a          DCB      185,".\r\n",0
00039f  00      
                  |L11.928|
0003a0  cad6b6af          DCB      202,214,182,175,196,163,202,189,",A",177,195,181,205,203
0003a4  c4a3cabd
0003a8  2c41b1c3
0003ac  b5cdcb  
0003af  d92e0d0a          DCB      217,".\r\n",0
0003b3  00      
                  |L11.948|
0003b4  cad6b6af          DCB      202,214,182,175,196,163,202,189,",A",177,195,184,223,203
0003b8  c4a3cabd
0003bc  2c41b1c3
0003c0  b8dfcb  
0003c3  d92e0d0a          DCB      217,".\r\n",0
0003c7  00      
                  |L11.968|
0003c8  cad6b6af          DCB      202,214,182,175,196,163,202,189,",B",177,195,205,163,214
0003cc  c4a3cabd
0003d0  2c42b1c3
0003d4  cda3d6  
0003d7  b92e0d0a          DCB      185,".\r\n",0
0003db  00      
                  |L11.988|
0003dc  cad6b6af          DCB      202,214,182,175,196,163,202,189,",B",177,195,181,205,203
0003e0  c4a3cabd
0003e4  2c42b1c3
0003e8  b5cdcb  
0003eb  d92e0d0a          DCB      217,".\r\n",0
0003ef  00      
                  |L11.1008|
0003f0  cad6b6af          DCB      202,214,182,175,196,163,202,189,",B",177,195,184,223,203
0003f4  c4a3cabd
0003f8  2c42b1c3
0003fc  b8dfcb  
0003ff  d92e0d0a          DCB      217,".\r\n",0
000403  00      

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  2d2d2d2d          DCB      "-------------------------------------------------------"
000004  2d2d2d2d
000008  2d2d2d2d
00000c  2d2d2d2d
000010  2d2d2d2d
000014  2d2d2d2d
000018  2d2d2d2d
00001c  2d2d2d2d
000020  2d2d2d2d
000024  2d2d2d2d
000028  2d2d2d2d
00002c  2d2d2d2d
000030  2d2d2d2d
000034  2d2d2d  
000037  2d2d2d2d          DCB      "------------\r\n",0
00003b  2d2d2d2d
00003f  2d2d2d2d
000043  0d0a00  

                          AREA ||.data||, DATA, ALIGN=2

                  g_RxMessage
000000  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000
                  g_RxMessFlag
000008  00                DCB      0x00
                  OutFlag
000009  00                DCB      0x00
                  InPutCount
00000a  0000              DCB      0x00,0x00
                  g_RunningTime
                          DCD      0x00000000
                  Time_count
000010  00                DCB      0x00
                  g_FlagDWG
000011  00                DCB      0x00

                  __ARM_use_no_argv EQU 0
